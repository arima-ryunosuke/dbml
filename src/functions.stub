<?php
# Don't touch this code. This is auto generated.
namespace ryunosuke\dbml;

if (!defined('ryunosuke\\dbml\\IS_OWNSELF')) {
    define('ryunosuke\\dbml\\IS_OWNSELF', 2);
}

if (!defined('ryunosuke\\dbml\\IS_PUBLIC')) {
    define('ryunosuke\\dbml\\IS_PUBLIC', 4);
}

if (!defined('ryunosuke\\dbml\\IS_PROTECTED')) {
    define('ryunosuke\\dbml\\IS_PROTECTED', 8);
}

if (!defined('ryunosuke\\dbml\\IS_PRIVATE')) {
    define('ryunosuke\\dbml\\IS_PRIVATE', 16);
}

if (!defined('ryunosuke\\dbml\\EN_MONTH_SHORT')) {
    define('ryunosuke\\dbml\\EN_MONTH_SHORT', [
        1  => "jan",
        2  => "feb",
        3  => "mar",
        4  => "apr",
        5  => "may",
        6  => "jun",
        7  => "jul",
        8  => "aug",
        9  => "sep",
        10 => "oct",
        11 => "nov",
        12 => "dec",
    ]);
}

if (!defined('ryunosuke\\dbml\\EN_MONTH_LONG')) {
    define('ryunosuke\\dbml\\EN_MONTH_LONG', [
        1  => "january",
        2  => "february",
        3  => "march",
        4  => "april",
        5  => "may",
        6  => "june",
        7  => "july",
        8  => "august",
        9  => "september",
        10 => "october",
        11 => "november",
        12 => "december",
    ]);
}

if (!defined('ryunosuke\\dbml\\JP_ERA')) {
    define('ryunosuke\\dbml\\JP_ERA', [
        [
            "name"  => "令和",
            "abbr"  => "R",
            "since" => 1556636400,
        ],
        [
            "name"  => "平成",
            "abbr"  => "H",
            "since" => 600188400,
        ],
        [
            "name"  => "昭和",
            "abbr"  => "S",
            "since" => -1357635600,
        ],
        [
            "name"  => "大正",
            "abbr"  => "T",
            "since" => -1812186000,
        ],
        [
            "name"  => "明治",
            "abbr"  => "M",
            "since" => -3216790800,
        ],
    ]);
}

if (!defined('ryunosuke\\dbml\\GENERAL_MIMETYPE')) {
    define('ryunosuke\\dbml\\GENERAL_MIMETYPE', [
        "csv"   => "text/csv",
        "dcm"   => "application/dicom",
        "dvc"   => "application/dvcs",
        "finf"  => "application/fastinfoset",
        "stk"   => "application/hyperstudio",
        "ipfix" => "application/ipfix",
        "json"  => "application/json",
        "mrc"   => "application/marc",
        "nb"    => "application/mathematica",
        "ma"    => "application/mathematica",
        "mb"    => "application/mathematica",
        "mbox"  => "application/mbox",
        "m21"   => "application/mp21",
        "mp21"  => "application/mp21",
        "xls"   => "application/vnd.ms-excel",
        "doc"   => "application/vnd.ms-word",
        "mxf"   => "application/mxf",
        "oda"   => "application/oda",
        "ogx"   => "application/ogg",
        "pdf"   => "application/pdf",
        "p10"   => "application/pkcs10",
        "ai"    => "application/postscript",
        "eps"   => "application/postscript",
        "ps"    => "application/postscript",
        "rtf"   => "application/rtf",
        "sdp"   => "application/sdp",
        "siv"   => "application/sieve",
        "sieve" => "application/sieve",
        "smil"  => "application/smil",
        "smi"   => "application/smil",
        "sml"   => "application/smil",
        "gram"  => "application/srgs",
        "xml"   => "text/xml",
        "zip"   => "application/x-zip-compressed",
        "xlsx"  => "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "docx"  => "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        726     => "audio/32kadpcm",
        "amr"   => "audio/AMR",
        "at3"   => "audio/ATRAC3",
        "aa3"   => "audio/ATRAC3",
        "omg"   => "audio/ATRAC3",
        "evc"   => "audio/EVRC",
        "evb"   => "audio/EVRCB",
        "evw"   => "audio/EVRCWB",
        "l16"   => "audio/L16",
        "smv"   => "audio/SMV",
        "ac3"   => "audio/ac3",
        "au"    => "audio/basic",
        "snd"   => "audio/basic",
        "dls"   => "audio/dls",
        "lbc"   => "audio/iLBC",
        "mid"   => "audio/midi",
        "midi"  => "audio/midi",
        "kar"   => "audio/midi",
        "mpga"  => "audio/mpeg",
        "mp1"   => "audio/mpeg",
        "mp2"   => "audio/mpeg",
        "mp3"   => "audio/mpeg",
        "oga"   => "audio/ogg",
        "ogg"   => "audio/ogg",
        "spx"   => "audio/ogg",
        "qcp"   => "audio/qcelp",
        "bmp"   => "image/bmp",
        "fits"  => "image/fits",
        "fit"   => "image/fits",
        "fts"   => "image/fits",
        "gif"   => "image/gif",
        "ief"   => "image/ief",
        "jp2"   => "image/jp2",
        "jpg2"  => "image/jp2",
        "jpeg"  => "image/jpeg",
        "jpg"   => "image/jpeg",
        "jpe"   => "image/jpeg",
        "jfif"  => "image/jpeg",
        "jpm"   => "image/jpm",
        "jpgm"  => "image/jpm",
        "jpx"   => "image/jpx",
        "jpf"   => "image/jpx",
        "svg"   => "image/svg+xml",
        "png"   => "image/png",
        "t38"   => "image/t38",
        "tiff"  => "image/tiff",
        "tif"   => "image/tiff",
        "u8msg" => "message/global",
        "eml"   => "message/rfc822",
        "mail"  => "message/rfc822",
        "art"   => "message/rfc822",
        "igs"   => "model/iges",
        "iges"  => "model/iges",
        "msh"   => "model/mesh",
        "mesh"  => "model/mesh",
        "silo"  => "model/mesh",
        "wrl"   => "model/vrml",
        "vrml"  => "model/vrml",
        "ics"   => "text/calendar",
        "ifb"   => "text/calendar",
        "css"   => "text/css",
        "soa"   => "text/dns",
        "zone"  => "text/dns",
        "html"  => "text/html",
        "htm"   => "text/html",
        "js"    => "text/javascript",
        "asc"   => "text/plain",
        "txt"   => "text/plain",
        "text"  => "text/plain",
        "pm"    => "text/plain",
        "el"    => "text/plain",
        "c"     => "text/plain",
        "h"     => "text/plain",
        "cc"    => "text/plain",
        "hh"    => "text/plain",
        "cxx"   => "text/plain",
        "hxx"   => "text/plain",
        "f90"   => "text/plain",
        "rtx"   => "text/richtext",
        "sgml"  => "text/sgml",
        "sgm"   => "text/sgml",
        "3gp"   => "video/3gpp",
        "3gpp"  => "video/3gpp",
        "3g2"   => "video/3gpp2",
        "3gpp2" => "video/3gpp2",
        "mj2"   => "video/mj2",
        "mjp2"  => "video/mj2",
        "mp4"   => "video/mp4",
        "mpg4"  => "video/mp4",
        "mpeg"  => "video/mpeg",
        "mpg"   => "video/mpeg",
        "mpe"   => "video/mpeg",
        "ogv"   => "video/ogg",
        "qt"    => "video/quicktime",
        "mov"   => "video/quicktime",
        "webm"  => "video/webm",
    ]);
}

if (!defined('ryunosuke\\dbml\\GLOB_RECURSIVE')) {
    define('ryunosuke\\dbml\\GLOB_RECURSIVE', 65536);
}

if (!defined('ryunosuke\\dbml\\JSON_MAX_DEPTH')) {
    define('ryunosuke\\dbml\\JSON_MAX_DEPTH', -1);
}

if (!defined('ryunosuke\\dbml\\JSON_INDENT')) {
    define('ryunosuke\\dbml\\JSON_INDENT', -71);
}

if (!defined('ryunosuke\\dbml\\JSON_CLOSURE')) {
    define('ryunosuke\\dbml\\JSON_CLOSURE', -72);
}

if (!defined('ryunosuke\\dbml\\JSON_NEST_LEVEL')) {
    define('ryunosuke\\dbml\\JSON_NEST_LEVEL', -73);
}

if (!defined('ryunosuke\\dbml\\JSON_INLINE_LEVEL')) {
    define('ryunosuke\\dbml\\JSON_INLINE_LEVEL', -74);
}

if (!defined('ryunosuke\\dbml\\JSON_INLINE_SCALARLIST')) {
    define('ryunosuke\\dbml\\JSON_INLINE_SCALARLIST', -75);
}

if (!defined('ryunosuke\\dbml\\JSON_ES5')) {
    define('ryunosuke\\dbml\\JSON_ES5', -100);
}

if (!defined('ryunosuke\\dbml\\JSON_INT_AS_STRING')) {
    define('ryunosuke\\dbml\\JSON_INT_AS_STRING', -101);
}

if (!defined('ryunosuke\\dbml\\JSON_FLOAT_AS_STRING')) {
    define('ryunosuke\\dbml\\JSON_FLOAT_AS_STRING', -102);
}

if (!defined('ryunosuke\\dbml\\JSON_TRAILING_COMMA')) {
    define('ryunosuke\\dbml\\JSON_TRAILING_COMMA', -103);
}

if (!defined('ryunosuke\\dbml\\JSON_COMMENT_PREFIX')) {
    define('ryunosuke\\dbml\\JSON_COMMENT_PREFIX', -104);
}

if (!defined('ryunosuke\\dbml\\JSON_TEMPLATE_LITERAL')) {
    define('ryunosuke\\dbml\\JSON_TEMPLATE_LITERAL', -105);
}

if (!defined('ryunosuke\\dbml\\JSON_BARE_AS_STRING')) {
    define('ryunosuke\\dbml\\JSON_BARE_AS_STRING', -106);
}

if (!defined('ryunosuke\\dbml\\JSON_OBJECT_HANDLER')) {
    define('ryunosuke\\dbml\\JSON_OBJECT_HANDLER', -107);
}

if (!defined('ryunosuke\\dbml\\JSON_ESCAPE_SINGLE_QUOTE')) {
    define('ryunosuke\\dbml\\JSON_ESCAPE_SINGLE_QUOTE', -108);
}

if (!defined('ryunosuke\\dbml\\SI_UNITS')) {
    define('ryunosuke\\dbml\\SI_UNITS', [
        -8 => ["y"],
        -7 => ["z"],
        -6 => ["a"],
        -5 => ["f"],
        -4 => ["p"],
        -3 => ["n"],
        -2 => ["u", "μ", "µ"],
        -1 => ["m"],
        0  => [],
        1  => ["k", "K"],
        2  => ["M"],
        3  => ["G"],
        4  => ["T"],
        5  => ["P"],
        6  => ["E"],
        7  => ["Z"],
        8  => ["Y"],
    ]);
}

if (!defined('ryunosuke\\dbml\\SORT_STRICT')) {
    define('ryunosuke\\dbml\\SORT_STRICT', 256);
}

assert(!function_exists('ryunosuke\\dbml\\array_add') || (new \ReflectionFunction('ryunosuke\\dbml\\array_add'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_add')) {
    /**
     * 配列の+演算子の関数版
     *
     * Example:
     * ```php
     * // ただの加算の関数版なので同じキーは上書きされない
     * that(array_add(['a', 'b', 'c'], ['X']))->isSame(['a', 'b', 'c']);
     * // 異なるキーは生える
     * that(array_add(['a', 'b', 'c'], ['x' => 'X']))->isSame(['a', 'b', 'c', 'x' => 'X']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array ...$variadic 足す配列（可変引数）
     * @return array 足された配列
     */
    function array_add(...$variadic)
    {
        $array = [];
        foreach ($variadic as $arg) {
            $array += $arg;
        }
        return $array;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_and') || (new \ReflectionFunction('ryunosuke\\dbml\\array_and'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_and')) {
    /**
     * 全要素が true になるなら true を返す（1つでも false なら false を返す）
     *
     * $callback が要求するならキーも渡ってくる。
     *
     * Example:
     * ```php
     * that(array_and([true, true]))->isTrue();
     * that(array_and([true, false]))->isFalse();
     * that(array_and([false, false]))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param ?callable $callback 評価クロージャ。 null なら値そのもので評価
     * @param bool|mixed $default 空配列の場合のデフォルト値
     * @return bool 全要素が true なら true
     */
    function array_and($array, $callback = null, $default = true)
    {
        if (is_empty($array)) {
            return $default;
        }

        $callback = func_user_func_array($callback);

        $n = 0;
        foreach ($array as $k => $v) {
            if (!$callback($v, $k, $n++)) {
                return false;
            }
        }
        return true;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_assort') || (new \ReflectionFunction('ryunosuke\\dbml\\array_assort'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_assort')) {
    /**
     * 配列をコールバックに従って分類する
     *
     * コールバックは配列で複数与える。そのキーが結果配列のキーになるが、一切マッチしなくてもキー自体は作られる。
     * 複数のコールバックにマッチしたらその分代入されるし、どれにもマッチしなければ代入されない。
     * つまり5個の配列を分類したからと言って、全要素数が5個になるとは限らない（多い場合も少ない場合もある）。
     *
     * $rule が要求するならキーも渡ってくる。
     *
     * Example:
     * ```php
     * // lt2(2より小さい)で分類
     * $lt2 = fn($v) => $v < 2;
     * that(array_assort([1, 2, 3], [
     *     'lt2' => $lt2,
     * ]))->isSame([
     *     'lt2' => [1],
     * ]);
     * // lt3(3より小さい)、ctd(ctype_digit)で分類（両方に属する要素が存在する）
     * $lt3 = fn($v) => $v < 3;
     * that(array_assort(['1', '2', '3'], [
     *     'lt3' => $lt3,
     *     'ctd' => 'ctype_digit',
     * ]))->isSame([
     *     'lt3' => ['1', '2'],
     *     'ctd' => ['1', '2', '3'],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable[] $rules 分類ルール。[key => callable] 形式
     * @return array 分類された新しい配列
     */
    function array_assort($array, $rules)
    {
        $result = array_fill_keys(array_keys($rules), []);
        foreach ($rules as $name => $rule) {
            $rule = func_user_func_array($rule);
            $n = 0;
            foreach ($array as $k => $v) {
                if ($rule($v, $k, $n++)) {
                    $result[$name][$k] = $v;
                }
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_convert') || (new \ReflectionFunction('ryunosuke\\dbml\\array_convert'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_convert')) {
    /**
     * 配列の各要素に再帰的にコールバックを適用して変換する
     *
     * $callback は下記の仕様。
     *
     * 引数は (キー, 値, 今まで処理したキー配列) で渡ってくる。
     * 返り値は新しいキーを返す。
     *
     * - 文字列や数値を返すとそれがキーとして使われる
     * - null を返すと元のキーがそのまま使われる
     * - true を返すと数値連番が振られる
     * - false を返すとその要素は無かったことになる
     * - 配列を返すとその配列で完全に置換される
     *
     * $apply_array=false で要素が配列の場合は再帰され、コールバックが適用されない（array_walk_recursive と同じ仕様）。
     *
     * $apply_array=true だと配列かは問わず全ての要素にコールバックが適用される。
     * 配列も渡ってきてしまうのでコールバック内部で is_array 判定が必要になる場合がある。
     *
     * 「map も filter も可能でキー変更可能かつ再帰的」というとてもマッチョな関数。
     * 複雑だが実質的には「キーも設定できる array_walk_recursive」のように振る舞う（そしてそのような使い方を想定している）。
     *
     * Example:
     * ```php
     * $array = [
     *    'k1' => 'v1',
     *    'k2' => [
     *        'k21' => 'v21',
     *        'k22' => [
     *            'k221' => 'v221',
     *            'k222' => 'v222',
     *        ],
     *        'k23' => 'v23',
     *    ],
     * ];
     * // 全要素に 'prefix-' を付与する。キーには '_' をつける。ただし 'k21' はそのままとする。さらに 'k22' はまるごと伏せる。 'k23' は数値キーになる
     * $callback = function ($k, &$v) {
     *     if ($k === 'k21') return null;
     *     if ($k === 'k22') return false;
     *     if ($k === 'k23') return true;
     *     if (!is_array($v)) $v = "prefix-$v";
     *     return "_$k";
     * };
     * that(array_convert($array, $callback, true))->isSame([
     *     '_k1' => 'prefix-v1',
     *     '_k2' => [
     *         'k21' => 'v21',
     *         0     => 'v23',
     *     ],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 対象配列
     * @param callable $callback 適用するコールバック
     * @param bool $apply_array 配列要素にもコールバックを適用するか
     * @return array 変換された配列
     */
    function array_convert($array, $callback, $apply_array = false)
    {
        $recursive = function (&$result, $array, $history, $callback) use (&$recursive, $apply_array) {
            $sequences = [];
            foreach ($array as $key => $value) {
                $is_array = is_array($value);
                $newkey = $key;
                // 配列で $apply_array あるいは非配列の場合にコールバック適用
                if (($is_array && $apply_array) || !$is_array) {
                    $newkey = $callback($key, $value, $history);
                }
                // 配列は置換
                if (is_array($newkey)) {
                    foreach ($newkey as $k => $v) {
                        $result[$k] = $v;
                    }
                    continue;
                }
                // false はスルー
                if ($newkey === false) {
                    continue;
                }
                // true は数値連番
                if ($newkey === true) {
                    if ($is_array) {
                        $sequences["_$key"] = $value;
                    }
                    else {
                        $sequences[] = $value;
                    }
                    continue;
                }
                // null は元のキー
                if ($newkey === null) {
                    $newkey = $key;
                }
                // 配列と非配列で代入の仕方が異なる
                if ($is_array) {
                    $history[] = $key;
                    $result[$newkey] = [];
                    $recursive($result[$newkey], $value, $history, $callback);
                    array_pop($history);
                }
                else {
                    $result[$newkey] = $value;
                }
            }
            // 数値連番は上書きを防ぐためにあとでやる
            foreach ($sequences as $key => $value) {
                if (is_string($key)) {
                    $history[] = substr($key, 1);
                    $v = [];
                    $result[] = &$v;
                    $recursive($v, $value, $history, $callback);
                    array_pop($history);
                    unset($v);
                }
                else {
                    $result[] = $value;
                }
            }
        };

        $result = [];
        $recursive($result, $array, [], $callback);
        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_count') || (new \ReflectionFunction('ryunosuke\\dbml\\array_count'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_count')) {
    /**
     * 配列をコールバックに従ってカウントする
     *
     * コールバックが true 相当を返した要素をカウントして返す。
     * 普通に使う分には `count(array_filter($array, $callback))` とほとんど同じだが、下記の点が微妙に異なる。
     *
     * - $callback が要求するならキーも渡ってくる
     * - $callback には配列が渡せる。配列を渡した場合は件数を配列で返す（Example 参照）
     *
     * $recursive に true を渡すと再帰的に動作する。
     * 末端・配列を問わずに呼び出されるので場合によっては is_array などの判定が必要になる。
     *
     * Example:
     * ```php
     * $array = ['hoge', 'fuga', 'piyo'];
     * // 'o' を含むものの数（2個）
     * that(array_count($array, fn($s) => strpos($s, 'o') !== false))->isSame(2);
     * // 'a' と 'o' を含むものをそれぞれ（1個と2個）
     * that(array_count($array, [
     *     'a' => fn($s) => strpos($s, 'a') !== false,
     *     'o' => fn($s) => strpos($s, 'o') !== false,
     * ]))->isSame([
     *     'a' => 1,
     *     'o' => 2,
     * ]);
     *
     * // 再帰版
     * $array = [
     *     ['1', '2', '3'],
     *     ['a', 'b', 'c'],
     *     ['X', 'Y', 'Z'],
     *     [[[['a', 'M', 'Z']]]],
     * ];
     * that(array_count($array, [
     *     'lower' => fn($v) => !is_array($v) && ctype_lower($v),
     *     'upper' => fn($v) => !is_array($v) && ctype_upper($v),
     *     'array' => fn($v) => is_array($v),
     * ], true))->is([
     *     'lower' => 4, // 小文字の数
     *     'upper' => 5, // 大文字の数
     *     'array' => 7, // 配列の数
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable $callback カウントルール。配列も渡せる
     * @param bool $recursive 再帰フラグ
     * @return int|array 条件一致した件数
     */
    function array_count($array, $callback, $recursive = false)
    {
        // 配列が来た場合はまるで動作が異なる（再帰でもいいがそれだと旨味がない。複数欲しいなら呼び出し元で複数回呼べば良い。ワンループに閉じ込めるからこそメリットがある））
        if (is_array($callback) && !is_callable($callback)) {
            $result = array_fill_keys(array_keys($callback), 0);
            foreach ($callback as $name => $rule) {
                $rule = func_user_func_array($rule);
                $n = 0;
                foreach ($array as $k => $v) {
                    if ($rule($v, $k, $n++)) {
                        $result[$name]++;
                    }
                    if ($recursive && is_iterable($v)) {
                        $result[$name] += array_count($v, $rule, $recursive);
                    }
                }
            }
            return $result;
        }

        $callback = func_user_func_array($callback);
        $result = 0;
        $n = 0;
        foreach ($array as $k => $v) {
            if ($callback($v, $k, $n++)) {
                $result++;
            }
            if ($recursive && is_iterable($v)) {
                $result += array_count($v, $callback, $recursive);
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_depth') || (new \ReflectionFunction('ryunosuke\\dbml\\array_depth'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_depth')) {
    /**
     * 配列の次元数を返す
     *
     * フラット配列は 1 と定義する。
     * つまり、配列を与える限りは 0 以下を返すことはない。
     *
     * 第2引数 $max_depth を与えるとその階層になった時点で走査を打ち切る。
     * 「1階層のみか？」などを調べるときは指定したほうが高速に動作する。
     *
     * Example:
     * ```php
     * that(array_depth([]))->isSame(1);
     * that(array_depth(['hoge']))->isSame(1);
     * that(array_depth([['nest1' => ['nest2']]]))->isSame(3);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 調べる配列
     * @param int|null $max_depth 最大階層数
     * @return int 次元数。素のフラット配列は 1
     */
    function array_depth($array, $max_depth = null)
    {
        assert((is_null($max_depth)) || $max_depth > 0);

        $main = function ($array, $depth) use (&$main, $max_depth) {
            // $max_depth を超えているなら打ち切る
            if ($max_depth !== null && $depth >= $max_depth) {
                return 1;
            }

            // 配列以外に興味はない
            $arrays = array_filter($array, 'is_array');

            // ネストしない配列は 1 と定義
            if (!$arrays) {
                return 1;
            }

            // 配下の内で最大を返す
            return 1 + max(array_map(fn($v) => $main($v, $depth + 1), $arrays));
        };

        return $main($array, 1);
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_each') || (new \ReflectionFunction('ryunosuke\\dbml\\array_each'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_each')) {
    /**
     * array_reduce の参照版（のようなもの）
     *
     * 配列をループで回し、その途中経過、値、キー、連番をコールバック引数で渡して最終的な結果を返り値として返す。
     * array_reduce と少し似てるが、下記の点が異なる。
     *
     * - いわゆる $carry は返り値で表すのではなく、参照引数で表す
     * - 値だけでなくキー、連番も渡ってくる
     * - 巨大配列の場合でも速度劣化が少ない（array_reduce に巨大配列を渡すと実用にならないレベルで遅くなる）
     *
     * $callback の引数は `($value, $key, $n)` （$n はキーとは関係がない 0 ～ 要素数-1 の通し連番）。
     *
     * 返り値ではなく参照引数なので return する必要はない（ワンライナーが書きやすくなる）。
     * 返り値が空くのでループ制御に用いる。
     * 今のところ $callback が false を返すとそこで break するのみ。
     *
     * 第3引数を省略した場合、**クロージャの第1引数のデフォルト値が使われる**。
     * これは特筆すべき動作で、不格好な第3引数を完全に省略することができる（サンプルコードを参照）。
     * ただし「php の文法違反（今のところエラーにはならないし、全てにデフォルト値をつければ一応回避可能）」「リフレクションを使う（ほんの少し遅くなる）」などの弊害が有るので推奨はしない。
     * （ただ、「意図していることをコードで表す」といった観点ではこの記法の方が正しいとも思う）。
     *
     * Example:
     * ```php
     * // 全要素を文字列的に足し合わせる
     * that(array_each([1, 2, 3, 4, 5], function (&$carry, $v) {$carry .= $v;}, ''))->isSame('12345');
     * // 値をキーにして要素を2乗値にする
     * that(array_each([1, 2, 3, 4, 5], function (&$carry, $v) {$carry[$v] = $v * $v;}, []))->isSame([
     *     1 => 1,
     *     2 => 4,
     *     3 => 9,
     *     4 => 16,
     *     5 => 25,
     * ]);
     * // 上記と同じ。ただし、3 で break する
     * that(array_each([1, 2, 3, 4, 5], function (&$carry, $v, $k){
     *     if ($k === 3) return false;
     *     $carry[$v] = $v * $v;
     * }, []))->isSame([
     *     1 => 1,
     *     2 => 4,
     *     3 => 9,
     * ]);
     *
     * // 下記は完全に同じ（第3引数の代わりにデフォルト引数を使っている）
     * that(array_each([1, 2, 3], function (&$carry = [], $v = null) {
     *         $carry[$v] = $v * $v;
     *     }))->isSame(array_each([1, 2, 3], function (&$carry, $v) {
     *         $carry[$v] = $v * $v;
     *     }, [])
     *     // 個人的に↑のようなぶら下がり引数があまり好きではない（クロージャを最後の引数にしたい）
     * );
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable $callback 評価クロージャ。(&$carry, $key, $value) を受ける
     * @param mixed $default ループの最初や空の場合に適用される値
     * @return mixed each した結果
     */
    function array_each($array, $callback, $default = null)
    {
        if (func_num_args() === 2) {
            /** @var \ReflectionFunction $ref */
            $ref = reflect_callable($callback);
            $params = $ref->getParameters();
            if ($params[0]->isDefaultValueAvailable()) {
                $default = $params[0]->getDefaultValue();
            }
        }

        $n = 0;
        foreach ($array as $k => $v) {
            $return = $callback($default, $v, $k, $n++);
            if ($return === false) {
                break;
            }
        }
        return $default;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_explode') || (new \ReflectionFunction('ryunosuke\\dbml\\array_explode'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_explode')) {
    /**
     * 配列を指定条件で分割する
     *
     * 文字列の explode を更に一階層掘り下げたイメージ。
     * $condition で指定された要素は結果配列に含まれない。
     *
     * $condition にはクロージャが指定できる。クロージャの場合は true 相当を返した場合に分割要素とみなされる。
     * 引数は (値, キー)の順番。
     *
     * $limit に負数を与えると「その絶対値-1までを結合したものと残り」を返す。
     * 端的に言えば「正数を与えると後詰めでその個数で返す」「負数を与えると前詰めでその（絶対値）個数で返す」という動作になる。
     *
     * Example:
     * ```php
     * // null 要素で分割
     * that(array_explode(['a', null, 'b', 'c'], null))->isSame([['a'], [2 => 'b', 3 => 'c']]);
     * // クロージャで分割（大文字で分割）
     * that(array_explode(['a', 'B', 'c', 'D', 'e'], fn($v) => ctype_upper($v)))->isSame([['a'], [2 => 'c'], [4 => 'e']]);
     * // 負数指定
     * that(array_explode(['a', null, 'b', null, 'c'], null, -2))->isSame([[0 => 'a', 1 => null, 2 => 'b'], [4 => 'c']]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param mixed $condition 分割条件
     * @param int $limit 最大分割数
     * @return array 分割された配列
     */
    function array_explode($array, $condition, $limit = \PHP_INT_MAX)
    {
        $array = arrayval($array, false);

        $limit = (int) $limit;
        if ($limit < 0) {
            // キーまで考慮するとかなりややこしくなるので富豪的にやる
            $reverse = array_explode(array_reverse($array, true), $condition, -$limit);
            $reverse = array_map(fn($v) => array_reverse($v, true), $reverse);
            return array_reverse($reverse);
        }
        // explode において 0 は 1 と等しい
        if ($limit === 0) {
            $limit = 1;
        }

        $result = [];
        $chunk = [];
        $n = -1;
        foreach ($array as $k => $v) {
            $n++;

            if ($limit === 1) {
                $chunk = array_slice($array, $n, null, true);
                break;
            }

            if ($condition instanceof \Closure) {
                $match = $condition($v, $k, $n);
            }
            else {
                $match = $condition === $v;
            }

            if ($match) {
                $limit--;
                $result[] = $chunk;
                $chunk = [];
            }
            else {
                $chunk[$k] = $v;
            }
        }
        $result[] = $chunk;
        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_find_first') || (new \ReflectionFunction('ryunosuke\\dbml\\array_find_first'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_find_first')) {
    /**
     * array_search のクロージャ版のようなもの
     *
     * コールバックの返り値が true 相当のものを返す。
     * $is_key に true を与えるとそのキーを返す（デフォルトの動作）。
     * $is_key に false を与えるとコールバックの結果を返す。
     *
     * この関数は論理値 FALSE を返す可能性がありますが、FALSE として評価される値を返す可能性もあります。
     *
     * Example:
     * ```php
     * // 最初に見つかったキーを返す
     * that(array_find_first(['a', '8', '9'], 'ctype_digit'))->isSame(1);
     * that(array_find_first(['a', 'b', 'b'], fn($v) => $v === 'b'))->isSame(1);
     * // 最初に見つかったコールバック結果を返す（最初の数字の2乗を返す）
     * $ifnumeric2power = fn($v) => ctype_digit($v) ? $v * $v : false;
     * that(array_find_first(['a', '8', '9'], $ifnumeric2power, false))->isSame(64);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 調べる配列
     * @param callable $callback 評価コールバック
     * @param bool $is_key キーを返すか否か
     * @return mixed コールバックが true を返した最初のキー。存在しなかったら null
     */
    function array_find_first($array, $callback, $is_key = true)
    {
        $callback = func_user_func_array($callback);

        $n = 0;
        foreach ($array as $k => $v) {
            $result = $callback($v, $k, $n++);
            if ($result) {
                if ($is_key) {
                    return $k;
                }
                return $result;
            }
        }
        return null;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_flatten') || (new \ReflectionFunction('ryunosuke\\dbml\\array_flatten'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_flatten')) {
    /**
     * 多階層配列をフラットに展開する
     *
     * 巷にあふれている実装と違って、 ["$pkey.$ckey" => $value] 形式の配列でも返せる。
     * $delimiter で区切り文字を指定した場合にそのようになる。
     * $delimiter = null の場合に本当の配列で返す（巷の実装と同じ）。
     *
     * Example:
     * ```php
     * $array = [
     *    'k1' => 'v1',
     *    'k2' => [
     *        'k21' => 'v21',
     *        'k22' => [
     *            'k221' => 'v221',
     *            'k222' => 'v222',
     *            'k223' => [1, 2, 3],
     *        ],
     *    ],
     * ];
     * // 区切り文字指定なし
     * that(array_flatten($array))->isSame([
     *    0 => 'v1',
     *    1 => 'v21',
     *    2 => 'v221',
     *    3 => 'v222',
     *    4 => 1,
     *    5 => 2,
     *    6 => 3,
     * ]);
     * // 区切り文字指定
     * that(array_flatten($array, '.'))->isSame([
     *    'k1'            => 'v1',
     *    'k2.k21'        => 'v21',
     *    'k2.k22.k221'   => 'v221',
     *    'k2.k22.k222'   => 'v222',
     *    'k2.k22.k223.0' => 1,
     *    'k2.k22.k223.1' => 2,
     *    'k2.k22.k223.2' => 3,
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param string|\Closure|null $delimiter キーの区切り文字。 null を与えると連番になる
     * @return array フラット化された配列
     */
    function array_flatten($array, $delimiter = null)
    {
        $result = [];
        $core = function ($array, $delimiter, $parents) use (&$core, &$result) {
            foreach ($array as $k => $v) {
                $keys = $parents;
                $keys[] = $k;
                if (is_iterable($v)) {
                    $core($v, $delimiter, $keys);
                }
                else {
                    if ($delimiter === null) {
                        $result[] = $v;
                    }
                    elseif ($delimiter instanceof \Closure) {
                        $result[$delimiter($keys)] = $v;
                    }
                    else {
                        $result[implode($delimiter, $keys)] = $v;
                    }
                }
            }
        };

        $core($array, $delimiter, []);
        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_get') || (new \ReflectionFunction('ryunosuke\\dbml\\array_get'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_get')) {
    /**
     * デフォルト値付きの配列値取得
     *
     * 存在しない場合は $default を返す。
     *
     * $key に配列を与えるとそれらの値の配列を返す（lookup 的な動作）。
     * その場合、$default が活きるのは「全て無かった場合」となる。
     *
     * さらに $key が配列の場合に限り、 $default を省略すると空配列として動作する。
     *
     * 同様に、$key にクロージャを与えると、その返り値が true 相当のものを返す。
     * その際、 $default が配列なら一致するものを配列で返し、配列でないなら単値で返す。
     *
     * Example:
     * ```php
     * // 単純取得
     * that(array_get(['a', 'b', 'c'], 1))->isSame('b');
     * // 単純デフォルト
     * that(array_get(['a', 'b', 'c'], 9, 999))->isSame(999);
     * // 配列取得
     * that(array_get(['a', 'b', 'c'], [0, 2]))->isSame([0 => 'a', 2 => 'c']);
     * // 配列部分取得
     * that(array_get(['a', 'b', 'c'], [0, 9]))->isSame([0 => 'a']);
     * // 配列デフォルト（null ではなく [] を返す）
     * that(array_get(['a', 'b', 'c'], [9]))->isSame([]);
     * // クロージャ指定＆単値（コールバックが true を返す最初の要素）
     * that(array_get(['a', 'b', 'c'], fn($v) => in_array($v, ['b', 'c'])))->isSame('b');
     * // クロージャ指定＆配列（コールバックが true を返すもの）
     * that(array_get(['a', 'b', 'c'], fn($v) => in_array($v, ['b', 'c']), []))->isSame([1 => 'b', 2 => 'c']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array|\ArrayAccess $array 配列
     * @param string|int|array|\Closure $key 取得したいキー。配列を与えると全て返す。クロージャの場合は true 相当を返す
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 指定したキーの値
     */
    function array_get($array, $key, $default = null)
    {
        if (is_array($key)) {
            $result = [];
            foreach ($key as $k) {
                if (array_keys_exist($k, $array)) {
                    $result[$k] = $array[$k];
                }
            }
            if (!$result) {
                // 明示的に与えられていないなら [] を使用する
                if (func_num_args() === 2) {
                    $default = [];
                }
                return $default;
            }
            return $result;
        }

        if ($key instanceof \Closure) {
            $result = [];
            $n = 0;
            foreach ($array as $k => $v) {
                if ($key($v, $k, $n++)) {
                    if (func_num_args() === 2) {
                        return $v;
                    }
                    $result[$k] = $v;
                }
            }
            if (!$result) {
                return $default;
            }
            return $result;
        }

        if (array_keys_exist($key, $array)) {
            return $array[$key];
        }
        return $default;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_implode') || (new \ReflectionFunction('ryunosuke\\dbml\\array_implode'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_implode')) {
    /**
     * 配列の各要素の間に要素を差し込む
     *
     * 歴史的な理由はないが、引数をどちらの順番でも受けつけることが可能。
     * ただし、$glue を先に渡すパターンの場合は配列指定が可変引数渡しになる。
     *
     * 文字キーは保存されるが数値キーは再割り振りされる。
     *
     * Example:
     * ```php
     * // (配列, 要素) の呼び出し
     * that(array_implode(['a', 'b', 'c'], 'X'))->isSame(['a', 'X', 'b', 'X', 'c']);
     * // (要素, ...配列) の呼び出し
     * that(array_implode('X', 'a', 'b', 'c'))->isSame(['a', 'X', 'b', 'X', 'c']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable|string $array 対象配列
     * @param string $glue 差し込む要素
     * @return array 差し込まれた配列
     */
    function array_implode($array, $glue)
    {
        // 第1引数が回せない場合は引数を入れ替えて可変引数パターン
        if (!is_array($array) && !$array instanceof \Traversable) {
            return array_implode(array_slice(func_get_args(), 1), $array);
        }

        $result = [];
        foreach ($array as $k => $v) {
            if (is_int($k)) {
                $result[] = $v;
            }
            else {
                $result[$k] = $v;
            }
            $result[] = $glue;
        }
        array_pop($result);
        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_keys_exist') || (new \ReflectionFunction('ryunosuke\\dbml\\array_keys_exist'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_keys_exist')) {
    /**
     * array_key_exists の複数版
     *
     * 指定キーが全て存在するなら true を返す。
     * 配列ではなく単一文字列を与えても動作する（array_key_exists と全く同じ動作になる）。
     *
     * $keys に空を与えると例外を投げる。
     * $keys に配列を与えるとキーで潜ってチェックする（Example 参照）。
     *
     * Example:
     * ```php
     * // すべて含むので true
     * that(array_keys_exist(['a', 'b', 'c'], ['a' => 'A', 'b' => 'B', 'c' => 'C']))->isTrue();
     * // N は含まないので false
     * that(array_keys_exist(['a', 'b', 'N'], ['a' => 'A', 'b' => 'B', 'c' => 'C']))->isFalse();
     * // 配列を与えると潜る（日本語で言えば「a というキーと、x というキーとその中に x1, x2 というキーがあるか？」）
     * that(array_keys_exist(['a', 'x' => ['x1', 'x2']], ['a' => 'A', 'x' => ['x1' => 'X1', 'x2' => 'X2']]))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array|string $keys 調べるキー
     * @param array|\ArrayAccess $array 調べる配列
     * @return bool 指定キーが全て存在するなら true
     */
    function array_keys_exist($keys, $array)
    {
        $keys = is_iterable($keys) ? $keys : [$keys];
        if (is_empty($keys)) {
            throw new \InvalidArgumentException('$keys is empty.');
        }

        $is_arrayaccess = $array instanceof \ArrayAccess;

        foreach ($keys as $k => $key) {
            if (is_array($key)) {
                // まずそのキーをチェックして
                if (!array_keys_exist($k, $array)) {
                    return false;
                }
                // あるなら再帰する
                if (!array_keys_exist($key, $array[$k])) {
                    return false;
                }
            }
            elseif ($is_arrayaccess) {
                if (!$array->offsetExists($key)) {
                    return false;
                }
            }
            elseif (!array_key_exists($key, $array)) {
                return false;
            }
        }
        return true;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_kvmap') || (new \ReflectionFunction('ryunosuke\\dbml\\array_kvmap'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_kvmap')) {
    /**
     * 配列の各キー・値にコールバックを適用する
     *
     * $callback は (キー, 値, $callback) が渡ってくるので 「その位置に配置したい配列」を返せばそこに置換される。
     * つまり、空配列を返せばそのキー・値は消えることになるし、複数の配列を返せば要素が増えることになる。
     * ただし、数値キーは新しく採番される。
     * null を返すと特別扱いで、そのキー・値をそのまま維持する。
     * iterable を返す必要があるが、もし iterable でない場合は配列キャストされる。
     *
     * 「map も filter も可能でキー変更可能」というとてもマッチョな関数。
     * 実質的には「数値キーが再採番される再帰的でない array_convert」のように振る舞う。
     * ただし、再帰処理はないので自前で管理する必要がある。
     *
     * Example:
     * ```php
     * $array = [
     *    'a' => 'A',
     *    'b' => 'B',
     *    'c' => 'C',
     *    'd' => 'D',
     * ];
     * // キーに '_' 、値に 'prefix-' を付与。'b' は一切何もしない。'c' は値のみ。'd' はそれ自体伏せる
     * that(array_kvmap($array, function ($k, $v) {
     *     if ($k === 'b') return null;
     *     if ($k === 'd') return [];
     *     if ($k !== 'c') $k = "_$k";
     *     return [$k => "prefix-$v"];
     * }))->isSame([
     *     '_a' => 'prefix-A',
     *     'b'  => 'B',
     *     'c'  => 'prefix-C',
     * ]);
     *
     * // 複数返せばその分増える（要素の水増し）
     * that(array_kvmap($array, fn($k, $v) => [
     *     "{$k}1" => "{$v}1",
     *     "{$k}2" => "{$v}2",
     * ]))->isSame([
     *    'a1' => 'A1',
     *    'a2' => 'A2',
     *    'b1' => 'B1',
     *    'b2' => 'B2',
     *    'c1' => 'C1',
     *    'c2' => 'C2',
     *    'd1' => 'D1',
     *    'd2' => 'D2',
     * ]);
     *
     * // $callback には $callback 自体も渡ってくるので再帰も比較的楽に書ける
     * that(array_kvmap([
     *     'x' => [
     *         'X',
     *         'y' => [
     *             'Y',
     *             'z' => ['Z'],
     *         ],
     *     ],
     * ], function ($k, $v, $callback) {
     *     // 配列だったら再帰する
     *     return ["_$k" => is_array($v) ? array_kvmap($v, $callback) : "prefix-$v"];
     * }))->isSame([
     *     "_x" => [
     *         "_0" => "prefix-X",
     *         "_y" => [
     *             "_0" => "prefix-Y",
     *             "_z" => [
     *                 "_0" => "prefix-Z",
     *             ],
     *         ],
     *     ],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable $callback 適用するコールバック
     * @return array 変換された配列
     */
    function array_kvmap($array, $callback)
    {
        $result = [];
        foreach ($array as $k => $v) {
            $kv = $callback($k, $v, $callback) ?? [$k => $v];
            if (!is_iterable($kv)) {
                $kv = [$kv];
            }
            // $result = array_merge($result, $kv); // 遅すぎる
            foreach ($kv as $k2 => $v2) {
                if (is_int($k2)) {
                    $result[] = $v2;
                }
                else {
                    $result[$k2] = $v2;
                }
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_lookup') || (new \ReflectionFunction('ryunosuke\\dbml\\array_lookup'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_lookup')) {
    /**
     * キー保存可能な array_column
     *
     * array_column は キーを保存することが出来ないが、この関数は引数を2つだけ与えるとキーはそのままで array_column 相当の配列を返す。
     * 逆に第3引数にクロージャを与えるとその結果をキーにすることが出来る。
     *
     * $column_key に配列を与えるとそれだけの配列を返す。
     *
     * Example:
     * ```php
     * $array = [
     *     11 => ['id' => 1, 'name' => 'name1', 'status' => true],
     *     12 => ['id' => 2, 'name' => 'name2', 'status' => false],
     *     13 => ['id' => 3, 'name' => 'name3', 'status' => true],
     * ];
     * // 第3引数を渡せば array_column と全く同じ
     * that(array_lookup($array, 'name', 'id'))->isSame(array_column($array, 'name', 'id'));
     * that(array_lookup($array, 'name', null))->isSame(array_column($array, 'name', null));
     * // 省略すればキーが保存される
     * that(array_lookup($array, 'name'))->isSame([
     *     11 => 'name1',
     *     12 => 'name2',
     *     13 => 'name3',
     * ]);
     * // クロージャを指定すればキーが生成される
     * that(array_lookup($array, 'name', fn($v, $k) => $k * 2))->isSame([
     *     22 => 'name1',
     *     24 => 'name2',
     *     26 => 'name3',
     * ]);
     * // $column_key に配列を与えるとそれだけの配列を返す
     * that(array_lookup($array, ['id', 'status']))->isSame([
     *     11 => ['id' => 1, 'status' => true],
     *     12 => ['id' => 2, 'status' => false],
     *     13 => ['id' => 3, 'status' => true],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param array|string|null $column_key 値となるキー
     * @param string|\Closure|null $index_key キーとなるキー
     * @return array 新しい配列
     */
    function array_lookup($array, $column_key = null, $index_key = null)
    {
        $array = arrayval($array, false);

        if (is_array($column_key)) {
            $array = array_maps($array, fn($row) => array_pickup($row, $column_key));
            $column_key = null;
        }

        if ($index_key instanceof \Closure) {
            return array_combine((array) array_maps($array, $index_key), array_column($array, $column_key));
        }
        if (func_num_args() === 3) {
            return array_column($array, $column_key, $index_key);
        }
        return array_combine(array_keys($array), array_column($array, $column_key));
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_map_recursive') || (new \ReflectionFunction('ryunosuke\\dbml\\array_map_recursive'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_map_recursive')) {
    /**
     * array_map の再帰版
     *
     * 下記の点で少し array_map とは挙動が異なる。
     *
     * - 配列だけでなく iterable も対象になる（引数で指定可能。デフォルト true）
     *     - つまりオブジェクト構造は維持されず、結果はすべて配列になる
     * - 値だけでなくキーも渡ってくる
     *
     * Example:
     * ```php
     * // デフォルトでは array_walk 等と同様に葉のみが渡ってくる（iterable も対象になる）
     * that(array_map_recursive([
     *     'k' => 'v',
     *     'c' => new \ArrayObject([
     *         'k1' => 'v1',
     *         'k2' => 'v2',
     *     ]),
     * ], 'strtoupper'))->isSame([
     *     'k' => 'V',
     *     'c' => [
     *         'k1' => 'V1',
     *         'k2' => 'V2',
     *     ],
     * ]);
     *
     * // ただし、その挙動は引数で変更可能
     * that(array_map_recursive([
     *     'k' => 'v',
     *     'c' => new \ArrayObject([
     *         'k1' => 'v1',
     *         'k2' => 'v2',
     *     ]),
     * ], 'gettype', false))->isSame([
     *     'k' => 'string',
     *     'c' => 'object',
     * ]);
     *
     * // さらに、自身にも適用できる（呼び出しは子が先で、本当の意味で「すべての要素」で呼び出される）
     * that(array_map_recursive([
     *     'k' => 'v',
     *     'c' => [
     *         'k1' => 'v1',
     *         'k2' => 'v2',
     *     ],
     * ], function ($v) {
     *     // 配列は stdclass 化、それ以外は大文字化
     *     return is_array($v) ? (object) $v : strtoupper($v);
     * }, true, true))->is((object) [
     *     'k' => 'V',
     *     'c' => (object) [
     *         'k1' => 'V1',
     *         'k2' => 'V2',
     *     ],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable $callback 評価クロージャ
     * @param bool $iterable is_iterable で判定するか
     * @param bool $apply_array 配列要素にもコールバックを適用するか
     * @return array map された新しい配列
     */
    function array_map_recursive($array, $callback, $iterable = true, $apply_array = false)
    {
        $callback = func_user_func_array($callback);

        // ↑の変換を再帰ごとにやるのは現実的ではないのでクロージャに閉じ込めて再帰する
        $main = static function ($array, $parent) use (&$main, $callback, $iterable, $apply_array) {
            $result = [];
            $n = 0;
            foreach ($array as $k => $v) {
                if (($iterable && is_iterable($v)) || (!$iterable && is_array($v))) {
                    $result[$k] = $main($v, $k);
                }
                else {
                    $result[$k] = $callback($v, $k, $n++);
                }
            }
            if ($apply_array) {
                return $callback($result, $parent, null);
            }
            return $result;
        };

        return $main($array, null);
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_maps') || (new \ReflectionFunction('ryunosuke\\dbml\\array_maps'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_maps')) {
    /**
     * 複数コールバックを指定できる array_map
     *
     * 指定したコールバックで複数回回してマップする。
     * `array_maps($array, $f, $g)` は `array_map($g, array_map($f, $array))` とほぼ等しい。
     * ただし、引数は順番が違う（可変引数のため）し、コールバックが要求するならキーも渡ってくる。
     * さらに文字列関数で "..." から始まっているなら可変引数としてコールする。
     *
     * 少し変わった仕様として、コールバックに [$method => $args] を付けるとそれはメソッド呼び出しになる。
     * つまり各要素 $v に対して `$v->$method(...$args)` がマップ結果になる。
     * さらに引数が不要なら `@method` とするだけで良い。
     *
     * Example:
     * ```php
     * // 値を3乗したあと16進表記にして大文字化する
     * that(array_maps([1, 2, 3, 4, 5], fn($v) => pow($v, 3), 'dechex', 'strtoupper'))->isSame(['1', '8', '1B', '40', '7D']);
     * // キーも渡ってくる
     * that(array_maps(['a' => 'A', 'b' => 'B'], fn($v, $k) => "$k:$v"))->isSame(['a' => 'a:A', 'b' => 'b:B']);
     * // ... で可変引数コール
     * that(array_maps([[1, 3], [1, 5, 2]], '...range'))->isSame([[1, 2, 3], [1, 3, 5]]);
     * // メソッドコールもできる（引数不要なら `@method` でも同じ）
     * that(array_maps([new \Exception('a'), new \Exception('b')], ['getMessage' => []]))->isSame(['a', 'b']);
     * that(array_maps([new \Exception('a'), new \Exception('b')], '@getMessage'))->isSame(['a', 'b']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param callable ...$callbacks 評価クロージャ配列
     * @return iterable|array 評価クロージャを通した新しい配列
     */
    function array_maps($array, ...$callbacks)
    {
        // Iterator だが ArrayAccess ではないオブジェクト（Generator とか）は unset できないので配列として扱わざるを得ない
        if (!(function_configure('array.variant') && is_arrayable($array))) {
            $array = arrayval($array, false);
        }

        foreach ($callbacks as $callback) {
            if (is_string($callback) && $callback[0] === '@') {
                $margs = [];
                $vargs = false;
                $callback = substr($callback, 1);
            }
            elseif (is_array($callback) && count($callback) === 1) {
                $margs = reset($callback);
                $vargs = false;
                $callback = key($callback);
            }
            elseif (is_string($callback) && substr($callback, 0, 3) === '...') {
                $margs = null;
                $vargs = true;
                $callback = substr($callback, 3);
            }
            else {
                $margs = null;
                $vargs = false;
                $callback = func_user_func_array($callback);
            }
            $n = 0;
            foreach (arrayval($array, false) as $k => $v) {
                if (isset($margs)) {
                    $array[$k] = ([$v, $callback])(...$margs);
                }
                elseif ($vargs) {
                    $array[$k] = $callback(...$v);
                }
                else {
                    $array[$k] = $callback($v, $k, $n++);
                }
            }
        }
        return $array;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_merge2') || (new \ReflectionFunction('ryunosuke\\dbml\\array_merge2'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_merge2')) {
    /**
     * 配列をマージして通常配列＋αで返す
     *
     * キー・値が維持される点で array_merge とは異なる（振り直しをせず数値配列で返す）。
     * きちんと0からの連番で構成される点で配列の加算とは異なる。
     * 要するに「できるだけキーが自然数（の並び）になるように」マージする。
     *
     * 歯抜けはそのまま維持され、文字キーは後ろに追加される（負数キーも同様）。
     *
     * Example:
     * ```php
     * // キーが入り乱れているがよく見ると通し番号が振られている配列をマージ
     * that(array_merge2([4 => 4, 1 => 1], [0 => 0], [5 => 5, 2 => 2, 3 => 3]))->isSame([0, 1, 2, 3, 4, 5]);
     * // 歯抜けの配列をマージ
     * that(array_merge2([4 => 4, 1 => 1], [0 => 0], [5 => 5, 3 => 3]))->isSame([0, 1, 3 => 3, 4 => 4, 5 => 5]);
     * // 負数や文字キーは後ろに追いやられる
     * that(array_merge2(['a' => 'A', 1 => 1], [0 => 0], [-1 => 'X', 2 => 2, 3 => 3]))->isSame([0, 1, 2, 3, -1 => 'X', 'a' => 'A']);
     * // 同じキーは後ろ優先
     * that(array_merge2([0, 'a' => 'A0'], [1, 'a' => 'A1'], [2, 'a' => 'A2']))->isSame([2, 'a' => 'A2']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array ...$arrays マージする配列
     * @return array マージされた配列
     */
    function array_merge2(...$arrays)
    {
        // array_merge を模倣するため前方優先
        $arrays = array_reverse($arrays);

        // 最大値の導出（負数は考慮せず文字キーとして扱う）
        $max = -1;
        foreach ($arrays as $array) {
            foreach ($array as $k => $v) {
                if (is_int($k) && $k > $max) {
                    $max = $k;
                }
            }
        }

        // 最大値までを埋める
        $result = [];
        for ($i = 0; $i <= $max; $i++) {
            foreach ($arrays as $array) {
                if (isset($array[$i]) || array_key_exists($i, $array)) {
                    $result[$i] = $array[$i];
                    break;
                }
            }
        }

        // 上記は数値キーだけなので負数や文字キーを補完する
        foreach ($arrays as $arg) {
            $result += $arg;
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_pickup') || (new \ReflectionFunction('ryunosuke\\dbml\\array_pickup'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_pickup')) {
    /**
     * キーを指定してそれだけの配列にする
     *
     * `array_intersect_key($array, array_flip($keys))` とほぼ同義。
     * 違いは Traversable を渡せることと、結果配列の順番が $keys に従うこと。
     *
     * $keys に連想配列を渡すとキーを読み替えて動作する（Example を参照）。
     * さらにその時クロージャを渡すと($key, $value)でコールされた結果が新しいキーになる。
     *
     * Example:
     * ```php
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // a と c を取り出す
     * that(array_pickup($array, ['a', 'c']))->isSame(['a' => 'A', 'c' => 'C']);
     * // 順番は $keys 基準になる
     * that(array_pickup($array, ['c', 'a']))->isSame(['c' => 'C', 'a' => 'A']);
     * // 連想配列を渡すと読み替えて返す
     * that(array_pickup($array, ['c' => 'cX', 'a' => 'aX']))->isSame(['cX' => 'C', 'aX' => 'A']);
     * // コールバックを渡せる
     * that(array_pickup($array, ['c' => fn($k, $v) => "$k-$v"]))->isSame(['c-C' => 'C']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable|object $array 対象配列
     * @param array $keys 取り出すキー
     * @return array 新しい配列
     */
    function array_pickup($array, $keys)
    {
        $array = arrayval($array, false);

        $result = [];
        foreach (arrayval($keys, false) as $k => $key) {
            if (is_int($k)) {
                if (array_key_exists($key, $array)) {
                    $result[$key] = $array[$key];
                }
            }
            else {
                if (array_key_exists($k, $array)) {
                    if (is_callback($key)) {
                        $key = $key($k, $array[$k]);
                    }
                    $result[$key] = $array[$k];
                }
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_rekey') || (new \ReflectionFunction('ryunosuke\\dbml\\array_rekey'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_rekey')) {
    /**
     * キーをマップ配列・callable で置換する
     *
     * 変換先・返り値が null だとその要素は取り除かれる。
     * callable 指定時の引数は `(キー, 値, 連番インデックス, 対象配列そのもの)` が渡ってくる。
     *
     * Example:
     * ```php
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // a は x に c は z に置換される
     * that(array_rekey($array, ['a' => 'x', 'c' => 'z']))->isSame(['x' => 'A', 'b' => 'B', 'z' => 'C']);
     * // b は削除され c は z に置換される
     * that(array_rekey($array, ['b' => null, 'c' => 'z']))->isSame(['a' => 'A', 'z' => 'C']);
     * // キーの交換にも使える（a ⇔ c）
     * that(array_rekey($array, ['a' => 'c', 'c' => 'a']))->isSame(['c' => 'A', 'b' => 'B', 'a' => 'C']);
     * // callable
     * that(array_rekey($array, 'strtoupper'))->isSame(['A' => 'A', 'B' => 'B', 'C' => 'C']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param array|callable $keymap マップ配列かキーを返すクロージャ
     * @return array キーが置換された配列
     */
    function array_rekey($array, $keymap)
    {
        // 互換性のため callable は配列以外に限定する
        $callable = ($keymap instanceof \Closure) || (!is_array($keymap) && is_callable($keymap));
        if ($callable) {
            $keymap = func_user_func_array($keymap);
        }

        $result = [];
        $n = 0;
        foreach ($array as $k => $v) {
            if ($callable) {
                $k = $keymap($k, $v, $n, $array);
                // null は突っ込まない（除去）
                if ($k !== null) {
                    $result[$k] = $v;
                }
            }
            elseif (array_key_exists($k, $keymap)) {
                // null は突っ込まない（除去）
                if ($keymap[$k] !== null) {
                    $result[$keymap[$k]] = $v;
                }
            }
            else {
                $result[$k] = $v;
            }
            $n++;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_remove') || (new \ReflectionFunction('ryunosuke\\dbml\\array_remove'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_remove')) {
    /**
     * キーを指定してそれらを除いた配列にする
     *
     * `array_diff_key($array, array_flip($keys))` とほぼ同義。
     * 違いは Traversable を渡せること。
     *
     * array_pickup の逆とも言える。
     *
     * Example:
     * ```php
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // a と c を伏せる（b を残す）
     * that(array_remove($array, ['a', 'c']))->isSame(['b' => 'B']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array|\Traversable $array 対象配列
     * @param array|int|string $keys 伏せるキー
     * @return array 新しい配列
     */
    function array_remove($array, $keys)
    {
        foreach (arrayval($keys, false) as $k) {
            unset($array[$k]);
        }
        return $array;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_set') || (new \ReflectionFunction('ryunosuke\\dbml\\array_set'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_set')) {
    /**
     * キー指定の配列値設定
     *
     * 第3引数を省略すると（null を与えると）言語機構を使用して配列の最後に設定する（$array[] = $value）。
     * 第3引数に配列を指定すると潜って設定する。
     *
     * 第4引数で追加する条件クロージャを指定できる。
     * クロージャには `(追加する要素, 追加するキー, 追加される元配列)` が渡ってくる。
     * このクロージャが false 相当を返した時は追加されないようになる。
     *
     * Example:
     * ```php
     * $array = ['a' => 'A', 'B'];
     * // 第3引数省略（最後に連番キーで設定）
     * that(array_set($array, 'Z'))->isSame(1);
     * that($array)->isSame(['a' => 'A', 'B', 'Z']);
     * // 第3引数でキーを指定
     * that(array_set($array, 'Z', 'z'))->isSame('z');
     * that($array)->isSame(['a' => 'A', 'B', 'Z', 'z' => 'Z']);
     * that(array_set($array, 'Z', 'z'))->isSame('z');
     * // 第3引数で配列を指定
     * that(array_set($array, 'Z', ['x', 'y', 'z']))->isSame('z');
     * that($array)->isSame(['a' => 'A', 'B', 'Z', 'z' => 'Z', 'x' => ['y' => ['z' => 'Z']]]);
     * // 第4引数で条件を指定（キーが存在するなら追加しない）
     * that(array_set($array, 'Z', 'z', fn($v, $k, $array) => !isset($array[$k])))->isSame(null);
     * // 第4引数で条件を指定（値が存在するなら追加しない）
     * that(array_set($array, 'Z', null, fn($v, $k, $array) => !in_array($v, $array)))->isSame(null);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 配列
     * @param mixed $value 設定する値
     * @param array|string|int|null $key 設定するキー
     * @param callable|null $condition 追加する条件
     * @return string|int|null 設定したキー
     */
    function array_set(&$array, $value, $key = null, $condition = null)
    {
        if (is_array($key)) {
            $k = array_shift($key);
            if ($key) {
                if (is_array($array) && array_key_exists($k, $array) && !is_array($array[$k])) {
                    throw new \InvalidArgumentException('$array[$k] is not array.');
                }
                return array_set(...[&$array[$k], $value, $key, $condition]);
            }
            else {
                return array_set(...[&$array, $value, $k, $condition]);
            }
        }

        if ($condition !== null) {
            if (!$condition($value, $key, $array)) {
                return null;
            }
        }

        if ($key === null) {
            $array[] = $value;
            $key = array_key_last($array);
        }
        else {
            $array[$key] = $value;
        }
        return $key;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_sprintf') || (new \ReflectionFunction('ryunosuke\\dbml\\array_sprintf'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_sprintf')) {
    /**
     * キーと値で sprintf する
     *
     * 配列の各要素を文字列化して返すイメージ。
     * $glue を与えるとさらに implode して返す（返り値が文字列になる）。
     *
     * $format は書式文字列（$v, $k）。
     * callable を与えると sprintf ではなくコールバック処理になる（$v, $k）。
     * 省略（null）するとキーを format 文字列、値を引数として **vsprintf** する。
     *
     * Example:
     * ```php
     * $array = ['key1' => 'val1', 'key2' => 'val2'];
     * // key, value を利用した sprintf
     * that(array_sprintf($array, '%2$s=%1$s'))->isSame(['key1=val1', 'key2=val2']);
     * // 第3引数を与えるとさらに implode される
     * that(array_sprintf($array, '%2$s=%1$s', ' '))->isSame('key1=val1 key2=val2');
     * // クロージャを与えるとコールバック動作になる
     * $closure = fn($v, $k) => "$k=" . strtoupper($v);
     * that(array_sprintf($array, $closure, ' '))->isSame('key1=VAL1 key2=VAL2');
     * // 省略すると vsprintf になる
     * that(array_sprintf([
     *     'str:%s,int:%d' => ['sss', '3.14'],
     *     'single:%s'     => 'str',
     * ], null, '|'))->isSame('str:sss,int:3|single:str');
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param string|callable|null $format 書式文字列あるいはクロージャ
     * @param ?string $glue 結合文字列。未指定時は implode しない
     * @return array|string sprintf された配列
     */
    function array_sprintf($array, $format = null, $glue = null)
    {
        if (is_callable($format)) {
            $callback = func_user_func_array($format);
        }
        elseif ($format === null) {
            $callback = fn($v, $k, $n) => vsprintf($k, is_array($v) ? $v : [$v]);
        }
        else {
            $callback = fn($v, $k, $n) => sprintf($format, $v, $k);
        }

        $result = [];
        $n = 0;
        foreach ($array as $k => $v) {
            $result[] = $callback($v, $k, $n++);
        }

        if ($glue !== null) {
            return implode($glue, $result);
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_strpad') || (new \ReflectionFunction('ryunosuke\\dbml\\array_strpad'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_strpad')) {
    /**
     * 配列のキー・要素に文字列を付加する
     *
     * $key_prefix, $val_prefix でそれぞれ「キーに付与する文字列」「値に付与する文字列」が指定できる。
     * 配列を与えると [サフィックス, プレフィックス] という意味になる。
     * デフォルト（ただの文字列）はプレフィックス（値だけに付与したいなら array_map で十分なので）。
     *
     * Example:
     * ```php
     * $array = ['key1' => 'val1', 'key2' => 'val2'];
     * // キーにプレフィックス付与
     * that(array_strpad($array, 'prefix-'))->isSame(['prefix-key1' => 'val1', 'prefix-key2' => 'val2']);
     * // 値にサフィックス付与
     * that(array_strpad($array, '', ['-suffix']))->isSame(['key1' => 'val1-suffix', 'key2' => 'val2-suffix']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param string|array $key_prefix キー側の付加文字列
     * @param string|array $val_prefix 値側の付加文字列
     * @return array 文字列付与された配列
     */
    function array_strpad($array, $key_prefix, $val_prefix = '')
    {
        $key_suffix = '';
        if (is_array($key_prefix)) {
            [$key_suffix, $key_prefix] = $key_prefix + [1 => ''];
        }
        $val_suffix = '';
        if (is_array($val_prefix)) {
            [$val_suffix, $val_prefix] = $val_prefix + [1 => ''];
        }

        $enable_key = strlen($key_prefix) || strlen($key_suffix);
        $enable_val = strlen($val_prefix) || strlen($val_suffix);

        $result = [];
        foreach ($array as $key => $val) {
            if ($enable_key) {
                $key = $key_prefix . $key . $key_suffix;
            }
            if ($enable_val) {
                $val = $val_prefix . $val . $val_suffix;
            }
            $result[$key] = $val;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_uncolumns') || (new \ReflectionFunction('ryunosuke\\dbml\\array_uncolumns'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_uncolumns')) {
    /**
     * array_columns のほぼ逆で [キー => [要素]] 配列から連想配列の配列を生成する
     *
     * $template を指定すると「それに含まれる配列かつ値がデフォルト」になる（要するに $default みたいなもの）。
     * キーがバラバラな配列を指定する場合は指定したほうが良い。が、null を指定すると最初の要素が使われるので大抵の場合は null で良い。
     *
     * Example:
     * ```php
     * that(array_uncolumns([
     *     'id'   => [1, 2],
     *     'name' => ['A', 'B'],
     * ]))->isSame([
     *     ['id' => 1, 'name' => 'A'],
     *     ['id' => 2, 'name' => 'B'],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 対象配列
     * @param ?array $template 抽出要素とそのデフォルト値
     * @return array 新しい配列
     */
    function array_uncolumns($array, $template = null)
    {
        // 指定されていないなら生のまま
        if (func_num_args() === 1) {
            $template = false;
        }
        // null なら最初の要素のキー・null
        if ($template === null) {
            $template = array_fill_keys(array_keys(first_value($array)), null);
        }

        $result = [];
        foreach ($array as $key => $vals) {
            if ($template !== false) {
                $vals = array_intersect_key($vals + $template, $template);
            }
            foreach ($vals as $n => $val) {
                $result[$n][$key] = $val;
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\array_unset') || (new \ReflectionFunction('ryunosuke\\dbml\\array_unset'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\array_unset')) {
    /**
     * 伏せると同時にその値を返す
     *
     * $key に配列を与えると全て伏せて配列で返す。
     * その場合、$default が活きるのは「全て無かった場合」となる。
     *
     * さらに $key が配列の場合に限り、 $default を省略すると空配列として動作する。
     *
     * 配列を与えた場合の返り値は与えた配列の順番・キーが活きる。
     * これを利用すると list の展開の利便性が上がったり、連想配列で返すことができる。
     *
     * 同様に、$key にクロージャを与えると、その返り値が true 相当のものを伏せて配列で返す。
     * callable ではなくクロージャのみ対応する。
     *
     * Example:
     * ```php
     * $array = ['a' => 'A', 'b' => 'B'];
     * // ない場合は $default を返す
     * that(array_unset($array, 'x', 'X'))->isSame('X');
     * // 指定したキーを返す。そのキーは伏せられている
     * that(array_unset($array, 'a'))->isSame('A');
     * that($array)->isSame(['b' => 'B']);
     *
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // 配列を与えるとそれらを返す。そのキーは全て伏せられている
     * that(array_unset($array, ['a', 'b', 'x']))->isSame(['A', 'B']);
     * that($array)->isSame(['c' => 'C']);
     *
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // 配列のキーは返されるキーを表す。順番も維持される
     * that(array_unset($array, ['x2' => 'b', 'x1' => 'a']))->isSame(['x2' => 'B', 'x1' => 'A']);
     *
     * $array = ['hoge' => 'HOGE', 'fuga' => 'FUGA', 'piyo' => 'PIYO'];
     * // 値に "G" を含むものを返す。その要素は伏せられている
     * that(array_unset($array, fn($v) => strpos($v, 'G') !== false))->isSame(['hoge' => 'HOGE', 'fuga' => 'FUGA']);
     * that($array)->isSame(['piyo' => 'PIYO']);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array|\ArrayAccess $array 配列
     * @param string|int|array|callable $key 伏せたいキー。配列を与えると全て伏せる。クロージャの場合は true 相当を伏せる
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 指定したキーの値
     */
    function array_unset(&$array, $key, $default = null)
    {
        if (is_array($key)) {
            $result = [];
            foreach ($key as $rk => $ak) {
                if (array_keys_exist($ak, $array)) {
                    $result[$rk] = $array[$ak];
                    unset($array[$ak]);
                }
            }
            if (!$result) {
                // 明示的に与えられていないなら [] を使用する
                if (func_num_args() === 2) {
                    $default = [];
                }
                return $default;
            }
            return $result;
        }

        if ($key instanceof \Closure) {
            $result = [];
            $n = 0;
            foreach ($array as $k => $v) {
                if ($key($v, $k, $n++)) {
                    $result[$k] = $v;
                    unset($array[$k]);
                }
            }
            if (!$result) {
                return $default;
            }
            return $result;
        }

        if (array_keys_exist($key, $array)) {
            $result = $array[$key];
            unset($array[$key]);
            return $result;
        }
        return $default;
    }
}

assert(!function_exists('ryunosuke\\dbml\\arrayize') || (new \ReflectionFunction('ryunosuke\\dbml\\arrayize'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\arrayize')) {
    /**
     * 引数の配列を生成する。
     *
     * 配列以外を渡すと配列化されて追加される。
     * 配列を渡してもそのままだが、連番配列の場合はマージ、連想配列の場合は結合となる。
     * iterable や Traversable は考慮せずあくまで「配列」としてチェックする。
     *
     * Example:
     * ```php
     * // 値は配列化される
     * that(arrayize(1, 2, 3))->isSame([1, 2, 3]);
     * // 配列はそのまま
     * that(arrayize([1], [2], [3]))->isSame([1, 2, 3]);
     * // 連想配列、連番配列の挙動
     * that(arrayize([1, 2, 3], [4, 5, 6], ['a' => 'A1'], ['a' => 'A2']))->isSame([1, 2, 3, 4, 5, 6, 'a' => 'A1']);
     * // stdClass は foreach 可能だがあくまで配列としてチェックする
     * $object = new \stdClass();
     * that(arrayize($object, false, [1, 2, 3]))->isSame([$object, false, 1, 2, 3]);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param mixed ...$variadic 生成する要素（可変引数）
     * @return array 引数を配列化したもの
     */
    function arrayize(...$variadic)
    {
        $result = [];
        foreach ($variadic as $arg) {
            if (!is_array($arg)) {
                $result[] = $arg;
            }
            elseif ($result && !is_hasharray($arg)) {
                $result = array_merge($result, $arg);
            }
            else {
                // array_merge に合わせるなら $result = $arg + $result で後方上書きの方がいいかも
                // 些細な変更だけど後方互換性が完全に壊れるのでいったん保留（可変引数なんてほとんど使ってないと思うけど…）
                $result += $arg; // for compatible
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\first_key') || (new \ReflectionFunction('ryunosuke\\dbml\\first_key'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\first_key')) {
    /**
     * 配列の最初のキーを返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(first_key(['a', 'b', 'c']))->isSame(0);
     * that(first_key([], 999))->isSame(999);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 最初のキー
     */
    function first_key($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        /** @noinspection PhpUnusedLocalVariableInspection */
        [$k, $v] = first_keyvalue($array);
        return $k;
    }
}

assert(!function_exists('ryunosuke\\dbml\\first_keyvalue') || (new \ReflectionFunction('ryunosuke\\dbml\\first_keyvalue'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\first_keyvalue')) {
    /**
     * 配列の最初のキー/値ペアをタプルで返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(first_keyvalue(['a', 'b', 'c']))->isSame([0, 'a']);
     * that(first_keyvalue([], 999))->isSame(999);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable|object $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return array [最初のキー, 最初の値]
     */
    function first_keyvalue($array, $default = null)
    {
        foreach ($array as $k => $v) {
            return [$k, $v];
        }
        return $default;
    }
}

assert(!function_exists('ryunosuke\\dbml\\first_value') || (new \ReflectionFunction('ryunosuke\\dbml\\first_value'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\first_value')) {
    /**
     * 配列の最初の値を返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(first_value(['a', 'b', 'c']))->isSame('a');
     * that(first_value([], 999))->isSame(999);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 最初の値
     */
    function first_value($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        /** @noinspection PhpUnusedLocalVariableInspection */
        [$k, $v] = first_keyvalue($array);
        return $v;
    }
}

assert(!function_exists('ryunosuke\\dbml\\is_hasharray') || (new \ReflectionFunction('ryunosuke\\dbml\\is_hasharray'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\is_hasharray')) {
    /**
     * 配列が連想配列か調べる
     *
     * 空の配列は普通の配列とみなす。
     *
     * Example:
     * ```php
     * that(is_hasharray([]))->isFalse();
     * that(is_hasharray([1, 2, 3]))->isFalse();
     * that(is_hasharray(['x' => 'X']))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 調べる配列
     * @return bool 連想配列なら true
     */
    function is_hasharray(array $array)
    {
        if (function_exists('array_is_list')) {
            return !array_is_list($array); // @codeCoverageIgnore
        }

        $i = 0;
        foreach ($array as $k => $dummy) {
            if ($k !== $i++) {
                return true;
            }
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\dbml\\is_indexarray') || (new \ReflectionFunction('ryunosuke\\dbml\\is_indexarray'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\is_indexarray')) {
    /**
     * 配列が数値配列か調べる
     *
     * 空の配列も数値配列とみなす。
     * さらにいわゆる「連番配列」ではなく「キーが数値のみか？」で判定する。
     *
     * つまり、 is_hasharray とは排他的ではない。
     *
     * Example:
     * ```php
     * that(is_indexarray([]))->isTrue();
     * that(is_indexarray([1, 2, 3]))->isTrue();
     * that(is_indexarray(['x' => 'X']))->isFalse();
     * // 抜け番があっても true になる（これは is_hasharray も true になる）
     * that(is_indexarray([1 => 1, 2 => 2, 3 => 3]))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param array $array 調べる配列
     * @return bool 数値配列なら true
     */
    function is_indexarray($array)
    {
        foreach ($array as $k => $dummy) {
            if (!is_int($k)) {
                return false;
            }
        }
        return true;
    }
}

assert(!function_exists('ryunosuke\\dbml\\last_keyvalue') || (new \ReflectionFunction('ryunosuke\\dbml\\last_keyvalue'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\last_keyvalue')) {
    /**
     * 配列の最後のキー/値ペアをタプルで返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(last_keyvalue(['a', 'b', 'c']))->isSame([2, 'c']);
     * that(last_keyvalue([], 999))->isSame(999);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable|object $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return array [最後のキー, 最後の値]
     */
    function last_keyvalue($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        if (is_array($array)) {
            $k = array_key_last($array);
            return [$k, $array[$k]];
        }
        foreach ($array as $k => $v) {
            // dummy
        }
        // $k がセットされてるなら「ループが最低でも1度回った（≠空）」とみなせる
        if (isset($k)) {
            /** @noinspection PhpUndefinedVariableInspection */
            return [$k, $v];
        }
        return $default;
    }
}

assert(!function_exists('ryunosuke\\dbml\\last_value') || (new \ReflectionFunction('ryunosuke\\dbml\\last_value'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\last_value')) {
    /**
     * 配列の最後の値を返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(last_value(['a', 'b', 'c']))->isSame('c');
     * that(last_value([], 999))->isSame(999);
     * ```
     *
     * @package ryunosuke\Functions\Package\array
     *
     * @param iterable $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 最後の値
     */
    function last_value($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        /** @noinspection PhpUnusedLocalVariableInspection */
        [$k, $v] = last_keyvalue($array);
        return $v;
    }
}

assert(!function_exists('ryunosuke\\dbml\\auto_loader') || (new \ReflectionFunction('ryunosuke\\dbml\\auto_loader'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\auto_loader')) {
    /**
     * vendor/autoload.php を返す
     *
     * かなり局所的な実装で vendor ディレクトリを変更していたりするとそれだけで例外になる。
     *
     * Example:
     * ```php
     * that(auto_loader())->contains('autoload.php');
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param ?string $startdir 高速化用の検索開始ディレクトリを指定するが、どちらかと言えばテスト用
     * @return string autoload.php のフルパス
     */
    function auto_loader($startdir = null)
    {
        return json_storage(__FUNCTION__)[$startdir] ??= (function () use ($startdir) {
            $cache = dirname_r($startdir ?: __DIR__, function ($dir) {
                if (file_exists($file = "$dir/autoload.php") || file_exists($file = "$dir/vendor/autoload.php")) {
                    return $file;
                }
            });
            if (!$cache) {
                throw new \DomainException('autoloader is not found.');
            }
            return $cache;
        })();
    }
}

assert(!function_exists('ryunosuke\\dbml\\class_aliases') || (new \ReflectionFunction('ryunosuke\\dbml\\class_aliases'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\class_aliases')) {
    /**
     * 遅延ロードする class_alias
     *
     * class_alias は即座にオートロードされるが、この関数は必要とされるまでオートロードしない。
     *
     * Example:
     * ```php
     * class_aliases([
     *     'TestCase' => \PHPUnit\Framework\TestCase::class,
     * ]);
     * that(class_exists('TestCase', false))->isFalse(); // オートロードを走らせなければまだ定義されていない
     * that(class_exists('TestCase', true))->isTrue();   // オートロードを走らせなければ定義されている
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param array $aliases
     * @return array エイリアス配列
     */
    function class_aliases($aliases)
    {
        static $alias_map = [];

        foreach ($aliases as $alias => $class) {
            $alias_map[trim($alias, '\\')] = $class;
        }

        static $registered = false;
        if (!$registered) {
            $registered = true;
            spl_autoload_register(function ($class) use (&$alias_map) {
                if (isset($alias_map[$class])) {
                    class_alias($alias_map[$class], $class);
                }
            }, true, true);
        }

        return $alias_map;
    }
}

assert(!function_exists('ryunosuke\\dbml\\class_loader') || (new \ReflectionFunction('ryunosuke\\dbml\\class_loader'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\class_loader')) {
    /**
     * composer のクラスローダを返す
     *
     * かなり局所的な実装で vendor ディレクトリを変更していたりするとそれだけで例外になる。
     *
     * Example:
     * ```php
     * that(class_loader())->isInstanceOf(\Composer\Autoload\ClassLoader::class);
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param ?string $startdir 高速化用の検索開始ディレクトリを指定するが、どちらかと言えばテスト用
     * @return \Composer\Autoload\ClassLoader クラスローダ
     */
    function class_loader($startdir = null)
    {
        return require auto_loader($startdir);
    }
}

assert(!function_exists('ryunosuke\\dbml\\class_shorten') || (new \ReflectionFunction('ryunosuke\\dbml\\class_shorten'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\class_shorten')) {
    /**
     * クラスの名前空間部分を除いた短い名前を取得する
     *
     * Example:
     * ```php
     * that(class_shorten('vendor\\namespace\\ClassName'))->isSame('ClassName');
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param string|object $class 対象クラス・オブジェクト
     * @return string クラスの短い名前
     */
    function class_shorten($class)
    {
        if (is_object($class)) {
            $class = get_class($class);
        }

        $parts = explode('\\', $class);
        return array_pop($parts);
    }
}

assert(!function_exists('ryunosuke\\dbml\\const_exists') || (new \ReflectionFunction('ryunosuke\\dbml\\const_exists'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\const_exists')) {
    /**
     * クラス定数が存在するか調べる
     *
     * グローバル定数も調べられる。ので実質的には defined とほぼ同じで違いは下記。
     *
     * - defined は単一引数しか与えられないが、この関数は2つの引数も受け入れる
     * - defined は private const で即死するが、この関数はきちんと調べることができる
     * - ClassName::class は常に true を返す
     *
     * あくまで存在を調べるだけで実際にアクセスできるかは分からないので注意（`property_exists` と同じ）。
     *
     * Example:
     * ```php
     * // クラス定数が調べられる（1引数、2引数どちらでも良い）
     * that(const_exists('ArrayObject::STD_PROP_LIST'))->isTrue();
     * that(const_exists('ArrayObject', 'STD_PROP_LIST'))->isTrue();
     * that(const_exists('ArrayObject::UNDEFINED'))->isFalse();
     * that(const_exists('ArrayObject', 'UNDEFINED'))->isFalse();
     * // グローバル（名前空間）もいける
     * that(const_exists('PHP_VERSION'))->isTrue();
     * that(const_exists('UNDEFINED'))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param string|object $classname 調べるクラス
     * @param string $constname 調べるクラス定数
     * @return bool 定数が存在するなら true
     */
    function const_exists($classname, $constname = '')
    {
        $colonp = strpos($classname, '::');
        if ($colonp === false && strlen($constname) === 0) {
            return defined($classname);
        }
        if (strlen($constname) === 0) {
            $constname = substr($classname, $colonp + 2);
            $classname = substr($classname, 0, $colonp);
        }

        try {
            $refclass = new \ReflectionClass($classname);
            if (strcasecmp($constname, 'class') === 0) {
                return true;
            }
            return $refclass->hasConstant($constname);
        }
        catch (\Throwable) {
            return false;
        }
    }
}

assert(!function_exists('ryunosuke\\dbml\\object_properties') || (new \ReflectionFunction('ryunosuke\\dbml\\object_properties'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\object_properties')) {
    /**
     * オブジェクトのプロパティを可視・不可視を問わず取得する
     *
     * get_object_vars + no public プロパティを返すイメージ。
     * クロージャだけは特別扱いで this + use 変数を返す。
     *
     * Example:
     * ```php
     * $object = new #[\AllowDynamicProperties] class('something', 42) extends \Exception{};
     * $object->oreore = 'oreore';
     *
     * // get_object_vars はそのスコープから見えないプロパティを取得できない
     * // var_dump(get_object_vars($object));
     *
     * // array キャストは全て得られるが null 文字を含むので扱いにくい
     * // var_dump((array) $object);
     *
     * // この関数を使えば不可視プロパティも取得できる
     * that(object_properties($object))->subsetEquals([
     *     'message' => 'something',
     *     'code'    => 42,
     *     'oreore'  => 'oreore',
     * ]);
     *
     * // クロージャは this と use 変数を返す
     * that(object_properties(fn() => $object))->is([
     *     'this'   => $this,
     *     'object' => $object,
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param object $object オブジェクト
     * @param array $privates 継承ツリー上の private が格納される
     * @return array 全プロパティの配列
     */
    function object_properties($object, &$privates = [])
    {
        if ($object instanceof \Closure) {
            $ref = new \ReflectionFunction($object);
            $uses = method_exists($ref, 'getClosureUsedVariables') ? $ref->getClosureUsedVariables() : $ref->getStaticVariables();
            return ['this' => $ref->getClosureThis()] + $uses;
        }

        $fields = [];
        foreach ((array) $object as $name => $field) {
            $cname = '';
            $names = explode("\0", $name);
            if (count($names) > 1) {
                $name = array_pop($names);
                $cname = $names[1];
            }
            $fields[$cname][$name] = $field;
        }

        $classname = get_class($object);
        $parents = array_values(['', '*', $classname] + class_parents($object));
        uksort($fields, function ($a, $b) use ($parents) {
            return array_search($a, $parents, true) <=> array_search($b, $parents, true);
        });

        $result = [];
        foreach ($fields as $cname => $props) {
            foreach ($props as $name => $field) {
                if ($cname !== '' && $cname !== '*' && $classname !== $cname) {
                    $privates[$cname][$name] = $field;
                }
                if (!array_key_exists($name, $result)) {
                    $result[$name] = $field;
                }
            }
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\type_exists') || (new \ReflectionFunction('ryunosuke\\dbml\\type_exists'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\type_exists')) {
    /**
     * 型が存在するか返す
     *
     * class/interface/trait/enum exists の合せ技。
     * trait/enum のように今後型的なものがさらに増えるかもしれないし、class_exists だけして interface/trait が抜けているコードを何度も見てきた。
     * それを一元管理するような関数となる。
     *
     * Example:
     * ```php
     * that(class_exists(\Throwable::class))->isFalse();     // class_exists は class にしか反応しない
     * that(interface_exists(\Exception::class))->isFalse(); // interface_exists は interface にしか反応しない
     * that(trait_exists(\Error::class))->isFalse();         // trait_exists は trait にしか反応しない
     * // type_exists であれば全てに反応する
     * that(type_exists(\Throwable::class))->isTrue();
     * that(type_exists(\Exception::class))->isTrue();
     * that(type_exists(\Error::class))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\classobj
     *
     * @param string $typename 調べる型名
     * @param bool $autoload オートロードを行うか
     * @return bool 型が存在するなら true
     */
    function type_exists($typename, $autoload = true)
    {
        if (class_exists($typename, $autoload)) {
            return true;
        }
        if (interface_exists($typename, $autoload)) {
            return true;
        }
        if (trait_exists($typename, $autoload)) {
            return true;
        }
        // enum は class で実装されているので enum_exists は不要
        return false;
    }
}

assert(!function_exists('ryunosuke\\dbml\\sql_format') || (new \ReflectionFunction('ryunosuke\\dbml\\sql_format'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\sql_format')) {
    /**
     * ものすごく雑に SQL を整形する
     *
     * 非常に荒くアドホックに実装しているのでこの関数で得られた SQL を**実際に実行してはならない**。
     * あくまでログ出力やデバッグ用途で視認性を高める目的である。
     *
     * JOIN 句は FROM 句とみなさず、別句として処理する。
     * AND と && は微妙に処理が異なる。 AND は改行されるが && は改行されない（OR と || も同様）。
     *
     * @package ryunosuke\Functions\Package\database
     *
     * @param string $sql 整形する SQL
     * @param array $options 整形オプション
     * @return string 整形された SQL
     */
    function sql_format($sql, $options = [])
    {
        static $keywords = [
            'ACCESSIBLE'                 => true,
            'ACTION'                     => true,
            'ADD'                        => true,
            'AFTER'                      => true,
            'AGAINST'                    => true,
            'AGGREGATE'                  => true,
            'ALGORITHM'                  => true,
            'ALL'                        => true,
            'ALTER'                      => true,
            'ALTER TABLE'                => true,
            'ANALYSE'                    => true,
            'ANALYZE'                    => true,
            'AND'                        => true,
            'AS'                         => true,
            'ASC'                        => true,
            'AUTOCOMMIT'                 => true,
            'AUTO_INCREMENT'             => true,
            'BACKUP'                     => true,
            'BEGIN'                      => true,
            'BETWEEN'                    => true,
            'BINLOG'                     => true,
            'BOTH'                       => true,
            'CASCADE'                    => true,
            'CASE'                       => true,
            'CHANGE'                     => true,
            'CHANGED'                    => true,
            'CHARACTER SET'              => true,
            'CHARSET'                    => true,
            'CHECK'                      => true,
            'CHECKSUM'                   => true,
            'COLLATE'                    => true,
            'COLLATION'                  => true,
            'COLUMN'                     => true,
            'COLUMNS'                    => true,
            'COMMENT'                    => true,
            'COMMIT'                     => true,
            'COMMITTED'                  => true,
            'COMPRESSED'                 => true,
            'CONCURRENT'                 => true,
            'CONSTRAINT'                 => true,
            'CONTAINS'                   => true,
            'CONVERT'                    => true,
            'CREATE'                     => true,
            'CROSS'                      => true,
            'CURRENT_TIMESTAMP'          => true,
            'DATABASE'                   => true,
            'DATABASES'                  => true,
            'DAY'                        => true,
            'DAY_HOUR'                   => true,
            'DAY_MINUTE'                 => true,
            'DAY_SECOND'                 => true,
            'DEFAULT'                    => true,
            'DEFINER'                    => true,
            'DELAYED'                    => true,
            'DELETE'                     => true,
            'DELETE FROM'                => true,
            'DESC'                       => true,
            'DESCRIBE'                   => true,
            'DETERMINISTIC'              => true,
            'DISTINCT'                   => true,
            'DISTINCTROW'                => true,
            'DIV'                        => true,
            'DO'                         => true,
            'DROP'                       => true,
            'DUMPFILE'                   => true,
            'DUPLICATE'                  => true,
            'DYNAMIC'                    => true,
            'ELSE'                       => true,
            'ENCLOSED'                   => true,
            'END'                        => true,
            'ENGINE'                     => true,
            'ENGINES'                    => true,
            'ENGINE_TYPE'                => true,
            'ESCAPE'                     => true,
            'ESCAPED'                    => true,
            'EVENTS'                     => true,
            'EXCEPT'                     => true,
            'EXECUTE'                    => true,
            'EXISTS'                     => true,
            'EXPLAIN'                    => true,
            'EXTENDED'                   => true,
            'FAST'                       => true,
            'FIELDS'                     => true,
            'FILE'                       => true,
            'FIRST'                      => true,
            'FIXED'                      => true,
            'FLUSH'                      => true,
            'FOR'                        => true,
            'FORCE'                      => true,
            'FOREIGN'                    => true,
            'FROM'                       => true,
            'FULL'                       => true,
            'FULLTEXT'                   => true,
            'FUNCTION'                   => true,
            'GLOBAL'                     => true,
            'GRANT'                      => true,
            'GRANTS'                     => true,
            'GROUP'                      => true,
            'GROUP_CONCAT'               => true,
            'HAVING'                     => true,
            'HEAP'                       => true,
            'HIGH_PRIORITY'              => true,
            'HOSTS'                      => true,
            'HOUR'                       => true,
            'HOUR_MINUTE'                => true,
            'HOUR_SECOND'                => true,
            'IDENTIFIED'                 => true,
            'IF'                         => true,
            'IFNULL'                     => true,
            'IGNORE'                     => true,
            'IN'                         => true,
            'INDEX'                      => true,
            'INDEXES'                    => true,
            'INFILE'                     => true,
            'INNER'                      => true,
            'INSERT'                     => true,
            'INSERT_ID'                  => true,
            'INSERT_METHOD'              => true,
            'INTERSECT'                  => true,
            'INTERVAL'                   => true,
            'INTO'                       => true,
            'INVOKER'                    => true,
            'IS'                         => true,
            'ISOLATION'                  => true,
            'JOIN'                       => true,
            'JSON_ARRAY'                 => true,
            'JSON_ARRAY_APPEND'          => true,
            'JSON_ARRAY_INSERT'          => true,
            'JSON_CONTAINS'              => true,
            'JSON_CONTAINS_PATH'         => true,
            'JSON_DEPTH'                 => true,
            'JSON_EXTRACT'               => true,
            'JSON_INSERT'                => true,
            'JSON_KEYS'                  => true,
            'JSON_LENGTH'                => true,
            'JSON_MERGE_PATCH'           => true,
            'JSON_MERGE_PRESERVE'        => true,
            'JSON_OBJECT'                => true,
            'JSON_PRETTY'                => true,
            'JSON_QUOTE'                 => true,
            'JSON_REMOVE'                => true,
            'JSON_REPLACE'               => true,
            'JSON_SEARCH'                => true,
            'JSON_SET'                   => true,
            'JSON_STORAGE_SIZE'          => true,
            'JSON_TYPE'                  => true,
            'JSON_UNQUOTE'               => true,
            'JSON_VALID'                 => true,
            'KEY'                        => true,
            'KEYS'                       => true,
            'KILL'                       => true,
            'LAST_INSERT_ID'             => true,
            'LATERAL'                    => true,
            'LEADING'                    => true,
            'LEFT'                       => true,
            'LEVEL'                      => true,
            'LIKE'                       => true,
            'LIMIT'                      => true,
            'LINEAR'                     => true,
            'LINES'                      => true,
            'LOAD'                       => true,
            'LOCAL'                      => true,
            'LOCK'                       => true,
            'LOCKS'                      => true,
            'LOGS'                       => true,
            'LOW_PRIORITY'               => true,
            'MARIA'                      => true,
            'MASTER'                     => true,
            'MASTER_CONNECT_RETRY'       => true,
            'MASTER_HOST'                => true,
            'MASTER_LOG_FILE'            => true,
            'MATCH'                      => true,
            'MAX_CONNECTIONS_PER_HOUR'   => true,
            'MAX_QUERIES_PER_HOUR'       => true,
            'MAX_ROWS'                   => true,
            'MAX_UPDATES_PER_HOUR'       => true,
            'MAX_USER_CONNECTIONS'       => true,
            'MEDIUM'                     => true,
            'MERGE'                      => true,
            'MINUTE'                     => true,
            'MINUTE_SECOND'              => true,
            'MIN_ROWS'                   => true,
            'MODE'                       => true,
            'MODIFY'                     => true,
            'MONTH'                      => true,
            'MRG_MYISAM'                 => true,
            'MYISAM'                     => true,
            'NAMES'                      => true,
            'NATURAL'                    => true,
            'NOT'                        => true,
            'NOW()'                      => true,
            'NULL'                       => true,
            'OFFSET'                     => true,
            'ON'                         => true,
            'ON DELETE'                  => true,
            'ON UPDATE'                  => true,
            'OPEN'                       => true,
            'OPTIMIZE'                   => true,
            'OPTION'                     => true,
            'OPTIONALLY'                 => true,
            'OR'                         => true,
            'ORDER'                      => true,
            'BY'                         => true,
            'OUTER'                      => true,
            'OUTFILE'                    => true,
            'PACK_KEYS'                  => true,
            'PAGE'                       => true,
            'PARTIAL'                    => true,
            'PARTITION'                  => true,
            'PARTITIONS'                 => true,
            'PASSWORD'                   => true,
            'PRIMARY'                    => true,
            'PRIVILEGES'                 => true,
            'PROCEDURE'                  => true,
            'PROCESS'                    => true,
            'PROCESSLIST'                => true,
            'PURGE'                      => true,
            'QUICK'                      => true,
            'RAID0'                      => true,
            'RAID_CHUNKS'                => true,
            'RAID_CHUNKSIZE'             => true,
            'RAID_TYPE'                  => true,
            'RANGE'                      => true,
            'READ'                       => true,
            'READ_ONLY'                  => true,
            'READ_WRITE'                 => true,
            'REFERENCES'                 => true,
            'REGEXP'                     => true,
            'RELEASE'                    => true,
            'RELOAD'                     => true,
            'RENAME'                     => true,
            'REPAIR'                     => true,
            'REPEATABLE'                 => true,
            'REPLACE'                    => true,
            'REPLICATION'                => true,
            'RESET'                      => true,
            'RESTORE'                    => true,
            'RESTRICT'                   => true,
            'RETURN'                     => true,
            'RETURNS'                    => true,
            'REVOKE'                     => true,
            'RIGHT'                      => true,
            'RLIKE'                      => true,
            'ROLLBACK'                   => true,
            'ROLLUP'                     => true,
            'ROW'                        => true,
            'ROWS'                       => true,
            'ROW_FORMAT'                 => true,
            'SAVEPOINT'                  => true,
            'SECOND'                     => true,
            'SECURITY'                   => true,
            'SELECT'                     => true,
            'SEPARATOR'                  => true,
            'SERIALIZABLE'               => true,
            'SESSION'                    => true,
            'SET'                        => true,
            'SHARE'                      => true,
            'SHOW'                       => true,
            'SHUTDOWN'                   => true,
            'SLAVE'                      => true,
            'SONAME'                     => true,
            'SOUNDS'                     => true,
            'SQL'                        => true,
            'SQL_AUTO_IS_NULL'           => true,
            'SQL_BIG_RESULT'             => true,
            'SQL_BIG_SELECTS'            => true,
            'SQL_BIG_TABLES'             => true,
            'SQL_BUFFER_RESULT'          => true,
            'SQL_CACHE'                  => true,
            'SQL_CALC_FOUND_ROWS'        => true,
            'SQL_LOG_BIN'                => true,
            'SQL_LOG_OFF'                => true,
            'SQL_LOG_UPDATE'             => true,
            'SQL_LOW_PRIORITY_UPDATES'   => true,
            'SQL_MAX_JOIN_SIZE'          => true,
            'SQL_NO_CACHE'               => true,
            'SQL_QUOTE_SHOW_CREATE'      => true,
            'SQL_SAFE_UPDATES'           => true,
            'SQL_SELECT_LIMIT'           => true,
            'SQL_SLAVE_SKIP_COUNTER'     => true,
            'SQL_SMALL_RESULT'           => true,
            'SQL_WARNINGS'               => true,
            'START'                      => true,
            'STARTING'                   => true,
            'STATUS'                     => true,
            'STOP'                       => true,
            'STORAGE'                    => true,
            'STRAIGHT_JOIN'              => true,
            'STRING'                     => true,
            'STRIPED'                    => true,
            'SUPER'                      => true,
            'TABLE'                      => true,
            'TABLES'                     => true,
            'TEMPORARY'                  => true,
            'TERMINATED'                 => true,
            'THEN'                       => true,
            'TO'                         => true,
            'TRAILING'                   => true,
            'TRANSACTIONAL'              => true,
            'TRUE'                       => true,
            'TRUNCATE'                   => true,
            'TYPE'                       => true,
            'TYPES'                      => true,
            'UNCOMMITTED'                => true,
            'UNION'                      => true,
            'UNION ALL'                  => true,
            'UNIQUE'                     => true,
            'UNLOCK'                     => true,
            'UNSIGNED'                   => true,
            'UPDATE'                     => true,
            'USAGE'                      => true,
            'USE'                        => true,
            'USING'                      => true,
            'VALUES'                     => true,
            'VARIABLES'                  => true,
            'VIEW'                       => true,
            'WHEN'                       => true,
            'WHERE'                      => true,
            'WITH'                       => true,
            'WORK'                       => true,
            'WRITE'                      => true,
            'XOR'                        => true,
            'YEAR_MONTH'                 => true,
            'ABS'                        => true,
            'ACOS'                       => true,
            'ADDDATE'                    => true,
            'ADDTIME'                    => true,
            'AES_DECRYPT'                => true,
            'AES_ENCRYPT'                => true,
            'AREA'                       => true,
            'ASBINARY'                   => true,
            'ASCII'                      => true,
            'ASIN'                       => true,
            'ASTEXT'                     => true,
            'ATAN'                       => true,
            'ATAN2'                      => true,
            'AVG'                        => true,
            'BDMPOLYFROMTEXT'            => true,
            'BDMPOLYFROMWKB'             => true,
            'BDPOLYFROMTEXT'             => true,
            'BDPOLYFROMWKB'              => true,
            'BENCHMARK'                  => true,
            'BIN'                        => true,
            'BIT_AND'                    => true,
            'BIT_COUNT'                  => true,
            'BIT_LENGTH'                 => true,
            'BIT_OR'                     => true,
            'BIT_XOR'                    => true,
            'BOUNDARY'                   => true,
            'BUFFER'                     => true,
            'CAST'                       => true,
            'CEIL'                       => true,
            'CEILING'                    => true,
            'CENTROID'                   => true,
            'CHAR'                       => true,
            'CHARACTER_LENGTH'           => true,
            'CHAR_LENGTH'                => true,
            'COALESCE'                   => true,
            'COERCIBILITY'               => true,
            'COMPRESS'                   => true,
            'CONCAT'                     => true,
            'CONCAT_WS'                  => true,
            'CONNECTION_ID'              => true,
            'CONV'                       => true,
            'CONVERT_TZ'                 => true,
            'CONVEXHULL'                 => true,
            'COS'                        => true,
            'COT'                        => true,
            'COUNT'                      => true,
            'CRC32'                      => true,
            'CROSSES'                    => true,
            'CURDATE'                    => true,
            'CURRENT_DATE'               => true,
            'CURRENT_TIME'               => true,
            'CURRENT_USER'               => true,
            'CURTIME'                    => true,
            'DATE'                       => true,
            'DATEDIFF'                   => true,
            'DATE_ADD'                   => true,
            'DATE_DIFF'                  => true,
            'DATE_FORMAT'                => true,
            'DATE_SUB'                   => true,
            'DAYNAME'                    => true,
            'DAYOFMONTH'                 => true,
            'DAYOFWEEK'                  => true,
            'DAYOFYEAR'                  => true,
            'DECODE'                     => true,
            'DEGREES'                    => true,
            'DES_DECRYPT'                => true,
            'DES_ENCRYPT'                => true,
            'DIFFERENCE'                 => true,
            'DIMENSION'                  => true,
            'DISJOINT'                   => true,
            'DISTANCE'                   => true,
            'ELT'                        => true,
            'ENCODE'                     => true,
            'ENCRYPT'                    => true,
            'ENDPOINT'                   => true,
            'ENVELOPE'                   => true,
            'EQUALS'                     => true,
            'EXP'                        => true,
            'EXPORT_SET'                 => true,
            'EXTERIORRING'               => true,
            'EXTRACT'                    => true,
            'EXTRACTVALUE'               => true,
            'FIELD'                      => true,
            'FIND_IN_SET'                => true,
            'FLOOR'                      => true,
            'FORMAT'                     => true,
            'FOUND_ROWS'                 => true,
            'FROM_DAYS'                  => true,
            'FROM_UNIXTIME'              => true,
            'GEOMCOLLFROMTEXT'           => true,
            'GEOMCOLLFROMWKB'            => true,
            'GEOMETRYCOLLECTION'         => true,
            'GEOMETRYCOLLECTIONFROMTEXT' => true,
            'GEOMETRYCOLLECTIONFROMWKB'  => true,
            'GEOMETRYFROMTEXT'           => true,
            'GEOMETRYFROMWKB'            => true,
            'GEOMETRYN'                  => true,
            'GEOMETRYTYPE'               => true,
            'GEOMFROMTEXT'               => true,
            'GEOMFROMWKB'                => true,
            'GET_FORMAT'                 => true,
            'GET_LOCK'                   => true,
            'GLENGTH'                    => true,
            'GREATEST'                   => true,
            'GROUP_UNIQUE_USERS'         => true,
            'HEX'                        => true,
            'INET_ATON'                  => true,
            'INET_NTOA'                  => true,
            'INSTR'                      => true,
            'INTERIORRINGN'              => true,
            'INTERSECTION'               => true,
            'INTERSECTS'                 => true,
            'ISCLOSED'                   => true,
            'ISEMPTY'                    => true,
            'ISNULL'                     => true,
            'ISRING'                     => true,
            'ISSIMPLE'                   => true,
            'IS_FREE_LOCK'               => true,
            'IS_USED_LOCK'               => true,
            'LAST_DAY'                   => true,
            'LCASE'                      => true,
            'LEAST'                      => true,
            'LENGTH'                     => true,
            'LINEFROMTEXT'               => true,
            'LINEFROMWKB'                => true,
            'LINESTRING'                 => true,
            'LINESTRINGFROMTEXT'         => true,
            'LINESTRINGFROMWKB'          => true,
            'LN'                         => true,
            'LOAD_FILE'                  => true,
            'LOCALTIME'                  => true,
            'LOCALTIMESTAMP'             => true,
            'LOCATE'                     => true,
            'LOG'                        => true,
            'LOG10'                      => true,
            'LOG2'                       => true,
            'LOWER'                      => true,
            'LPAD'                       => true,
            'LTRIM'                      => true,
            'MAKEDATE'                   => true,
            'MAKETIME'                   => true,
            'MAKE_SET'                   => true,
            'MASTER_POS_WAIT'            => true,
            'MAX'                        => true,
            'MBRCONTAINS'                => true,
            'MBRDISJOINT'                => true,
            'MBREQUAL'                   => true,
            'MBRINTERSECTS'              => true,
            'MBROVERLAPS'                => true,
            'MBRTOUCHES'                 => true,
            'MBRWITHIN'                  => true,
            'MD5'                        => true,
            'MICROSECOND'                => true,
            'MID'                        => true,
            'MIN'                        => true,
            'MLINEFROMTEXT'              => true,
            'MLINEFROMWKB'               => true,
            'MOD'                        => true,
            'MONTHNAME'                  => true,
            'MPOINTFROMTEXT'             => true,
            'MPOINTFROMWKB'              => true,
            'MPOLYFROMTEXT'              => true,
            'MPOLYFROMWKB'               => true,
            'MULTILINESTRING'            => true,
            'MULTILINESTRINGFROMTEXT'    => true,
            'MULTILINESTRINGFROMWKB'     => true,
            'MULTIPOINT'                 => true,
            'MULTIPOINTFROMTEXT'         => true,
            'MULTIPOINTFROMWKB'          => true,
            'MULTIPOLYGON'               => true,
            'MULTIPOLYGONFROMTEXT'       => true,
            'MULTIPOLYGONFROMWKB'        => true,
            'NAME_CONST'                 => true,
            'NULLIF'                     => true,
            'NUMGEOMETRIES'              => true,
            'NUMINTERIORRINGS'           => true,
            'NUMPOINTS'                  => true,
            'OCT'                        => true,
            'OCTET_LENGTH'               => true,
            'OLD_PASSWORD'               => true,
            'ORD'                        => true,
            'OVERLAPS'                   => true,
            'PERIOD_ADD'                 => true,
            'PERIOD_DIFF'                => true,
            'PI'                         => true,
            'POINT'                      => true,
            'POINTFROMTEXT'              => true,
            'POINTFROMWKB'               => true,
            'POINTN'                     => true,
            'POINTONSURFACE'             => true,
            'POLYFROMTEXT'               => true,
            'POLYFROMWKB'                => true,
            'POLYGON'                    => true,
            'POLYGONFROMTEXT'            => true,
            'POLYGONFROMWKB'             => true,
            'POSITION'                   => true,
            'POW'                        => true,
            'POWER'                      => true,
            'QUARTER'                    => true,
            'QUOTE'                      => true,
            'RADIANS'                    => true,
            'RAND'                       => true,
            'RELATED'                    => true,
            'RELEASE_LOCK'               => true,
            'REPEAT'                     => true,
            'REVERSE'                    => true,
            'ROUND'                      => true,
            'ROW_COUNT'                  => true,
            'RPAD'                       => true,
            'RTRIM'                      => true,
            'SCHEMA'                     => true,
            'SEC_TO_TIME'                => true,
            'SESSION_USER'               => true,
            'SHA'                        => true,
            'SHA1'                       => true,
            'SIGN'                       => true,
            'SIN'                        => true,
            'SLEEP'                      => true,
            'SOUNDEX'                    => true,
            'SPACE'                      => true,
            'SQRT'                       => true,
            'SRID'                       => true,
            'STARTPOINT'                 => true,
            'STD'                        => true,
            'STDDEV'                     => true,
            'STDDEV_POP'                 => true,
            'STDDEV_SAMP'                => true,
            'STRCMP'                     => true,
            'STR_TO_DATE'                => true,
            'SUBDATE'                    => true,
            'SUBSTR'                     => true,
            'SUBSTRING'                  => true,
            'SUBSTRING_INDEX'            => true,
            'SUBTIME'                    => true,
            'SUM'                        => true,
            'SYMDIFFERENCE'              => true,
            'SYSDATE'                    => true,
            'SYSTEM_USER'                => true,
            'TAN'                        => true,
            'TIME'                       => true,
            'TIMEDIFF'                   => true,
            'TIMESTAMP'                  => true,
            'TIMESTAMPADD'               => true,
            'TIMESTAMPDIFF'              => true,
            'TIME_FORMAT'                => true,
            'TIME_TO_SEC'                => true,
            'TOUCHES'                    => true,
            'TO_DAYS'                    => true,
            'TRIM'                       => true,
            'UCASE'                      => true,
            'UNCOMPRESS'                 => true,
            'UNCOMPRESSED_LENGTH'        => true,
            'UNHEX'                      => true,
            'UNIQUE_USERS'               => true,
            'UNIX_TIMESTAMP'             => true,
            'UPDATEXML'                  => true,
            'UPPER'                      => true,
            'USER'                       => true,
            'UTC_DATE'                   => true,
            'UTC_TIME'                   => true,
            'UTC_TIMESTAMP'              => true,
            'UUID'                       => true,
            'VARIANCE'                   => true,
            'VAR_POP'                    => true,
            'VAR_SAMP'                   => true,
            'VERSION'                    => true,
            'WEEK'                       => true,
            'WEEKDAY'                    => true,
            'WEEKOFYEAR'                 => true,
            'WITHIN'                     => true,
            'X'                          => true,
            'Y'                          => true,
            'YEAR'                       => true,
            'YEARWEEK'                   => true,
        ];

        $options += [
            // インデント文字
            'indent'    => "  ",
            // インラインレベル
            'inline'    => 999,
            // 括弧の展開レベル
            'nestlevel' => 1,
            // キーワードの大文字/小文字可変換（true だと大文字化。false だと小文字化。あるいは 'ucfirst' 等の文字列関数を直接指定する。クロージャでも良い）
            'case'      => null,
            // シンタックス装飾（true だと SAPI に基づいてよしなに。"html", "cli" だと SAPI を明示的に指定。クロージャだと直接コール）
            'highlight' => null,
            // 最大折返し文字数（未実装）
            'wrapsize'  => false,
        ];

        if ($options['case'] === true) {
            $options['case'] = 'strtoupper';
        }
        elseif ($options['case'] === false) {
            $options['case'] = 'strtolower';
        }

        if ($options['highlight'] === true) {
            $options['highlight'] = php_sapi_name() === 'cli' ? 'cli' : 'html';
        }
        if (is_string($options['highlight'])) {
            $rules = [
                'cli'  => [
                    'KEYWORD' => fn($token) => "\e[1m" . $token . "\e[m",
                    'COMMENT' => fn($token) => "\e[33m" . $token . "\e[m",
                    'STRING'  => fn($token) => "\e[31m" . $token . "\e[m",
                    'NUMBER'  => fn($token) => "\e[36m" . $token . "\e[m",
                ],
                'html' => [
                    'KEYWORD' => fn($token) => "<span style='font-weight:bold;'>" . htmlspecialchars($token, ENT_QUOTES) . "</span>",
                    'COMMENT' => fn($token) => "<span style='color:#FF8000;'>" . htmlspecialchars($token, ENT_QUOTES) . "</span>",
                    'STRING'  => fn($token) => "<span style='color:#DD0000;'>" . htmlspecialchars($token, ENT_QUOTES) . "</span>",
                    'NUMBER'  => fn($token) => "<span style='color:#0000BB;'>" . htmlspecialchars($token, ENT_QUOTES) . "</span>",
                ],
            ];
            $rule = $rules[$options['highlight']] ?? throw new \InvalidArgumentException('highlight must be "cli" or "html".');
            $options['highlight'] = function ($token, $ttype) use ($keywords, $rule) {
                switch (true) {
                    case isset($keywords[strtoupper($token)]):
                        return $rule['KEYWORD']($token);
                    case in_array($ttype, [T_COMMENT, T_DOC_COMMENT]):
                        return $rule['COMMENT']($token);
                    case in_array($ttype, [T_CONSTANT_ENCAPSED_STRING, T_ENCAPSED_AND_WHITESPACE]):
                        return $rule['STRING']($token);
                    case in_array($ttype, [T_LNUMBER, T_DNUMBER]):
                        return $rule['NUMBER']($token);
                }
                return $token;
            };
        }
        $options['syntaxer'] = function ($token, $ttype) use ($options, $keywords) {
            if (in_array($ttype, [T_COMMENT, T_DOC_COMMENT, T_CONSTANT_ENCAPSED_STRING], true)) {
                $tokens = [$token];
            }
            else {
                $tokens = explode(' ', $token);
            }

            $result = [];
            foreach ($tokens as $token) {
                if ($options['case'] && isset($keywords[strtoupper($token)])) {
                    $token = $options['case']($token);
                }
                if ($options['highlight']) {
                    $token = $options['highlight']($token, $ttype);
                }
                $result[] = $token;
            }
            return implode(' ', $result);
        };

        // 構文解析も先読みもない素朴な実装なので、特定文字列をあとから置換するための目印文字列
        $MARK = unique_string($sql, 8);
        $MARK_BR = "{$MARK}_BR:}"; // 改行マーク
        $MARK_CS = "{$MARK}_CS:}"; // コメント開始マーク
        $MARK_CE = "{$MARK}_CE:}"; // コメント終了マーク
        $MARK_NT = "{$MARK}_NT:}"; // インデントマーク
        $MARK_SP = "{$MARK}_SP:}"; // スペースマーク
        $MARK_PT = "{$MARK}_PT:}"; // 括弧ネストマーク

        // 字句にバラす（シンタックスが php に似ているので token_get_all で大幅にサボることができる）
        $tokens = [];
        $comment = '';
        $last = [];
        foreach (\PhpToken::tokenize("<?php $sql") as $token) {
            // パースのために無理やり <?php を付けているので無視
            if ($token->id === T_OPEN_TAG) {
                continue;
            }

            // '--' は php ではデクリメントだが sql ではコメントなので特別扱いする
            if ($token->id === T_DEC) {
                $comment = $token->text;
            }
            // 改行は '--' コメントの終わり
            elseif ($comment && in_array($token->id, [T_WHITESPACE, T_COMMENT], true) && strpos($token->text, "\n") !== false) {
                $tokens[] = new \PhpToken(T_COMMENT, $comment . $token->text);
                $comment = '';
            }
            // コメント中はコメントに格納する
            elseif ($comment) {
                $comment .= $token->text;
            }
            // END IF, END LOOP などは一つのトークンとする
            elseif (strtoupper($last->text ?? '') === 'END' && in_array(strtoupper($token->text), ['CASE', 'IF', 'LOOP', 'REPEAT', 'WHILE'], true)) {
                $lasttoken = $tokens[array_key_last($tokens)];
                $lasttoken->text .= " " . $token->text;
            }
            // 上記以外はただのトークンとして格納する
            else {
                // `string` のような文字列は T_ENCAPSED_AND_WHITESPACE として得られる（ただし ` がついていないので付与）
                if ($token->id === T_ENCAPSED_AND_WHITESPACE) {
                    $tokens[] = new \PhpToken($token->id, "`{$token->text}`");
                }
                elseif ($token->id !== T_WHITESPACE && $token->text !== '`') {
                    $tokens[] = new \PhpToken($token->id, $token->text);
                }
            }

            if ($token->id !== T_WHITESPACE) {
                $last = $token;
            }
        }

        // コメント以外の前後のトークンを返すクロージャ
        $seek = function ($start, $step) use ($tokens) {
            $comments = [];
            for ($n = 1; ; $n++) {
                $index = $start + $n * $step;
                if (!isset($tokens[$index])) {
                    break;
                }
                $token = $tokens[$index];
                if ($token->id === T_COMMENT || $token->id === T_DOC_COMMENT) {
                    $comments[] = trim($token->text);
                }
                else {
                    return [$index, trim($token->text), $comments];
                }
            }
            return [$start, '', $comments];
        };

        $interpret = function (&$index = -1, $context = '', $breaker = '', $nest = 0) use (&$interpret, $MARK_BR, $MARK_CS, $MARK_CE, $MARK_NT, $MARK_SP, $MARK_PT, $tokens, $options, $seek) {
            $index++;
            $beginning = true; // クエリの冒頭か
            $subcontext = '';  // SET, VALUES などのサブ分類
            $modifier = '';    // RIGHT などのキーワード修飾語
            $firstcol = null;  // SELECT における最初の列か

            $result = [];
            for ($token_length = count($tokens); $index < $token_length; $index++) {
                $token = $tokens[$index];
                $ttype = $token->id;

                $rawtoken = trim($token->text);
                $virttoken = $options['syntaxer']($rawtoken, $ttype);
                $uppertoken = strtoupper($rawtoken);

                // SELECT の直後には DISTINCT などのオプションが来ることがあるので特別扱い
                if ($context === 'SELECT' && $firstcol) {
                    if (!in_array($uppertoken, ['DISTINCT', 'DISTINCTROW', 'STRAIGHT_JOIN'], true) && !preg_match('#^SQL_#i', $uppertoken)) {
                        $firstcol = false;
                        $result[] = $MARK_BR;
                    }
                }

                // コメントは特別扱いでただ付け足すだけ
                if ($ttype === T_COMMENT || $ttype === T_DOC_COMMENT) {
                    $result[] = ($beginning ? '' : $MARK_CS) . $virttoken . $MARK_CE . $MARK_BR;
                    continue;
                }

                $prev = $seek($index, -1);
                $next = $seek($index, +1);

                switch ($uppertoken) {
                    default:
                        _DEFAULT:
                        // （コメントを含めた）先頭行にスペースがついてしまう
                        // "tablename. columnname" になってしまう
                        // "@ var" になってしまう
                        // ": holder" になってしまう
                        if (!in_array($prev[1], ['', '.', '@', ':', ';'], true)) {
                            $result[] = $MARK_SP;
                        }

                        $result[] = $virttoken;

                        // "tablename .columnname" になってしまう
                        // "columnname ," になってしまう
                        // mysql において関数呼び出し括弧の前に空白は許されない
                        // ただし、関数呼び出しではなく記号の場合はスペースを入れたい（ colname = (SELECT ～) など）
                        if (!in_array($prev[1], [';']) && !in_array($next[1], ['.', ',', '(', ';']) || ($next[1] === '(' && !preg_match('#^[a-z0-9_"\'`]+$#i', $rawtoken))) {
                            $result[] = $MARK_SP;
                        }
                        break;
                    case "@":
                    case ":":
                        $result[] = $MARK_SP . $virttoken;
                        break;
                    case ".":
                        $result[] = $virttoken;
                        break;
                    case ",":
                        if ($subcontext === 'LIMIT') {
                            $result[] = $virttoken . $MARK_SP;
                            break;
                        }
                        $result[] = $virttoken . $MARK_BR;
                        break;
                    case ";":
                        $result[] = $virttoken . $MARK_BR;
                        break;
                    case "WITH":
                        $result[] = $virttoken;
                        $result[] = $MARK_BR;
                        break;
                    /** @noinspection PhpMissingBreakStatementInspection */
                    case "BETWEEN":
                        $subcontext = $uppertoken;
                        goto _DEFAULT;
                    case "CREATE":
                    case "ALTER":
                    case "DROP":
                        $result[] = $MARK_SP . $virttoken . $MARK_SP;
                        $context = $uppertoken;
                        break;
                    case "TABLE":
                        // CREATE TABLE tablename は括弧があるので何もしなくて済むが、
                        // ALTER TABLE tablename は括弧がなく ADD などで始まるので特別分岐
                        $index = $next[0];
                        $result[] = $MARK_SP . $virttoken . $MARK_SP . ($MARK_SP . implode('', $next[2]) . $MARK_CE) . $next[1] . $MARK_SP;
                        if ($context !== 'CREATE' && $context !== 'DROP') {
                            $result[] = $MARK_BR;
                        }
                        break;
                    /** @noinspection PhpMissingBreakStatementInspection */
                    case "AND":
                        // BETWEEN A AND B と論理演算子の AND が競合するので分岐後にフォールスルー
                        if ($subcontext === 'BETWEEN') {
                            $subcontext = '';
                            $result[] = $MARK_SP . $virttoken . $MARK_SP;
                            break;
                        }
                        goto _BINARY_OPERATOR_;
                    /** @noinspection PhpMissingBreakStatementInspection */
                    case "OR":
                        // CREATE OR REPLACE
                        if ($context === 'CREATE') {
                            $result[] = $MARK_SP . $virttoken . $MARK_SP;
                            break;
                        }
                        goto _BINARY_OPERATOR_;
                    case "XOR":
                        _BINARY_OPERATOR_:
                        // WHEN の条件はカッコがない限り改行しない
                        if ($subcontext === 'WHEN') {
                            $result[] = $MARK_SP . $virttoken . $MARK_SP;
                            break;
                        }
                        $result[] = $MARK_SP . $MARK_BR . $MARK_NT . $virttoken . $MARK_SP;
                        break;
                    case "UNION":
                    case "EXCEPT":
                    case "INTERSECT":
                        $result[] = $MARK_BR . $virttoken . $MARK_SP;
                        $result[] = $MARK_BR;
                        break;
                    case "BY":
                    case "ALL":
                    case "RECURSIVE":
                    case "LATERAL":
                        $result[] = $MARK_SP . $virttoken . $MARK_SP . array_pop($result);
                        break;
                    case "SELECT":
                        if (!$beginning) {
                            $result[] = $MARK_BR;
                        }
                        $result[] = $virttoken;
                        $context = $uppertoken;
                        $firstcol = true;
                        break;
                    case "LEFT":
                        /** @noinspection PhpMissingBreakStatementInspection */
                    case "RIGHT":
                        // 例えば LEFT や RIGHT は関数呼び出しの場合もあるので分岐後にフォールスルー
                        if ($next[1] === '(') {
                            goto _DEFAULT;
                        }
                    case "CROSS":
                    case "INNER":
                    case "OUTER":
                        $modifier .= $virttoken . $MARK_SP;
                        break;
                    case "FROM":
                    case "JOIN":
                    case "WHERE":
                    case "HAVING":
                    case "GROUP":
                    case "ORDER":
                    case "LIMIT":
                    case "OFFSET":
                        $subcontext = $uppertoken;
                        $result[] = $MARK_BR . $modifier . $virttoken;
                        $result[] = $MARK_BR; // のちの BY のために結合はせず後ろに入れるだけにする
                        $modifier = '';
                        break;
                    case "FOR":
                    case "LOCK":
                        $result[] = $MARK_BR . $virttoken . $MARK_SP;
                        break;
                    case "ON":
                        // ON は ON でも mysql の ON DUPLICATED かもしれない（pgsql の ON CONFLICT も似たようなコンテキスト）
                        if (in_array(strtoupper($next[1]), ['DUPLICATE', 'CONFLICT'], true)) {
                            $result[] = $MARK_BR;
                        }
                        else {
                            $result[] = $MARK_SP;
                        }
                        $result[] = $virttoken . $MARK_SP;
                        break;
                    case "SET":
                        if ($context === "INSERT" || $context === "UPDATE") {
                            $subcontext = $uppertoken;
                            $result[] = $MARK_BR . $virttoken . $MARK_BR;
                        }
                        elseif ($context === "ALTER" || $subcontext === "REFERENCES") {
                            $result[] = $MARK_SP . $virttoken;
                        }
                        else {
                            $result[] = $virttoken;
                        }
                        break;
                    case "INSERT":
                    case "REPLACE":
                        $result[] = $virttoken . $MARK_SP;
                        $context = "INSERT"; // 構文的には INSERT と同じ
                        break;
                    case "INTO":
                        if ($context === "SELECT") {
                            $result[] = $MARK_BR;
                        }
                        $result[] = $virttoken;
                        if ($context === "INSERT") {
                            $result[] = $MARK_BR;
                        }
                        break;
                    case "VALUES":
                        if ($context === "UPDATE") {
                            $result[] = $MARK_SP . $virttoken;
                        }
                        else {
                            $result[] = $MARK_BR . $virttoken . $MARK_BR;
                        }
                        break;
                    case "REFERENCES":
                        $result[] = $MARK_SP . $virttoken . $MARK_SP;
                        $subcontext = $uppertoken;
                        break;
                    case "UPDATE":
                    case "DELETE":
                        $result[] = $virttoken;
                        if ($context !== 'CREATE' && $subcontext !== 'REFERENCES') {
                            $result[] = $MARK_BR;
                            $context = $uppertoken;
                        }
                        break;
                    case "IF":
                        $subcontext = $uppertoken;
                        $result[] = $virttoken;
                        break;
                    /** @noinspection PhpMissingBreakStatementInspection */
                    case "WHEN":
                        $subcontext = $uppertoken;
                        $result[] = $MARK_BR . $MARK_NT . $virttoken . $MARK_SP;
                        break;
                    case "ELSE":
                        if ($context === 'CASE') {
                            $result[] = $MARK_BR . $MARK_NT . $virttoken . $MARK_SP;
                            break;
                        }
                        $result[] = $virttoken . $MARK_SP;
                        break;
                    case "CASE":
                        $parts = $interpret($index, $uppertoken, 'END', $nest + 1);
                        $parts = str_replace($MARK_BR, $MARK_BR . $MARK_NT, $parts);
                        $result[] = $MARK_NT . $virttoken . $MARK_SP . $parts;
                        break;
                    case "BEGIN":
                        if ($next[1] === ';') {
                            $result[] = $virttoken;
                        }
                        else {
                            $parts = $interpret($index, $uppertoken, 'END', $nest + 1);
                            $parts = preg_replace("#^($MARK_SP)+#u", "", $parts);
                            $parts = preg_replace("#$MARK_BR#u", $MARK_BR . $MARK_NT, $parts, substr_count($parts, $MARK_BR) - 1);
                            $result[] = $MARK_BR . $virttoken . $MARK_BR . $MARK_NT . $parts;
                        }
                        break;
                    case "COMMIT":
                    case "ROLLBACK":
                    case "SAVEPOINT":
                    case "RELEASE":
                        // begin は begin～end の一部の可能性があるが commit,rollback は俺の知る限りそのような構文はない
                        $result[] = $virttoken;
                        break;
                    case "END":
                        if ($context === 'CASE') {
                            $result[] = $MARK_BR;
                        }
                        $result[] = $virttoken;
                        break;
                    case "(":
                        if ($next[1] === ')') {
                            $result[] = $virttoken . implode('', $next[2]) . ')';
                            $index = $next[0];
                            break;
                        }

                        $parts = $uppertoken . $MARK_BR . $interpret($index, $uppertoken, ')', $nest + 1);

                        // コメントを含まない指定ネストレベルなら改行とインデントを吹き飛ばす
                        if (strpos($parts, $MARK_CE) === false && ($nest >= $options['inline'] || substr_count($parts, $MARK_PT) < $options['nestlevel'])) {
                            $parts = strtr($parts, [
                                $MARK_BR => "",
                                $MARK_NT => "",
                            ]);
                            $parts = preg_replace("#\\(($MARK_SP)+#u", '(', $parts);
                            $parts = preg_replace("#($MARK_SP)+\\)#u", ')', $parts);
                        }
                        elseif ($context === 'CREATE') {
                            // ???
                            assert($context === 'CREATE');
                        }
                        else {
                            $lastnt = $MARK_NT;
                            $brnt = $MARK_BR . $MARK_NT;
                            if (strtoupper($next[1]) === 'SELECT') {
                                $brnt .= $lastnt;
                            }
                            $parts = preg_replace("#($MARK_BR(?!\\)))+#u", $brnt, $parts) . $lastnt;
                            $parts = preg_replace("#($MARK_BR(\\)))+#u", "$MARK_BR$MARK_NT)", $parts) . $lastnt;
                            $parts = preg_replace("#$MARK_CS#u", "", $parts);
                        }

                        // IN や数式はネストとみなさない
                        $suffix = $MARK_PT;
                        if (strtoupper($prev[1]) === 'IN' || !preg_match('#^[a-z0-9_]+$#i', $prev[1])) {
                            $suffix = '';
                        }

                        $result[] = $MARK_NT . $parts . $suffix;
                        break;
                    case ")":
                        $result[] = $MARK_BR . $virttoken;
                        break;
                }

                $beginning = false;

                if ($uppertoken === $breaker) {
                    break;
                }
            }
            return implode('', $result);
        };

        $result = $interpret();
        $result = preg_replaces("#" . implode('|', [
                // 改行文字＋インデント文字をインデントとみなす（改行＋連続スペースもついでに）
                "(?<indent>$MARK_BR(($MARK_NT|$MARK_SP)+))",
                // 末尾スペースは除去
                "(?<spbr>($MARK_SP)+(?=$MARK_BR))",
                // 行末コメントと単一コメント
                "(?<cs1>$MARK_BR$MARK_CS)",
                "(?<cs2>$MARK_CS)",
                // 連続改行は1つに集約
                "(?<br>$MARK_BR(($MARK_NT|$MARK_SP)*)($MARK_BR)*)",
                // 連続スペースは1つに集約
                "(?<sp>($MARK_SP)+)",
                // 下記はマーカ文字が現れないように単純置換
                "(?<ce>$MARK_CE)",
                "(?<nt>$MARK_NT)",
                "(?<pt>$MARK_PT)",
            ]) . "#u", [
            'indent' => fn($str) => "\n" . str_repeat($options['indent'], (substr_count($str, $MARK_NT) + substr_count($str, $MARK_SP))),
            'spbr'   => "",
            'cs1'    => "\n" . $options['indent'],
            'cs2'    => "",
            'br'     => "\n",
            'sp'     => ' ',
            'ce'     => "",
            'nt'     => "",
            'pt'     => "",
        ], $result);

        return trim($result);
    }
}

assert(!function_exists('ryunosuke\\dbml\\sql_quote') || (new \ReflectionFunction('ryunosuke\\dbml\\sql_quote'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\sql_quote')) {
    /**
     * ものすごく雑に値をクオートする
     *
     * 非常に荒くアドホックに実装しているのでこの関数で得られた値で**実際に実行してはならない**。
     * あくまでログ出力やデバッグ用途で視認性を高める目的である。
     *
     * - null は NULL になる
     * - 数字はそのまま数字になる
     * - bool は 0 or 1 になる
     * - 配列は再帰的にカンマ区切りになる
     *   - この実装はエラー回避の意味合いが強く、実装は変更される可能性がある
     * - それ以外は addcslashes される
     *
     * Example:
     * ```php
     * that(sql_quote(null))->isSame('NULL');
     * that(sql_quote(123))->isSame(123);
     * that(sql_quote(true))->isSame(1);
     * that(sql_quote("hoge"))->isSame("'hoge'");
     * that(sql_quote([1, 2, 3]))->isSame("1,2,3");
     * ```
     *
     * @package ryunosuke\Functions\Package\database
     *
     * @param mixed $value クオートする値
     * @return mixed クオートされた値
     */
    function sql_quote($value)
    {
        if ($value === null) {
            return 'NULL';
        }
        if (is_numeric($value)) {
            return $value;
        }
        if (is_bool($value)) {
            return (int) $value;
        }
        if (is_iterable($value) && !is_stringable($value)) {
            return implode(',', array_map(fn($v) => sql_quote($v), arrayval($value)));
        }
        return "'" . addcslashes((string) $value, "\0\e\f\n\r\t\v'\\") . "'";
    }
}

assert(!function_exists('ryunosuke\\dbml\\csv_import') || (new \ReflectionFunction('ryunosuke\\dbml\\csv_import'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\csv_import')) {
    /**
     * CSV 的文字列を連想配列の配列に変換する
     *
     * 1行目をヘッダ文字列とみなしてそれをキーとした連想配列の配列を返す。
     * ただし、オプションで headers が与えられた場合はそれを使用する。
     * この headers オプションはヘッダフィルタも兼ねる（[n => header] で「n 番目フィールドを header で取り込み」となる）。
     * 入力にヘッダがありかつ headers に連想配列が渡された場合はフィルタ兼読み換えとなる（Example を参照）。
     *
     * structure オプションが渡された場合は query like なヘッダーで配列になる。
     *
     * callback オプションが渡された場合は「あらゆる処理の最後」にコールされる。
     * つまりヘッダの読み換えや文字エンコーディングの変換が行われた後の状態でコールされる。
     * また、 false を返すとその要素はスルーされる。
     *
     * メモリ効率は意識しない（どうせ配列を返すので意識しても無駄）。
     *
     * Example:
     * ```php
     * // シンプルな実行例
     * that(csv_import("
     * a,b,c
     * A1,B1,C1
     * A2,B2,C2
     * A3,B3,C3
     * "))->is([
     *     ['a' => 'A1', 'b' => 'B1', 'c' => 'C1'],
     *     ['a' => 'A2', 'b' => 'B2', 'c' => 'C2'],
     *     ['a' => 'A3', 'b' => 'B3', 'c' => 'C3'],
     * ]);
     *
     * // ヘッダを指定できる
     * that(csv_import("
     * A1,B1,C1
     * A2,B2,C2
     * A3,B3,C3
     * ", [
     *     'headers' => [0 => 'a', 2 => 'c'], // 1がないので1番目のフィールドを読み飛ばしつつ、0, 2 は "a", "c" として取り込む
     * ]))->is([
     *     ['a' => 'A1', 'c' => 'C1'],
     *     ['a' => 'A2', 'c' => 'C2'],
     *     ['a' => 'A3', 'c' => 'C3'],
     * ]);
     *
     * // ヘッダありで連想配列で指定するとキーの読み換えとなる（指定しなければ読み飛ばしも行える）
     * that(csv_import("
     * a,b,c
     * A1,B1,C1
     * A2,B2,C2
     * A3,B3,C3
     * ", [
     *     'headers' => ['a' => 'hoge', 'c' => 'piyo'], // a は hoge, c は piyo で読み込む。 b は指定がないので飛ばされる
     * ]))->is([
     *     ['hoge' => 'A1', 'piyo' => 'C1'],
     *     ['hoge' => 'A2', 'piyo' => 'C2'],
     *     ['hoge' => 'A3', 'piyo' => 'C3'],
     * ]);
     *
     * // structure:true で配列も扱える
     * that(csv_import("
     * scalar,list[],list[],hash[a],hash[b]
     * 123,list11,list12,hash1A,hash1B
     * 456,list21,list22,hash2A,hash2B
     * ", [
     *     'structure' => true,
     * ]))->is([
     *     ['scalar' => '123', 'list' => ['list11', 'list12'], 'hash' => ['a' => 'hash1A', 'b' => 'hash1B']],
     *     ['scalar' => '456', 'list' => ['list21', 'list22'], 'hash' => ['a' => 'hash2A', 'b' => 'hash2B']],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param string|resource $csvstring CSV 的文字列。ファイルポインタでも良いが終了後に必ず閉じられる
     * @param array $options オプション配列。fgetcsv の第3引数以降もここで指定する
     * @return array 連想配列の配列
     */
    function csv_import($csvstring, $options = [])
    {
        $options += [
            'delimiter' => ',',
            'enclosure' => '"',
            'escape'    => '\\',
            'encoding'  => ini_get('default_charset'),
            'scrub'     => 'IGNORE',
            'initial'   => [],
            'headers'   => [],
            'headermap' => null,
            'structure' => false,
            'grouping'  => null,
            'callback'  => null, // map + filter 用コールバック（1行が参照で渡ってくるので書き換えられる&&false を返すと結果から除かれる）
            'limit'     => null, // 正味のデータ行の最大値（超えた場合はそこで処理を終了する。例外が飛んだりはしない）
        ];

        // 文字キーを含む場合はヘッダーありの読み換えとなる
        if (is_array($options['headers']) && count(array_filter(array_keys($options['headers']), 'is_string')) > 0) {
            $options['headermap'] = $options['headers'];
            $options['headers'] = null;
        }

        if (is_resource($csvstring)) {
            $fp = $csvstring;
        }
        else {
            $fp = fopen('php://temp', 'r+b');
            fwrite($fp, $csvstring);
            rewind($fp);
        }

        $restore = set_error_exception_handler();
        try {
            $n = -1;
            return (function ($fp, $delimiter, $enclosure, $escape, $encoding, $scrub, $initial, $headers, $headermap, $structure, $grouping, $callback, $limit) use (&$n) {
                $default_charset = ini_get('default_charset');
                if ($default_charset !== $encoding) {
                    stream_filter_append($fp, "convert.iconv.$encoding/$default_charset" . (strlen($scrub) ? "//$scrub" : ""), STREAM_FILTER_READ);
                }

                foreach ($initial as $rule => $count) {
                    for ($i = 0; $i < $count; $i++) {
                        if ($rule === 'byte') {
                            fgetc($fp);
                        }
                        elseif ($rule === 'line') {
                            fgets($fp);
                        }
                        elseif ($rule === 'csv') {
                            fgetcsv($fp, 0, $delimiter, $enclosure, $escape);
                        }
                    }
                }

                $result = [];
                while ($row = fgetcsv($fp, 0, $delimiter, $enclosure, $escape)) {
                    if ($row === [null]) {
                        continue;
                    }
                    if (!$headers) {
                        $headers = $row;
                        continue;
                    }

                    $n++;
                    if ($structure) {
                        $query = [];
                        foreach ($headers as $i => $header) {
                            $query[] = rawurlencode($header) . "=" . rawurlencode($row[$i]);
                        }
                        $row = query_parse(implode('&', $query), '&', PHP_QUERY_RFC3986);
                        // csv の仕様上、空文字を置かざるを得ないが、数値配列の場合は空にしたいことがある
                        $row = array_map_recursive($row, function ($v) {
                            if (is_array($v) && is_indexarray($v)) {
                                return array_values(array_filter($v, function ($v) {
                                    if (is_array($v)) {
                                        $v = implode('', array_flatten($v));
                                    }
                                    return strlen($v);
                                }));
                            }
                            return $v;
                        }, true, true);
                    }
                    else {
                        $row = array_combine($headers, array_intersect_key($row, $headers));
                    }
                    if ($headermap) {
                        $row = array_pickup($row, $headermap);
                    }
                    if ($callback) {
                        if ($callback($row, $n) === false) {
                            continue;
                        }
                    }

                    if ($grouping !== null) {
                        foreach ($row as $column => $value) {
                            $parts = explode($grouping, $column, 2);
                            if (count($parts) === 1) {
                                array_unshift($parts, "");
                            }
                            $result[$parts[0]][$n][$parts[1]] = $value;
                        }
                    }
                    else {
                        $result[] = $row;
                    }

                    if ($limit !== null && count($result) >= $limit) {
                        break;
                    }
                }

                if ($grouping !== null) {
                    foreach ($result as $g => $rows) {
                        $result[$g] = array_values(array_unique($rows, SORT_REGULAR));
                    }
                }

                return $result;
            })($fp, $options['delimiter'], $options['enclosure'], $options['escape'], $options['encoding'], $options['scrub'], $options['initial'], $options['headers'], $options['headermap'], $options['structure'], $options['grouping'], $options['callback'], $options['limit']);
        }
        catch (\Throwable $t) {
            // 何行目？ が欲しくなることが非常に多いので例外メッセージを書き換える
            $message = new \ReflectionProperty($t, 'message');
            $message->setAccessible(true);
            $message->setValue($t, "csv#$n: " . $t->getMessage());
            throw $t;
        }
        finally {
            $restore();
            fclose($fp);
        }
    }
}

assert(!function_exists('ryunosuke\\dbml\\json_import') || (new \ReflectionFunction('ryunosuke\\dbml\\json_import'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\json_import')) {
    /**
     * json_decode のプロキシ関数
     *
     * 引数体系とデフォルト値を変更してある。
     *
     * JSON_ES5 に null か true を渡すと json5 としてでデコードする（null はまず json_decode で試みる、true は json5 のみ）。
     * その場合拡張オプションとして下記がある。
     *
     * - JSON_INT_AS_STRING: 常に整数を文字列で返す
     * - JSON_FLOAT_AS_STRING: 常に小数を文字列で返す
     * - JSON_BARE_AS_STRING: bare string を文字列として扱う
     * - JSON_TEMPLATE_LITERAL: テンプレートリテラルが使用可能になる
     *   - あくまで「文字列の括りに ` が使えるようになる」というものでテンプレートリテラルそのものではない
     *   - 末尾のインデントと同じインデントがすべて除去され、前後の改行は取り除かれる
     *
     * Example:
     * ```php
     * // オプションはこのように [定数 => bool] で渡す。false は指定されていないとみなされる（JSON_MAX_DEPTH 以外）
     * that(json_import('{"a":"A","b":"B"}', [
     *    JSON_OBJECT_AS_ARRAY => true,
     * ]))->is(['a' => 'A', 'b' => 'B']);
     *
     * // json5 が使える
     * that(json_import('{a: "A", b: "B", }'))->is(['a' => 'A', 'b' => 'B']);
     *
     * // テンプレートリテラル
     * that(json_import('`
     *     1
     *     2
     *     3
     *     `', [
     *     JSON_TEMPLATE_LITERAL => true,
     * ]))->is("1\n2\n3");
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param string $value JSON 文字列
     * @param array $options JSON_*** をキーにした連想配列。値が false は指定されていないとみなされる
     * @return mixed decode された値
     */
    function json_import($value, $options = [])
    {
        $specials = [
            JSON_OBJECT_AS_ARRAY     => true, // 個人的嗜好だが連想配列のほうが扱いやすい
            JSON_MAX_DEPTH           => 512,
            JSON_ES5                 => null,
            JSON_INT_AS_STRING       => false,
            JSON_FLOAT_AS_STRING     => false,
            JSON_TEMPLATE_LITERAL    => false,
            JSON_BARE_AS_STRING      => false,
            JSON_ESCAPE_SINGLE_QUOTE => true,
        ];
        foreach ($specials as $key => $default) {
            $specials[$key] = $options[$key] ?? $default;
            unset($options[$key]);
        }
        $specials[JSON_THROW_ON_ERROR] = $options[JSON_THROW_ON_ERROR] ?? true;
        $specials[JSON_BIGINT_AS_STRING] = $options[JSON_BIGINT_AS_STRING] ?? false;
        if ($specials[JSON_INT_AS_STRING] || $specials[JSON_FLOAT_AS_STRING] || $specials[JSON_TEMPLATE_LITERAL] || $specials[JSON_BARE_AS_STRING]) {
            $specials[JSON_ES5] = true;
        }

        // true でないならまず json_decode で試行（json が来るならその方が遥かに速い）
        if ($specials[JSON_ES5] === false || $specials[JSON_ES5] === null) {
            $option = array_sum(array_keys(array_filter($options)));
            $result = json_decode($value, $specials[JSON_OBJECT_AS_ARRAY], $specials[JSON_MAX_DEPTH], $option);

            // エラーが出なかったらもうその時点で返せば良い
            if (json_last_error() === JSON_ERROR_NONE) {
                return $result;
            }
            // json5 を試行しないモードならこの時点で例外
            if ($specials[JSON_ES5] === false) {
                throw new \ErrorException(json_last_error_msg(), json_last_error());
            }
        }

        // 上記を通り抜けたら json5 で試行
        $parser = new class($value) {
            private $json_string;
            private $type;
            private $begin_position;
            private $end_position;
            private $keys;
            private $values;

            public function __construct($json_string)
            {
                $this->json_string = "<?php [$json_string]";
            }

            public function parse($options)
            {
                $tokens = php_tokens($this->json_string);
                array_shift($tokens);

                $braces = [];
                for ($i = 0; $i < count($tokens); $i++) {
                    $token = $tokens[$i];
                    if ($token->text === '{' || $token->text === '[') {
                        if ($options[JSON_MAX_DEPTH] <= count($braces) + 1) {
                            throw $this->exception("Maximum stack depth exceeded", $token);
                        }
                        $braces[] = $i;
                    }
                    elseif ($token->text === '}' || $token->text === ']') {
                        if (!$braces) {
                            throw $this->exception("Mismatch", $token);
                        }
                        $brace = array_pop($braces);
                        if ($tokens[$brace]->text !== '{' && $token->text === '}' || $tokens[$brace]->text !== '[' && $token->text === ']') {
                            throw $this->exception("Mismatch", $token);
                        }
                        $block = array_filter(array_slice(array_splice($tokens, $brace + 1, $i - $brace, []), 0, -1), fn($token) => !(!$token instanceof $this && in_array($token->id, [T_WHITESPACE, T_COMMENT, T_DOC_COMMENT, T_BAD_CHARACTER], true)));
                        $elements = array_explode($block, fn($token) => !$token instanceof $this && $token->text === ',');
                        // for trailing comma
                        if ($elements && !$elements[count($elements) - 1]) {
                            array_pop($elements);
                        }
                        // check consecutive comma (e.g. [1,,3])
                        if (count(array_filter($elements)) !== count($elements)) {
                            throw $this->exception("Missing element", $token);
                        }
                        $i = $brace;
                        if ($token->text === '}') {
                            $object = $this->token('object', $tokens[$brace]->pos, $token->pos + strlen($token->text));
                            foreach ($elements as $element) {
                                $keyandval = array_explode($element, fn($token) => !$token instanceof $this && $token->text === ':', 2);
                                // check no colon (e.g. {123})
                                if (count($keyandval) !== 2) {
                                    throw $this->exception("Missing object key", first_value($keyandval[0]));
                                }
                                // check objective key (e.g. {[1]: 123})
                                if (($k = array_find_first($keyandval[0], fn($v) => $v instanceof $this)) !== null) {
                                    throw $this->exception("Unexpected object key", $keyandval[0][$k]);
                                }
                                // check consecutive objective value (e.g. {k: 123 [1]})
                                if (!(count($keyandval[1]) === 1 && count(array_filter($keyandval[1], fn($v) => $v instanceof $this)) === 1 || count(array_filter($keyandval[1], fn($v) => !$v instanceof $this)) === count($keyandval[1]))) {
                                    throw $this->exception("Unexpected object value", $token);
                                }
                                $key = first_value($keyandval[0]);
                                $lastkey = last_value($keyandval[0]);
                                $val = first_value($keyandval[1]);
                                $lastval = last_value($keyandval[1]);
                                if (!$val instanceof $this) {
                                    $val = $this->token('value', $val->pos, $lastval->pos + strlen($lastval->text));
                                }
                                $object->append($this->token('key', $key->pos, $lastkey->pos + strlen($lastkey->text)), $val);
                            }
                            $tokens[$brace] = $object;
                        }
                        if ($token->text === ']') {
                            $array = $this->token('array', $tokens[$brace]->pos, $token->pos + strlen($token->text));
                            foreach ($elements as $element) {
                                // check consecutive objective value (e.g. [123 [1]])
                                if (!(count($element) === 1 && count(array_filter($element, fn($v) => $v instanceof $this)) === 1 || count(array_filter($element, fn($v) => !$v instanceof $this)) === count($element))) {
                                    throw $this->exception("Unexpected array value", $token);
                                }
                                $val = first_value($element);
                                $lastval = last_value($element);
                                if (!$val instanceof $this) {
                                    $val = $this->token('value', $val->pos, $lastval->pos + strlen($lastval->text));
                                }
                                $array->append(null, $val);
                            }
                            $tokens[$brace] = $array;
                        }
                    }
                }

                if ($braces) {
                    throw $this->exception("Mismatch", $tokens[$braces[count($braces) - 1]]);
                }

                /** @var self $root */
                $root = $tokens[0];
                $result = $root->value($options);

                if (count($result) !== 1) {
                    throw $this->exception("Mismatch", $tokens[0]);
                }
                return $result[0];
            }

            private function token($type, $begin_position, $end_position)
            {
                $clone = clone $this;
                $clone->type = $type;
                $clone->begin_position = $begin_position;
                $clone->end_position = $end_position;
                $clone->keys = [];
                $clone->values = [];
                return $clone;
            }

            private function append($key, $value)
            {
                assert(($key !== null && $this->type === 'object') || ($key === null && $this->type === 'array'));
                $this->keys[] = $key ?? count($this->keys);
                $this->values[] = $value;
            }

            private function value($options = [])
            {
                $datetimify = function ($token) use ($options) {
                    /** @var \DateTime $datetimeClass */
                    $datetimeClass = function_configure('datetime.class');
                    $rules = [
                        'Y-m-d\TH:i:s.uP' => true,
                        'Y-m-d\TH:i:s.u'  => true,
                        'Y-m-d\TH:i:sP'   => true,
                        'Y-m-d\TH:i:s'    => true,
                        'Y-m-d H:i:s.uP'  => true,
                        'Y-m-d H:i:s.u'   => true,
                        'Y-m-d H:i:sP'    => true,
                        'Y-m-d H:i:s'     => true,
                        'Y-m-d'           => false,
                    ];
                    foreach ($rules as $format => $with_time) {
                        if ($result = $datetimeClass::createFromFormat($format, $token)) {
                            if (!$with_time) {
                                $result = $result->setTime(0, 0, 0, 0);
                            }
                            return $result;
                        }
                    }
                    return null;
                };
                $numberify = function ($token) use ($options) {
                    if (is_numeric($token[0]) || $token[0] === '-' || $token[0] === '+' || $token[0] === '.') {
                        $sign = 1;
                        if ($token[0] === '+' || $token[0] === '-') {
                            $sign = substr($token, 0, 1) === '-' ? -1 : 1;
                            $token = substr($token, 1);
                        }
                        if (($token[0] ?? null) === '0' && isset($token[1]) && $token[1] !== '.') {
                            if (!($token[1] === 'x' || $token[1] === 'X')) {
                                throw $this->exception("Octal literal", $this);
                            }
                            $token = substr($token, 2);
                            if (!ctype_xdigit($token)) {
                                throw $this->exception("Bad hex number", $this);
                            }
                            $token = hexdec($token);
                        }
                        if (!is_numeric($token) || !is_finite($token)) {
                            throw $this->exception("Bad number", $this);
                        }
                        if (false
                            || ($options[JSON_INT_AS_STRING] && ctype_digit("$token"))
                            || ($options[JSON_FLOAT_AS_STRING] && !ctype_digit("$token"))
                            || ($options[JSON_BIGINT_AS_STRING] && ctype_digit("$token") && is_float(($token + 0)))
                        ) {
                            return $sign === -1 ? "-$token" : $token;
                        }

                        return 0 + $sign * $token;
                    }
                    return null;
                };
                $stringify = function ($token) use ($options) {
                    if (strlen($token) > 1 && ($token[0] === '"' || $token[0] === "'" || ($options[JSON_TEMPLATE_LITERAL] && $token[0] === "`"))) {
                        if (strlen($token) < 2 || $token[0] !== $token[-1]) {
                            throw $this->exception("Bad string", $this);
                        }
                        $rawtoken = $token;
                        $token = substr($token, 1, -1);
                        if (!$options[JSON_ESCAPE_SINGLE_QUOTE] && $rawtoken[0] === "'") {
                            return $token;
                        }
                        if ($rawtoken[0] === "`" && $rawtoken[1] === "\n" && preg_match('#\n( +)`#u', $rawtoken, $match)) {
                            $token = substr(preg_replace("#\n{$match[1]}#u", "\n", $token), 1, -1);
                        }
                        $token = preg_replace_callback('/(?:\\\\u[0-9A-Fa-f]{4})+/u', function ($m) { return json_decode('"' . $m[0] . '"'); }, $token);
                        $token = strtr($token, [
                            "\\'"    => "'",
                            "\\`"    => "`",
                            '\\"'    => '"',
                            '\\\\'   => '\\',
                            '\\/'    => '/',
                            "\\\n"   => "",
                            "\\\r"   => "",
                            "\\\r\n" => "",
                            '\\b'    => chr(8),
                            '\\f'    => "\f",
                            '\\n'    => "\n",
                            '\\r'    => "\r",
                            '\\t'    => "\t",
                        ]);
                        return $token;
                    }
                    return null;
                };

                switch ($this->type) {
                    default:
                        throw new \DomainException(); // @codeCoverageIgnore
                    case 'array':
                        return array_map(fn($value) => $value->value($options), $this->values);
                    case 'object':
                        $array = array_combine(
                            array_map(fn($value) => $value->value($options), $this->keys),
                            array_map(fn($value) => $value->value($options), $this->values)
                        );
                        return $options[JSON_OBJECT_AS_ARRAY] ? $array : (object) $array;
                    case 'key':
                        $token = substr($this->json_string, $this->begin_position, $this->end_position - $this->begin_position);
                        $token = trim($token, chr(0xC2) . chr(0xA0) . " \n\r\t\v\x00\x0c");
                        if (preg_match('/^(?:[\$_\p{L}\p{Nl}]|\\\\u[0-9A-Fa-f]{4})(?:[\$_\p{L}\p{Nl}\p{Mn}\p{Mc}\p{Nd}\p{Pc}‌‍]|\\\\u[0-9A-Fa-f]{4})*/u', $token)) {
                            $token = preg_replace_callback('/(?:\\\\u[0-9A-Fa-f]{4})+/u', fn($m) => json_decode('"' . $m[0] . '"'), $token);
                            return $token;
                        }
                        if (($string = $stringify($token)) !== null) {
                            return $string;
                        }
                        throw $this->exception("Bad identifier", $this);
                    case 'value':
                        $token = substr($this->json_string, $this->begin_position, $this->end_position - $this->begin_position);
                        $token = trim($token, chr(0xC2) . chr(0xA0) . " \n\r\t\v\x00\x0c");
                        $literals = [
                            'null'      => null,
                            'false'     => false,
                            'true'      => true,
                            'Infinity'  => INF,
                            '+Infinity' => +INF,
                            '-Infinity' => -INF,
                            'NaN'       => NAN,
                            '+NaN'      => +NAN,
                            '-NaN'      => -NAN,
                        ];
                        // literals
                        if (array_key_exists($token, $literals)) {
                            return $literals[$token];
                        }
                        // datetime
                        if (($datetime = $datetimify($token)) !== null) {
                            return $datetime;
                        }
                        // numbers
                        if (($number = $numberify($token)) !== null) {
                            return $number;
                        }
                        // strings
                        if (($string = $stringify($token)) !== null) {
                            return $string;
                        }
                        if ($options[JSON_BARE_AS_STRING]) {
                            return $token;
                        }
                        throw $this->exception("Bad value", $this);
                }
            }

            private function exception($message, $token)
            {
                if ($token instanceof $this) {
                    $line = substr_count($token->json_string, "\n", 0, $token->begin_position) + 1;
                    $column = $token->begin_position - strrpos($token->json_string, "\n", $token->begin_position - strlen($token->json_string));
                    $word = substr($token->json_string, $token->begin_position, $token->end_position - $token->begin_position);
                }
                else {
                    $line = $token->line;
                    $column = $token->pos - strrpos($this->json_string, "\n", $token->pos - strlen($this->json_string));
                    $word = $token->text;
                }
                return new \ErrorException(sprintf("%s '%s' at line %d column %d of the JSON5 data", $message, $word, $line, $column));
            }
        };

        try {
            return $parser->parse($specials);
        }
        catch (\Throwable $t) {
            if ($specials[JSON_THROW_ON_ERROR]) {
                throw $t;
            }
            // json_last_error を設定する術はないので強制的に Syntax error にする（return することで返り値も統一される）
            return @json_decode('invalid json');
        }
    }
}

assert(!function_exists('ryunosuke\\dbml\\ltsv_import') || (new \ReflectionFunction('ryunosuke\\dbml\\ltsv_import'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\ltsv_import')) {
    /**
     * LTSV 的文字列を配列に変換する
     *
     * escape オプションで「LTSV 的にまずい文字」がその文字でエスケープされる（具体的には "\n" と "\t"）。
     * デフォルトでは "\\" でエスケープされるので、整合性が崩れることはない。
     *
     * decode オプションで「`` で囲まれた値」が来たときのその関数を通して出力される。
     * デフォルトでは json_decode される。
     *
     * エンコード機能はおまけに過ぎない（大抵の場合はそんな機能は必要ない）。
     * ので、この実装は互換性を維持せず変更される可能性がある。
     *
     * Example:
     * ```php
     * // シンプルな実行例
     * that(ltsv_import("label1:value1	label2:value2"))->is([
     *     "label1" => "value1",
     *     "label2" => "value2",
     * ]);
     *
     * // タブや改行文字のエスケープ
     * that(ltsv_import("label1:val\\tue1	label2:val\\nue2"))->is([
     *     "label1" => "val\tue1",
     *     "label2" => "val\nue2",
     * ]);
     *
     * // 配列のデコード
     * that(ltsv_import("label1:value1	label2:`[1,2,3]`"))->is([
     *     "label1" => "value1",
     *     "label2" => [1, 2, 3],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param string $ltsvstring LTSV 的文字列
     * @param array $options オプション配列
     * @return array 配列
     */
    function ltsv_import($ltsvstring, $options = [])
    {
        $options += [
            'escape' => '\\',
            'decode' => fn($v) => json_decode($v, true),
        ];
        $escape = $options['escape'];
        $decode = $options['decode'];

        $map = [];
        if (strlen($escape)) {
            $map["{$escape}\\"] = "\\";
            $map["{$escape}t"] = "\t";
            $map["{$escape}n"] = "\n";
        }

        $result = [];
        foreach (explode("\t", $ltsvstring) as $part) {
            [$label, $value] = explode(':', $part, 2);
            $should_decode = substr($value, 0, 1) === '`' && substr($value, -1, 1) === '`';
            if ($map) {
                $label = strtr($label, $map);
                if (!$should_decode) {
                    $value = strtr($value, $map);
                }
            }
            if ($should_decode) {
                $value2 = $decode(substr($value, 1, -1));
                // たまたま ` が付いているだけかも知れないので結果で判定する
                if (!is_stringable($value2)) {
                    $value = $value2;
                }
            }
            $result[$label] = $value;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\paml_import') || (new \ReflectionFunction('ryunosuke\\dbml\\paml_import'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\paml_import')) {
    /**
     * paml 的文字列をパースする
     *
     * paml とは yaml を簡易化したような独自フォーマットを指す（Php Array Markup Language）。
     * ざっくりと下記のような特徴がある。
     *
     * - ほとんど yaml と同じだがフロースタイルのみでキーコロンの後のスペースは不要
     * - yaml のアンカーや複数ドキュメントのようなややこしい仕様はすべて未対応
     * - 配列を前提にしているので、トップレベルの `[]` `{}` は不要
     * - `[]` でいわゆる php の配列、 `{}` で stdClass を表す（オプション指定可能）
     * - bare string で php の定数を表す（クラス定数も完全修飾すれば使用可能）
     *
     * 簡易的な設定の注入に使える（yaml は標準で対応していないし、json や php 配列はクオートの必要やケツカンマ問題がある）。
     * なお、かなり緩くパースしてるので基本的にエラーにはならない。
     *
     * 早見表：
     *
     * - php:  `["n" => null, "f" => false, "i" => 123, "d" => 3.14, "s" => "this is string", "a" => [1, 2, "x" => "X"]]`
     *     - ダブルアローとキーのクオートが冗長
     * - json: `{"n":null, "f":false, "i":123, "d":3.14, "s":"this is string", "a":{"0": 1, "1": 2, "x": "X"}}`
     *     - キーのクオートが冗長だしケツカンマ非許容
     * - yaml: `{n: null, f: false, i: 123, d: 3.14, s: "this is string", a: {0: 1, 1: 2, x: X}}`
     *     - 理想に近いが、コロンの後にスペースが必要だし連想配列が少々難。なにより拡張や外部ライブラリが必要
     * - paml: `n:null, f:false, i:123, d:3.14, s:"this is string", a:[1, 2, x:X]`
     *     - シンプルイズベスト
     *
     * Example:
     * ```php
     * // こういったスカラー型はほとんど yaml と一緒だが、コロンの後のスペースは不要（あってもよい）
     * that(paml_import('n:null, f:false, i:123, d:3.14, s:"this is string"'))->isSame([
     *     'n' => null,
     *     'f' => false,
     *     'i' => 123,
     *     'd' => 3.14,
     *     's' => 'this is string',
     * ]);
     * // 配列が使える（キーは連番なら不要）。ネストも可能
     * that(paml_import('a:[1,2,x:X,3], nest:[a:[b:[c:[X]]]]'))->isSame([
     *     'a'    => [1, 2, 'x' => 'X', 3],
     *     'nest' => [
     *         'a' => [
     *             'b' => [
     *                 'c' => ['X']
     *             ],
     *         ],
     *     ],
     * ]);
     * // bare 文字列で定数が使える。::class も特別扱いで定数とみなす
     * that(paml_import('pv:PHP_VERSION, ao:ArrayObject::STD_PROP_LIST, class:ArrayObject::class'))->isSame([
     *     'pv'    => \PHP_VERSION,
     *     'ao'    => \ArrayObject::STD_PROP_LIST,
     *     'class' => \ArrayObject::class,
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\dataformat
     *
     * @param string $pamlstring PAML 文字列
     * @param array $options オプション配列
     * @return array php 配列
     */
    function paml_import($pamlstring, $options = [])
    {
        $options += [
            'cache'          => true,
            'trailing-comma' => true,
            'stdclass'       => true,
            'expression'     => false,
            'escapers'       => ['"' => '"', "'" => "'", '[' => ']', '{' => '}'],
        ];

        static $caches = [];
        if ($options['cache']) {
            $key = $pamlstring . json_encode($options);
            return $caches[$key] ??= paml_import($pamlstring, ['cache' => false] + $options);
        }

        $resolve = function (&$value, $options) {
            $prefix = $value[0] ?? null;
            $suffix = $value[-1] ?? null;

            if (($prefix === '[' && $suffix === ']') || ($prefix === '{' && $suffix === '}')) {
                $values = paml_import(substr($value, 1, -1), $options);
                $value = ($prefix === '[' || !$options['stdclass']) ? (array) $values : (object) $values;
                return true;
            }

            if ($prefix === '"' && $suffix === '"') {
                //$element = stripslashes(substr($element, 1, -1));
                $value2 = json_decode($value);
                if (json_last_error() === JSON_ERROR_NONE) {
                    $value = $value2;
                    return true;
                }
            }
            if ($prefix === "'" && $suffix === "'") {
                $value = substr($value, 1, -1);
                return true;
            }

            if (ctype_digit(ltrim($value, '+-'))) {
                $value = (int) $value;
                return true;
            }
            if (is_numeric($value)) {
                $value = (double) $value;
                return true;
            }

            if (defined($value)) {
                $value = constant($value);
                return true;
            }
            [$class, $cname] = explode('::', $value, 2) + [1 => ''];
            if (class_exists($class) && strtolower($cname) === 'class') {
                $value = ltrim($class, '\\');
                return true;
            }

            if ($options['expression']) {
                if ($prefix === '`' && $suffix === '`') {
                    $value = evaluate("return " . substr($value, 1, -1) . ';');
                    return true;
                }
                try {
                    $evalue = @evaluate("return $value;");
                    if ($value !== $evalue) {
                        $value = $evalue;
                        return true;
                    }
                }
                catch (\ParseError) {
                }
            }

            return false;
        };

        $values = array_map('trim', quoteexplode(',', $pamlstring, null, $options['escapers']));
        if ($options['trailing-comma'] && end($values) === '') {
            array_pop($values);
        }

        $result = [];
        foreach ($values as $value) {
            $key = null;
            if (!$resolve($value, $options)) {
                $kv = array_map('trim', quoteexplode(':', $value, 2, $options['escapers']));
                if (count($kv) === 2) {
                    [$key, $value] = $kv;
                    $resolve($key, ['expression' => false] + $options);
                    $resolve($value, $options);
                }
            }

            array_set($result, $value, is_int($key) ? null : $key);
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\date_convert') || (new \ReflectionFunction('ryunosuke\\dbml\\date_convert'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\date_convert')) {
    /**
     * 日時文字列をよしなに別のフォーマットに変換する
     *
     * マイクロ秒にも対応している。
     * かなり適当に和暦にも対応している。
     *
     * 拡張書式は下記。
     * - J: 日本元号
     *   - e.g. 平成
     *   - e.g. 令和
     * - b: 日本元号略称
     *   - e.g. H
     *   - e.g. R
     * - k: 日本元号年
     *   - e.g. 平成7年
     *   - e.g. 令和1年
     * - K: 日本元号年（1年が元年）
     *   - e.g. 平成7年
     *   - e.g. 令和元年
     * - x: 日本語曜日
     *   - e.g. 日
     *   - e.g. 月
     * - Q: 月内週番号（商が第N、余が曜日）
     *   - e.g. 6（7 * 0 + 6 第1土曜日）
     *   - e.g. 15（7 * 2 + 1 第3月曜日）
     *
     * php8.2 から x,X が追加されたため上記はあくまで参考となる。
     *
     * Example:
     * ```php
     * // 和暦を Y/m/d H:i:s に変換
     * that(date_convert('Y/m/d H:i:s', '昭和31年12月24日 12時34分56秒'))->isSame('1956/12/24 12:34:56');
     * // 単純に「マイクロ秒が使える date」としても使える
     * $now = 1234567890.123; // テストがしづらいので固定時刻にする
     * that(date_convert('Y/m/d H:i:s.u', $now))->isSame('2009/02/14 08:31:30.122999');
     * // $format に DateTimeInterface 実装クラス名を与えるとそのインスタンスを返す
     * that(date_convert(\DateTimeImmutable::class, $now))->isInstanceOf(\DateTimeImmutable::class);
     * // null は DateTimeInterface を意味する
     * that(date_convert(null, $now))->isInstanceOf(\DateTimeImmutable::class);
     * ```
     *
     * @package ryunosuke\Functions\Package\datetime
     *
     * @todo 引数を入れ替えたほうが自然な気がする
     *
     * @param ?string $format フォーマット
     * @param string|int|float|\DateTimeInterface|null $datetimedata 日時データ。省略時は microtime
     * @return string|\DateTimeInterface 日時文字列。$format が null の場合は DateTime
     */
    function date_convert($format, $datetimedata = null)
    {
        $format ??= function_configure('datetime.class');
        $return_object = class_exists($format) && is_subclass_of($format, \DateTimeInterface::class);

        if ($return_object && $datetimedata instanceof \DateTimeInterface) {
            return $datetimedata;
        }

        // 省略時は microtime
        if ($datetimedata === null) {
            $timestamp = microtime(true);
        }
        else {
            $timestamp = date_timestamp($datetimedata);
            if ($timestamp === null) {
                throw new \InvalidArgumentException("parse failed '$datetimedata'");
            }
        }

        if (!$return_object) {
            $era = array_find_first(JP_ERA, function ($era) use ($timestamp) {
                if ($era['since'] <= $timestamp) {
                    $era['year'] = idate('Y', (int) $timestamp) - idate('Y', $era['since']) + 1;
                    $era['gann'] = $era['year'] === 1 ? '元' : $era['year'];
                    return $era;
                }
            }, false);
            $format = strtr_escaped($format, [
                'J' => fn() => $era ? $era['name'] : throw new \InvalidArgumentException("notfound JP_ERA '$datetimedata'"),
                'b' => fn() => $era ? $era['abbr'] : throw new \InvalidArgumentException("notfound JP_ERA '$datetimedata'"),
                'k' => fn() => $era ? $era['year'] : throw new \InvalidArgumentException("notfound JP_ERA '$datetimedata'"),
                'K' => fn() => $era ? $era['gann'] : throw new \InvalidArgumentException("notfound JP_ERA '$datetimedata'"),
                'x' => fn() => ['日', '月', '火', '水', '木', '金', '土'][idate('w', (int) $timestamp)],
                'Q' => fn() => idate('w', $timestamp) + intdiv(idate('j', $timestamp) - 1, 7) * 7,
            ], '\\');
        }

        if (is_int($timestamp) && !$return_object) {
            return date($format, $timestamp);
        }

        $class = $return_object ? $format : function_configure('datetime.class');
        $dt = new $class();
        $dt = $dt->setTimestamp((int) $timestamp);

        if (is_float($timestamp)) {
            $diff = (int) (($timestamp - (int) $timestamp) * 1000 * 1000);
            $dt = $dt->modify("$diff microsecond");
        }

        if ($return_object) {
            return $dt;
        }
        return $dt->format($format);
    }
}

assert(!function_exists('ryunosuke\\dbml\\date_timestamp') || (new \ReflectionFunction('ryunosuke\\dbml\\date_timestamp'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\date_timestamp')) {
    /**
     * 日時的なものをよしなにタイムスタンプに変換する
     *
     * マイクロ秒にも対応している。つまり返り値は int か float になる。
     * また、相対指定の +1 month の月末問題は起きないようにしてある。
     *
     * かなり適当に和暦にも対応している。
     * さらに必要に迫られてかなり特殊な対応を行っているので Example を参照。
     *
     * Example:
     * ```php
     * // 普通の日時文字列
     * that(date_timestamp('2014/12/24 12:34:56'))->isSame(strtotime('2014/12/24 12:34:56'));
     * // 和暦
     * that(date_timestamp('昭和31年12月24日 12時34分56秒'))->isSame(strtotime('1956/12/24 12:34:56'));
     * // 相対指定
     * that(date_timestamp('2012/01/31 +1 month'))->isSame(strtotime('2012/02/29'));
     * that(date_timestamp('2012/03/31 -1 month'))->isSame(strtotime('2012/02/29'));
     * // マイクロ秒
     * that(date_timestamp('2014/12/24 12:34:56.789'))->isSame(1419392096.789);
     *
     * // ベース日時
     * $baseTimestamp = strtotime('2012/01/31');
     * // ベース日時の25日（strtotime の序数日付は first/last しか対応していないが、この関数は対応している）
     * that(date_timestamp('25th of this month', $baseTimestamp))->isSame(strtotime('2012/01/25'));
     * // ベース日時の第2月曜（strtotime の序数曜日は 1st のような表記に対応していないが、この関数は対応している）
     * that(date_timestamp('2nd monday of this month', $baseTimestamp))->isSame(strtotime('2012/01/09'));
     * ```
     *
     * @package ryunosuke\Functions\Package\datetime
     *
     * @param string|int|float|\DateTimeInterface $datetimedata 日時データ
     * @param int|null $baseTimestamp 日時データ
     * @return int|float|null タイムスタンプ。パース失敗時は null
     */
    function date_timestamp($datetimedata, $baseTimestamp = null)
    {
        if ($datetimedata instanceof \DateTimeInterface) {
            return $datetimedata->getTimestamp() + $datetimedata->format('u') / 1000 / 1000;
        }

        $DAY1 = 60 * 60 * 24;
        $ORDINAL_WORDS = [
            '1st'  => 'first',
            '2nd'  => 'second',
            '3rd'  => 'third',
            '4th'  => 'fourth',
            '5th'  => 'fifth',
            '6th'  => 'sixth',
            '7th'  => 'seventh',
            '8th'  => 'eighth',
            '9th'  => 'ninth',
            '10th' => 'tenth',
            '11th' => 'eleventh',
            '12th' => 'twelfth',
        ];

        $ordinal_day = null;
        $oddeven = null;
        if (is_string($datetimedata) || (is_object($datetimedata) && method_exists($datetimedata, '__toString'))) {
            // 全角を含めた trim
            $chars = "[\\x0-\x20\x7f\xc2\xa0\xe3\x80\x80]";
            $datetimedata = preg_replace("/\A{$chars}++|{$chars}++\z/u", '', $datetimedata);

            // 和暦を西暦に置換
            $jpnames = array_merge(array_column(JP_ERA, 'name'), array_column(JP_ERA, 'abbr'));
            $datetimedata = preg_replace_callback('/^(' . implode('|', $jpnames) . ')(\d{1,2}|元)/u', function ($matches) {
                [, $era, $year] = $matches;
                $eratime = array_find_first(JP_ERA, function ($v) use ($era) {
                    if (in_array($era, [$v['name'], $v['abbr']], true)) {
                        return $v['since'];
                    }
                }, false);
                return idate('Y', $eratime) + ($year === '元' ? 1 : $year) - 1;
            }, $datetimedata);

            // 単位文字列を置換
            $datetimedata = strtr($datetimedata, [
                '　'    => ' ',
                '西暦' => '',
                '年'   => '/',
                '月'   => '/',
                '日'   => ' ',
                '時'   => ':',
                '分'   => ':',
                '秒'   => '',
            ]);
            $datetimedata = trim($datetimedata, " \t\n\r\0\x0B:/");

            // 1st, 2nd, 3rd, 4th dayname の対応
            $datetimedata = preg_replace_callback('#((\d{1,2})(st|nd|rd|th))(\s+(sun|mon|tues?|wed(nes)?|thu(rs)?|fri|sat(ur)?)day)#u', function ($matches) use ($ORDINAL_WORDS) {
                if (!isset($ORDINAL_WORDS[$matches[1]])) {
                    return $matches[0];
                }

                return $ORDINAL_WORDS[$matches[1]] . $matches[4];
            }, $datetimedata);

            // 1st, 2nd, 3rd, 4th day の対応
            $datetimedata = preg_replace_callback('#((\d{1,2})(st|nd|rd|th))(\s+day)?#ui', function ($matches) use (&$ordinal_day) {
                if ($matches[1] !== (new \NumberFormatter('en', \NumberFormatter::ORDINAL))->format($matches[2])) {
                    return $matches[0];
                }

                $ordinal_day = $matches[2];
                return 'first day';
            }, $datetimedata);

            // odd, even の対応
            $datetimedata = preg_replace_callback('#(odd|even)\s+#ui', function ($matches) use (&$oddeven) {
                $oddeven = $matches[1];
                return 'this ';
            }, $datetimedata);
        }

        // 数値4桁は年と解釈されるように
        if (preg_match('/^[0-9]{4}$/', $datetimedata)) {
            $datetimedata .= '-01-01';
        }

        // 数値系はタイムスタンプとみなす
        if (ctype_digit("$datetimedata")) {
            return (int) $datetimedata;
        }
        if (is_numeric($datetimedata)) {
            return (float) $datetimedata;
        }

        // strtotime と date_parse の合せ技で変換
        $baseTimestamp ??= time();
        $timestamp = strtotime($datetimedata, $baseTimestamp);
        $parts = date_parse($datetimedata);
        if ($timestamp === false || $parts['error_count']) {
            return null;
        }

        if (!checkdate($parts['month'], $parts['day'], $parts['year'])) {
            if (!isset($parts['relative'])) {
                return null;
            }
            $parts['year'] = idate('Y', $baseTimestamp);
            $parts['month'] = idate('m', $baseTimestamp);
            $parts['day'] = idate('d', $baseTimestamp);
        }

        if ($ordinal_day) {
            $timestamp += ($ordinal_day - 1) * $DAY1;
        }

        if ($oddeven !== null) {
            $idateW2 = idate('W', $timestamp) % 2;
            if (($oddeven === 'odd' && $idateW2 === 0) || ($oddeven === 'even' && $idateW2 === 1)) {
                $timestamp += $DAY1 * 7;
            }
        }

        $relative = $parts['relative'] ?? [];
        if (true
            && !isset($relative['weekday'])            // 週指定があるとかなり特殊で初日末日が意味を為さない
            && !isset($relative['first_day_of_month']) // first day 指定があるなら初日確定
            && !isset($relative['last_day_of_month'])  // last day 指定があるなら末日確定
        ) {
            if ($relative['year'] ?? false) {
                $parts['year'] += $relative['year'];
            }
            if ($relative['month'] ?? false) {
                $parts['month'] += $relative['month'];
                $parts['year'] += intdiv($parts['month'], 12);
                $parts['month'] %= 12;
                $parts['month'] += $parts['month'] <= 0 ? 12 : 0;
            }

            if (!checkdate($parts['month'], $parts['day'], $parts['year'])) {
                $timestamp = strtotime(date('Y-m-t H:i:s', $timestamp - $DAY1 * 4));
            }
        }

        if ($parts['fraction']) {
            $timestamp += ($timestamp >= 0 ? +$parts['fraction'] : -$parts['fraction']);
        }
        return $timestamp;
    }
}

assert(!function_exists('ryunosuke\\dbml\\error') || (new \ReflectionFunction('ryunosuke\\dbml\\error'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\error')) {
    /**
     * エラー出力する
     *
     * 第1引数 $message はそれらしく文字列化されて出力される。基本的にはあらゆる型を与えて良い。
     *
     * 第2引数 $destination で出力対象を指定する。省略すると error_log 設定に従う。
     * 文字列を与えるとファイル名とみなし、ファイルに追記される。
     * ファイルを開くが、**ファイルは閉じない**。閉じ処理は php の終了処理に身を任せる。
     * したがって閉じる必要がある場合はファイルポインタを渡す必要がある。
     *
     * @package ryunosuke\Functions\Package\errorfunc
     *
     * @param string|mixed $message 出力メッセージ
     * @param resource|string|mixed $destination 出力先
     * @return int 書き込んだバイト数
     */
    function error($message, $destination = null)
    {
        static $persistences = [];

        $time = date('d-M-Y H:i:s e');
        $content = stringify($message);
        $location = '';
        if (!($message instanceof \Exception || $message instanceof \Throwable)) {
            foreach (debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS) as $trace) {
                if (isset($trace['file'], $trace['line'])) {
                    $location = " in {$trace['file']} on line {$trace['line']}";
                    break;
                }
            }
        }
        $line = "[$time] PHP Log:  $content$location\n";

        if ($destination === null) {
            $destination = blank_if(ini_get('error_log'), 'php://stderr');
        }

        if ($destination === 'syslog') {
            syslog(LOG_INFO, $message);
            return strlen($line);
        }

        if (is_resource($destination)) {
            $fp = $destination;
        }
        elseif (is_string($destination)) {
            if (!isset($persistences[$destination])) {
                $persistences[$destination] = fopen($destination, 'a');
            }
            $fp = $persistences[$destination];
        }

        if (empty($fp)) {
            throw new \InvalidArgumentException('$destination must be resource or string.');
        }

        flock($fp, LOCK_EX);
        fwrite($fp, $line);
        flock($fp, LOCK_UN);

        return strlen($line);
    }
}

assert(!function_exists('ryunosuke\\dbml\\set_error_exception_handler') || (new \ReflectionFunction('ryunosuke\\dbml\\set_error_exception_handler'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\set_error_exception_handler')) {
    /**
     * エラーを ErrorException に変換するハンドラを設定する
     *
     * かなり局所的だが、使用するケースは結構ある。
     * 戻り値として callable を返すので、それを呼べば restore される。
     * あるいは参照が切れれば RAII で restore される。
     *
     * Example:
     * ```php
     * // 呼ぶとエラーが例外に変換されるようになる
     * $restore = set_error_exception_handler();
     * try {
     *     $array = [];
     *     $dummy = $array['undefined'];
     * }
     * catch (\Throwable $t) {
     *     // undefined 例外が飛ぶ
     *     that($t)->isInstanceof(\ErrorException::class);
     * }
     * finally {
     *     // こうするとハンドラが戻る
     *     $restore();
     * }
     * ```
     *
     * @package ryunosuke\Functions\Package\errorfunc
     *
     * @param int $error_levels エラーレベル
     * @param bool $handle_atmark_error エラー抑制時もハンドリングするか
     * @return callable restore するコールバック
     */
    function set_error_exception_handler($error_levels = \E_ALL, $handle_atmark_error = false)
    {
        set_error_handler(static function ($errno, $errstr, $errfile, $errline) use ($handle_atmark_error) {
            if (!$handle_atmark_error && !(error_reporting() & $errno)) {
                return false;
            }
            throw new \ErrorException($errstr, 0, $errno, $errfile, $errline);
        }, $error_levels);

        return finalize('restore_error_handler');
    }
}

assert(!function_exists('ryunosuke\\dbml\\dirname_r') || (new \ReflectionFunction('ryunosuke\\dbml\\dirname_r'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\dirname_r')) {
    /**
     * コールバックが true 相当を返すまで親ディレクトリを辿り続ける
     *
     * コールバックには親ディレクトリが引数として渡ってくる。
     *
     * Example:
     * ```php
     * // //tmp/a/b/file.txt を作っておく
     * $tmp = sys_get_temp_dir();
     * file_set_contents("$tmp/a/b/file.txt", 'hoge');
     * // /a/b/c/d/e/f から開始して「どこかの階層の file.txt を探したい」という状況を想定
     * $callback = fn($path) => realpath("$path/file.txt");
     * that(dirname_r("$tmp/a/b/c/d/e/f", $callback))->isSame(realpath("$tmp/a/b/file.txt"));
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $path パス名
     * @param callable $callback コールバック
     * @return mixed $callback の返り値。頂上まで辿ったら null
     */
    function dirname_r($path, $callback)
    {
        $return = $callback($path);
        if ($return) {
            return $return;
        }

        $dirname = dirname($path);
        if ($dirname === $path) {
            return null;
        }
        return dirname_r($dirname, $callback);
    }
}

assert(!function_exists('ryunosuke\\dbml\\file_get_arrays') || (new \ReflectionFunction('ryunosuke\\dbml\\file_get_arrays'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\file_get_arrays')) {
    /**
     * 指定ファイルを拡張子別に php の配列として読み込む
     *
     * 形式は拡張子で自動判別する。
     * その際、2重拡張子で hoge.sjis.csv のように指定するとそのファイルのエンコーディングを指定したことになる。
     *
     * Example:
     * ```php
     * // csv ファイルを読み込んで配列で返す
     * file_put_contents($csvfile = sys_get_temp_dir() . '/hoge.csv', 'a,b,c
     * 1,2,3
     * 4,5,6
     * 7,8,9
     * ');
     * that(file_get_arrays($csvfile))->isSame([
     *     ['a' => '1', 'b' => '2', 'c' => '3'],
     *     ['a' => '4', 'b' => '5', 'c' => '6'],
     *     ['a' => '7', 'b' => '8', 'c' => '9'],
     * ]);
     *
     * // sjis の json ファイルを読み込んで配列で返す
     * file_put_contents($jsonfile = sys_get_temp_dir() . '/hoge.sjis.json', '[
     * {"a": 1, "b": 2, "c": 3},
     * {"a": 4, "b": 5, "c": 6},
     * {"a": 7, "b": 8, "c": 9}
     * ]');
     * that(file_get_arrays($jsonfile))->isSame([
     *     ['a' => 1, 'b' => 2, 'c' => 3],
     *     ['a' => 4, 'b' => 5, 'c' => 6],
     *     ['a' => 7, 'b' => 8, 'c' => 9],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $filename 読み込むファイル名
     * @param array $options 各種オプション
     * @return array レコード配列
     */
    function file_get_arrays($filename, $options = [])
    {
        static $supported_encodings = null;
        if ($supported_encodings === null) {
            $supported_encodings = array_combine(array_map('strtolower', mb_list_encodings()), mb_list_encodings());
        }

        if (!file_exists($filename)) {
            throw new \InvalidArgumentException("$filename is not exists");
        }

        $internal_encoding = mb_internal_encoding();
        $mb_convert_encoding = function ($encoding, $contents) use ($internal_encoding) {
            if ($encoding !== $internal_encoding) {
                $contents = mb_convert_encoding($contents, $internal_encoding, $encoding);
            }
            return $contents;
        };

        $pathinfo = pathinfo($filename);
        $encoding = pathinfo($pathinfo['filename'], PATHINFO_EXTENSION);
        $encoding = $supported_encodings[strtolower($encoding)] ?? $internal_encoding;
        $extension = $pathinfo['extension'] ?? '';

        switch (strtolower($extension)) {
            default:
                throw new \InvalidArgumentException("ext '$extension' is not supported.");
            case 'php':
                return (array) require $filename;
            case 'csv':
                return (array) csv_import($mb_convert_encoding($encoding, file_get_contents($filename)), $options + ['structure' => true]);
            case 'json':
            case 'json5':
                return (array) json_import($mb_convert_encoding($encoding, file_get_contents($filename)), $options);
            case 'jsonl':
            case 'jsonl5':
                return (array) array_map(fn($json) => json_import($json, $options), $mb_convert_encoding($encoding, array_filter(file($filename, FILE_IGNORE_NEW_LINES), 'strlen')));
            case 'yml':
            case 'yaml':
                return (array) yaml_parse($mb_convert_encoding($encoding, file_get_contents($filename)), 0, $ndocs, $options);
            case 'xml':
                throw new \DomainException("ext '$extension' is supported in the future.");
            case 'ltsv':
                return (array) array_map(fn($ltsv) => ltsv_import($ltsv, $options), $mb_convert_encoding($encoding, array_filter(file($filename, FILE_IGNORE_NEW_LINES), 'strlen')));
        }
    }
}

assert(!function_exists('ryunosuke\\dbml\\file_list') || (new \ReflectionFunction('ryunosuke\\dbml\\file_list'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\file_list')) {
    /**
     * ファイル一覧を配列で返す
     *
     * Example:
     * ```php
     * // 適当にファイルを用意
     * $DS = DIRECTORY_SEPARATOR;
     * $tmp = sys_get_temp_dir() . "{$DS}file_list";
     * rm_rf($tmp, false);
     * file_set_contents("$tmp/a.txt", 'a');
     * file_set_contents("$tmp/dir/b.txt", 'b');
     * file_set_contents("$tmp/dir/dir/c.txt", 'c');
     * // ファイル一覧が取得できる
     * that(file_list($tmp))->equalsCanonicalizing([
     *     "$tmp{$DS}a.txt",
     *     "$tmp{$DS}dir{$DS}b.txt",
     *     "$tmp{$DS}dir{$DS}dir{$DS}c.txt",
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $dirname 調べるディレクトリ名
     * @param array $filter_condition フィルタ条件
     * @return ?array ファイルの配列
     */
    function file_list($dirname, $filter_condition = [])
    {
        $filter_condition += [
            'unixpath' => false,
            '!type'    => 'dir',

            'recursive' => true,
            'relative'  => false,
            'nesting'   => false,
        ];

        $dirname = path_normalize($dirname);

        $subpath = '';
        while (!is_dir($dirname) && str_exists(basename($dirname), ['*', '?', '!', '{', '}', '[', ']'])) {
            $subpath = basename($dirname) . (strlen($subpath) ? '/' : '') . $subpath;
            $dirname = dirname($dirname);
        }

        if (strlen($subpath)) {
            if (strlen($filter_condition['subpath'] ?? '')) {
                throw new \InvalidArgumentException("both subpath and subpattern are specified");
            }
            $filter_condition['subpath'] = $subpath;
            $filter_condition['fnmflag'] = FNM_PATHNAME;
            $filter_condition['unixpath'] = true;
        }

        if (!file_exists($dirname) || $dirname === dirname($dirname)) {
            return null;
        }

        $match = file_matcher($filter_condition);

        $DS = DIRECTORY_SEPARATOR;
        $opt = \FilesystemIterator::SKIP_DOTS | \FilesystemIterator::KEY_AS_PATHNAME | \FilesystemIterator::CURRENT_AS_SELF;

        if ($filter_condition['unixpath']) {
            $DS = '/';
            $opt |= \FilesystemIterator::UNIX_PATHS;
        }

        $rdi = new \RecursiveDirectoryIterator($dirname, $opt);

        if ($filter_condition['recursive']) {
            $iterator = new \RecursiveIteratorIterator($rdi, \RecursiveIteratorIterator::CHILD_FIRST);
        }
        else {
            $iterator = $rdi;
        }

        $result = [];
        foreach ($iterator as $fullpath => $it) {
            if (!$match($it)) {
                continue;
            }

            $path = $filter_condition['relative'] ? $it->getSubPathName() : $fullpath;
            $path = strtr(is_dir($fullpath) ? $path . $DS : $path, [DIRECTORY_SEPARATOR => $DS]);

            if ($filter_condition['nesting']) {
                $tmp = &$result;
                foreach (array_filter(multiexplode(['/', DIRECTORY_SEPARATOR], $it->getSubPath()), 'strlen') as $subdir) {
                    $tmp = &$tmp[$subdir];
                }
                if ($it->isDir()) {
                    $tmp[$it->getFilename()] = $tmp[$it->getFilename()] ?? [];
                }
                else {
                    $tmp[$it->getFilename()] = $path;
                }
            }
            else {
                $result[] = $path;
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\file_matcher') || (new \ReflectionFunction('ryunosuke\\dbml\\file_matcher'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\file_matcher')) {
    /**
     * 各種属性を指定してファイルのマッチングを行うクロージャを返す
     *
     * ※ 内部向け
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param array $filter_condition マッチャーコンディション配列（ソースを参照）
     * @return \Closure ファイルマッチャー
     */
    function file_matcher(array $filter_condition)
    {
        $filter_condition += [
            // common
            'dotfile'    => null,  // switch startWith "."
            'unixpath'   => true,  // convert "\\" -> "/"
            'casefold'   => false, // ignore case
            'fnmflag'    => 0,     // FNM_*
            // by getType (string or [string])
            'type'       => null,
            '!type'      => null,
            // by getPerms (int)
            'perms'      => null,
            '!perms'     => null,
            // by getMTime (int or [int, int])
            'mtime'      => null,
            '!mtime'     => null,
            // by getSize (int or [int, int])
            'size'       => null,
            '!size'      => null,
            // by getPathname (glob or regex)
            'path'       => null,
            '!path'      => null,
            // by getSubPath (glob or regex)
            'subpath'    => null,
            '!subpath'   => null,
            // by getPath or getSubpath (glob or regex)
            'dir'        => null,
            '!dir'       => null,
            // by getFilename (glob or regex)
            'name'       => null,
            '!name'      => null,
            // by getBasename (glob or regex)
            'basename'   => null,
            '!basename'  => null,
            // by getExtension (string or [string])
            'extension'  => null,
            '!extension' => null,
            // by contents (string)
            'contains'   => null,
            '!contains'  => null,
            // by custom condition (callable)
            'filter'     => null,
            '!filter'    => null,
        ];

        foreach ([
            'mtime'  => fn(...$args) => date_timestamp(...$args),
            '!mtime' => fn(...$args) => date_timestamp(...$args),
            'size'   => fn(...$args) => si_unprefix(...$args),
            '!size'  => fn(...$args) => si_unprefix(...$args),
        ] as $key => $map) {
            if (isset($filter_condition[$key])) {
                $range = $filter_condition[$key];
                if (!is_array($range)) {
                    $range = array_fill_keys([0, 1], $range);
                }
                $range = array_map($map, $range);
                $filter_condition[$key] = static function ($value) use ($range) {
                    return (!isset($range[0]) || $value >= $range[0]) && (!isset($range[1]) || $value <= $range[1]);
                };
            }
        }

        foreach ([
            'type'       => null,
            '!type'      => null,
            'extension'  => null,
            '!extension' => null,
        ] as $key => $map) {
            if (isset($filter_condition[$key])) {
                $array = array_flip((array) $filter_condition[$key]);
                if ($filter_condition['casefold']) {
                    $array = array_change_key_case($array, CASE_LOWER);
                }
                $filter_condition[$key] = static function ($value) use ($array) {
                    return isset($array[$value]);
                };
            }
        }

        foreach ([
            'path'      => null,
            '!path'     => null,
            'subpath'   => null,
            '!subpath'  => null,
            'dir'       => null,
            '!dir'      => null,
            'name'      => null,
            '!name'     => null,
            'basename'  => null,
            '!basename' => null,
        ] as $key => $convert) {
            if (isset($filter_condition[$key])) {
                $callback = fn() => false;
                foreach (arrayize($filter_condition[$key]) as $pattern) {
                    preg_match('##', ''); // clear preg_last_error
                    @preg_match($pattern, '');
                    if (preg_last_error() === PREG_NO_ERROR) {
                        $callback = static function ($string) use ($callback, $pattern, $filter_condition) {
                            if ($callback($string)) {
                                return true;
                            }
                            $string = $filter_condition['unixpath'] && DIRECTORY_SEPARATOR === '\\' ? str_replace('\\', '/', $string) : $string;
                            return !!preg_match($pattern, $string);
                        };
                    }
                    else {
                        $callback = static function ($string) use ($callback, $pattern, $filter_condition) {
                            if ($callback($string)) {
                                return true;
                            }
                            if ($filter_condition['unixpath'] && DIRECTORY_SEPARATOR === '\\') {
                                $pattern = str_replace('\\', '/', $pattern);
                                $string = str_replace('\\', '/', $string);
                            }
                            $flags = $filter_condition['fnmflag'];
                            $flags |= $filter_condition['casefold'] ? FNM_CASEFOLD : 0;
                            $flags &= ~((strpos($pattern, '**') !== false) ? FNM_PATHNAME : 0);
                            return fnmatch($pattern, $string, $flags);
                        };
                    }
                }
                $filter_condition[$key] = $callback;
            }
        }

        return function ($file) use ($filter_condition) {
            if (!$file instanceof \SplFileInfo) {
                $file = new \SplFileInfo($file);
            }

            if (isset($filter_condition['dotfile']) && !$filter_condition['dotfile'] === (strpos($file->getFilename(), '.') === 0)) {
                return false;
            }

            foreach (['type' => false, '!type' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && (!file_exists($file->getPathname()) || $cond === $filter_condition[$key]($file->getType()))) {
                    return false;
                }
            }
            foreach (['perms' => false, '!perms' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && (!file_exists($file->getPathname()) || $cond === !!($filter_condition[$key] & $file->getPerms()))) {
                    return false;
                }
            }
            foreach (['mtime' => false, '!mtime' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && (!file_exists($file->getPathname()) || $cond === $filter_condition[$key]($file->getMTime()))) {
                    return false;
                }
            }
            foreach (['size' => false, '!size' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && (!file_exists($file->getPathname()) || $cond === $filter_condition[$key]($file->getSize()))) {
                    return false;
                }
            }
            foreach (['path' => false, '!path' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($file->getPathname())) {
                    return false;
                }
            }
            foreach (['subpath' => false, '!subpath' => true] as $key => $cond) {
                $subpath = $file instanceof \RecursiveDirectoryIterator ? $file->getSubPathname() : $file->getPathname();
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($subpath)) {
                    return false;
                }
            }
            foreach (['dir' => false, '!dir' => true] as $key => $cond) {
                $dirname = $file instanceof \RecursiveDirectoryIterator ? $file->getSubPath() : $file->getPath();
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($dirname)) {
                    return false;
                }
            }
            foreach (['name' => false, '!name' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($file->getFilename())) {
                    return false;
                }
            }
            foreach (['basename' => false, '!basename' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($file->getBasename(concat('.', $file->getExtension())))) {
                    return false;
                }
            }
            foreach (['extension' => false, '!extension' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && $cond === $filter_condition[$key]($file->getExtension())) {
                    return false;
                }
            }
            foreach (['filter' => false, '!filter' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && $cond === !!$filter_condition[$key]($file)) {
                    return false;
                }
            }
            foreach (['contains' => false, '!contains' => true] as $key => $cond) {
                if (isset($filter_condition[$key]) && (!file_exists($file->getPathname()) || $cond === (file_pos($file->getPathname(), $filter_condition[$key]) !== null))) {
                    return false;
                }
            }

            return true;
        };
    }
}

assert(!function_exists('ryunosuke\\dbml\\file_pos') || (new \ReflectionFunction('ryunosuke\\dbml\\file_pos'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\file_pos')) {
    /**
     * 範囲指定でファイルを読んで位置を返す
     *
     * $needle に配列を与えると OR 的動作で一つでも見つかった時点の位置を返す。
     * このとき「どれが見つかったか？」は得られない（場合によっては不便なので将来の改修対象）。
     *
     * Example:
     * ```php
     * // 適当にファイルを用意
     * $testpath = sys_get_temp_dir() . '/file_pos.txt';
     * file_put_contents($testpath, "hoge\nfuga\npiyo\nfuga");
     * // fuga の位置を返す
     * that(file_pos($testpath, 'fuga'))->is(5);
     * // 2つ目の fuga の位置を返す
     * that(file_pos($testpath, 'fuga', 6))->is(15);
     * // 見つからない場合は false を返す
     * that(file_pos($testpath, 'hogera'))->is(null);
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $filename ファイル名
     * @param string|array $needle 探す文字列
     * @param int $start 読み込み位置
     * @param int|null $end 読み込むまでの位置。省略時は指定なし（最後まで）。負数は後ろからのインデックス
     * @param int|null $chunksize 読み込みチャンクサイズ。省略時は 4096 の倍数に正規化
     * @return ?int $needle の位置。見つからなかった場合は null
     */
    function file_pos($filename, $needle, $start = 0, $end = null, $chunksize = null)
    {
        if (!is_file($filename)) {
            throw new \InvalidArgumentException("'$filename' is not found.");
        }

        $needle = arrayval($needle, false);
        $maxlength = max(array_map('strlen', $needle));

        if ($start < 0) {
            $start += $filesize ?? $filesize = filesize($filename);
        }
        if ($end === null) {
            $end = $filesize ?? $filesize = filesize($filename);
        }
        if ($end < 0) {
            $end += $filesize ?? $filesize = filesize($filename);
        }
        if ($chunksize === null) {
            $chunksize = 4096 * ($maxlength % 4096 + 1);
        }

        assert(isset($filesize) || !isset($filesize));
        assert($chunksize >= $maxlength);

        $fp = fopen($filename, 'rb');
        try {
            fseek($fp, $start);
            while (!feof($fp)) {
                if ($start > $end) {
                    break;
                }
                $last = $part ?? '';
                $part = fread($fp, $chunksize);
                if (($p = strpos_array($part, $needle))) {
                    $min = min($p);
                    $result = $start + $min;
                    return $result + strlen($needle[array_flip($p)[$min]]) > $end ? false : $result;
                }
                if (($p = strpos_array($last . $part, $needle))) {
                    $min = min($p);
                    $result = $start + $min - strlen($last);
                    return $result + strlen($needle[array_flip($p)[$min]]) > $end ? false : $result;
                }
                $start += strlen($part);
            }
            return null;
        }
        finally {
            fclose($fp);
        }
    }
}

assert(!function_exists('ryunosuke\\dbml\\file_set_contents') || (new \ReflectionFunction('ryunosuke\\dbml\\file_set_contents'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\file_set_contents')) {
    /**
     * ディレクトリも掘る file_put_contents
     *
     * 書き込みは一時ファイルと rename を使用してアトミックに行われる。
     *
     * Example:
     * ```php
     * file_set_contents(sys_get_temp_dir() . '/not/filename.ext', 'hoge');
     * that(file_get_contents(sys_get_temp_dir() . '/not/filename.ext'))->isSame('hoge');
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $filename 書き込むファイル名
     * @param string $data 書き込む内容
     * @param int $umask ディレクトリを掘る際の umask
     * @return ?int 書き込まれたバイト数
     */
    function file_set_contents($filename, $data, $umask = 0002)
    {
        if (func_num_args() === 2) {
            $umask = umask();
        }

        $filename = path_normalize($filename);

        if (!is_dir($dirname = dirname($filename))) {
            if (!@mkdir_p($dirname, $umask)) {
                throw new \RuntimeException("failed to mkdir($dirname)");
            }
        }

        error_clear_last();
        $tempnam = @tempnam($dirname, 'tmp');
        if (strpos(error_get_last()['message'] ?? '', "file created in the system's temporary directory") !== false) {
            $result = file_put_contents($filename, $data);
            @chmod($filename, 0666 & ~$umask);
            return $result === false ? null : $result;
        }
        if (($result = file_put_contents($tempnam, $data)) !== false) {
            if (rename($tempnam, $filename)) {
                @chmod($filename, 0666 & ~$umask);
                return $result === false ? null : $result;
            }
            unlink($tempnam);
        }
        return null;
    }
}

assert(!function_exists('ryunosuke\\dbml\\fnmatch_or') || (new \ReflectionFunction('ryunosuke\\dbml\\fnmatch_or'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\fnmatch_or')) {
    /**
     * fnmatch の OR 版
     *
     * $patterns のうちどれか一つでもマッチしたら true を返す。
     * $patterns が空だと例外を投げる。
     *
     * Example:
     * ```php
     * // aaa にマッチするので true
     * that(fnmatch_or(['*aaa*', '*bbb*'], 'aaaX'))->isTrue();
     * // どれともマッチしないので false
     * that(fnmatch_or(['*aaa*', '*bbb*'], 'cccX'))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param array|string $patterns パターン配列（単一文字列可）
     * @param string $string 調べる文字列
     * @param int $flags FNM_***
     * @return bool どれかにマッチしたら true
     */
    function fnmatch_or($patterns, $string, $flags = 0)
    {
        $patterns = is_iterable($patterns) ? $patterns : [$patterns];
        if (is_empty($patterns)) {
            throw new \InvalidArgumentException('$patterns must be not empty.');
        }

        foreach ($patterns as $pattern) {
            if (fnmatch($pattern, $string, $flags)) {
                return true;
            }
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\dbml\\mkdir_p') || (new \ReflectionFunction('ryunosuke\\dbml\\mkdir_p'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\mkdir_p')) {
    /**
     * ディレクトリを再帰的に掘る
     *
     * 既に存在する場合は何もしない（エラーも出さない）。
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $dirname ディレクトリ名
     * @param int $umask ディレクトリを掘る際の umask
     * @return bool 作成したら true
     */
    function mkdir_p($dirname, $umask = 0002)
    {
        if (func_num_args() === 1) {
            $umask = umask();
        }

        if (file_exists($dirname)) {
            return false;
        }

        return mkdir($dirname, 0777 & (~$umask), true);
    }
}

assert(!function_exists('ryunosuke\\dbml\\path_is_absolute') || (new \ReflectionFunction('ryunosuke\\dbml\\path_is_absolute'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\path_is_absolute')) {
    /**
     * パスが絶対パスか判定する
     *
     * Example:
     * ```php
     * that(path_is_absolute('/absolute/path'))->isTrue();
     * that(path_is_absolute('relative/path'))->isFalse();
     * // Windows 環境では下記も true になる
     * if (DIRECTORY_SEPARATOR === '\\') {
     *     that(path_is_absolute('\\absolute\\path'))->isTrue();
     *     that(path_is_absolute('C:\\absolute\\path'))->isTrue();
     * }
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $path パス文字列
     * @return bool 絶対パスなら true
     */
    function path_is_absolute($path)
    {
        // スキームが付いている場合は path 部分で判定
        $parts = parse_url($path);
        if (isset($parts['scheme'], $parts['path'])) {
            $path = $parts['path'];
        }
        elseif (isset($parts['scheme'], $parts['host'])) {
            $path = $parts['host'];
        }

        if (substr($path, 0, 1) === '/') {
            return true;
        }

        if (DIRECTORY_SEPARATOR === '\\') {
            if (preg_match('#^([a-z]+:(\\\\|/|$)|\\\\)#i', $path) !== 0) {
                return true;
            }
        }

        return false;
    }
}

assert(!function_exists('ryunosuke\\dbml\\path_normalize') || (new \ReflectionFunction('ryunosuke\\dbml\\path_normalize'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\path_normalize')) {
    /**
     * パスを正規化する
     *
     * 具体的には ./ や ../ を取り除いたり連続したディレクトリ区切りをまとめたりする。
     * realpath ではない。のでシンボリックリンクの解決などはしない。その代わりファイルが存在しなくても使用することができる。
     *
     * Example:
     * ```php
     * $DS = DIRECTORY_SEPARATOR;
     * that(path_normalize('/path/to/something'))->isSame("{$DS}path{$DS}to{$DS}something");
     * that(path_normalize('/path/through/../something'))->isSame("{$DS}path{$DS}something");
     * that(path_normalize('./path/current/./through/../something'))->isSame("path{$DS}current{$DS}something");
     * ```
     *
     * @package ryunosuke\Functions\Package\filesystem
     *
     * @param string $path パス文字列
     * @return string 正規化されたパス
     */
    function path_normalize($path)
    {
        $DS = DIRECTORY_SEPARATOR;

        // スキームの保護
        $with_scheme = false;
        $scheme = parse_url($path, PHP_URL_SCHEME);
        if (!($scheme === null || $scheme === 'file') && substr($path, strlen($scheme), 3) === '://') {
            $path = substr($path, strlen($scheme) + 3);
            $DS = '/';
            $with_scheme = true;
        }

        $delimiter = '/';
        if ($DS === '\\') {
            $delimiter .= '\\\\';
        }

        $result = [];
        foreach (preg_split("#[$delimiter]+#u", $path) as $part) {
            if ($part === '.') {
                continue;
            }
            if ($part === '..') {
                if (empty($result)) {
                    throw new \InvalidArgumentException("'$path' is invalid as path string.");
                }
                array_pop($result);
                continue;
            }
            $result[] = $part;
        }
        if (count($result) > 2 && $result[count($result) - 1] === '') {
            array_pop($result);
        }

        $path = implode($DS, $result);

        if ($with_scheme) {
            $path = "$scheme://$path";
        }

        return $path;
    }
}

assert(!function_exists('ryunosuke\\dbml\\func_user_func_array') || (new \ReflectionFunction('ryunosuke\\dbml\\func_user_func_array'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\func_user_func_array')) {
    /**
     * パラメータ定義数に応じて呼び出し引数を可変にしてコールする
     *
     * デフォルト引数はカウントされない。必須パラメータの数で呼び出す。
     *
     * $callback に null を与えると例外的に「第1引数を返すクロージャ」を返す。
     *
     * php の標準関数は定義数より多い引数を投げるとエラーを出すのでそれを抑制したい場合に使う。
     *
     * Example:
     * ```php
     * // strlen に2つの引数を渡してもエラーにならない
     * $strlen = func_user_func_array('strlen');
     * that($strlen('abc', null))->isSame(3);
     * ```
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param callable|null $callback 呼び出すクロージャ
     * @return callable 引数ぴったりで呼び出すクロージャ
     */
    function func_user_func_array($callback)
    {
        // null は第1引数を返す特殊仕様
        if ($callback === null) {
            return fn($v) => $v;
        }
        // クロージャはユーザ定義しかありえないので調べる必要がない
        if ($callback instanceof \Closure) {
            // と思ったが、\Closure::fromCallable で作成されたクロージャは内部属性が伝播されるようなので除外
            if (reflect_callable($callback)->isUserDefined()) {
                return $callback;
            }
        }

        // 上記以外は「引数ぴったりで削ぎ落としてコールするクロージャ」を返す
        $plength = parameter_length($callback, true, true);
        return function (...$args) use ($callback, $plength) {
            if (is_infinite($plength)) {
                return $callback(...$args);
            }
            return $callback(...array_slice($args, 0, $plength));
        };
    }
}

assert(!function_exists('ryunosuke\\dbml\\is_bindable_closure') || (new \ReflectionFunction('ryunosuke\\dbml\\is_bindable_closure'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\is_bindable_closure')) {
    /**
     * $this を bind 可能なクロージャか調べる
     *
     * Example:
     * ```php
     * that(is_bindable_closure(function () {}))->isTrue();
     * that(is_bindable_closure(static function () {}))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param \Closure $closure 調べるクロージャ
     * @return bool $this を bind 可能なクロージャなら true
     */
    function is_bindable_closure(\Closure $closure)
    {
        return !!@$closure->bindTo(new \stdClass());
    }
}

assert(!function_exists('ryunosuke\\dbml\\is_callback') || (new \ReflectionFunction('ryunosuke\\dbml\\is_callback'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\is_callback')) {
    /**
     * callable のうち、関数文字列を false で返す
     *
     * 歴史的な経緯で php の callable は多岐に渡る。
     *
     * 1. 単純なコールバック: `"strtolower"`
     * 2. staticメソッドのコール: `["ClassName", "method"]`
     * 3. オブジェクトメソッドのコール: `[$object, "method"]`
     * 4. staticメソッドのコール: `"ClassName::method"`
     * 5. 相対指定によるstaticメソッドのコール: `["ClassName", "parent::method"]`
     * 6. __invoke実装オブジェクト: `$object`
     * 7. クロージャ: `fn() => something()`
     *
     * 上記のうち 1 を callable とはみなさず false を返す。
     * 現代的には `Closure::fromCallable`, `$object->method(...)` などで callable == Closure という概念が浸透しているが、そうでないこともある。
     * 本ライブラリでも `preg_splice` や `array_sprintf` などで頻出しているので関数として定義する。
     *
     * 副作用はなく、クラスのロードや関数の存在チェックなどは行わない。あくまで型と形式で判定する。
     * 引数は callable でなくても構わない。その場合単に false を返す。
     *
     * @package ryunosuke\Functions\Package\funchand
     *
     * @param mixed $callable 対象 callable
     * @return bool 関数呼び出しの callable なら false
     */
    function is_callback($callable)
    {
        // 大前提（不要に思えるが invoke や配列 [1, 2, 3] などを考慮すると必要）
        if (!is_callable($callable, true)) {
            return false;
        }

        // 変なオブジェクト・配列は↑で除かれている
        if (is_object($callable) || is_array($callable)) {
            return true;
        }

        // 文字列で :: を含んだら関数呼び出しではない
        if (is_string($callable) && strpos($callable, '::') !== false) {
            return true;
        }

        return false;
    }
}

assert(!function_exists('ryunosuke\\dbml\\finalize') || (new \ReflectionFunction('ryunosuke\\dbml\\finalize'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\finalize')) {
    /**
     * 自身が死ぬときに指定 callable を呼ぶオブジェクトを返す
     *
     * invoke を実装しているので明示的にも呼べる。
     * 明示的だろうと暗黙的だろうと必ず1回しか呼ばれない。
     *
     * Example:
     * ```php
     * $called = 0;
     * $finalizer = finalize(function()use(&$called){$called++;});
     * that($called)->is(0); // まだ呼ばれていない
     *
     * // コールすると・・・
     * $finalizer();
     * that($called)->is(1); // 呼ばれている
     *
     * // unset（GC）でも呼ばれる
     * unset($finalizer);
     * that($called)->is(1); // が、一度しか呼ばれないので呼ばれない
     * ```
     *
     * @package ryunosuke\Functions\Package\info
     *
     * @param callable $finalizer 実行する php コード
     * @return callable GC 時に $finalizer を実行する callable
     */
    function finalize(callable $finalizer)
    {
        return new class($finalizer) {
            public function __construct(private $finalizer) { }

            public function __destruct() { $this->__invoke(); }

            public function __invoke()
            {
                if (isset($this->finalizer)) {
                    ($this->finalizer)();
                    unset($this->finalizer);
                    gc_collect_cycles();
                }
            }
        };
    }
}

assert(!function_exists('ryunosuke\\dbml\\iterator_chunk') || (new \ReflectionFunction('ryunosuke\\dbml\\iterator_chunk'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\iterator_chunk')) {
    /**
     * イテレータも使える array_chunk
     *
     * Generator を返す Generator を返す。
     * foreach で使う分には普通の配列と遜色なく使うことができる。
     *
     * 大本 Generator は return 値として総数を返す。
     * 各種 Generator は return 値として要素数を返す。
     *
     * Example:
     * ```php
     * // 要素7の Generator を3つに分割
     * $generator = (function () {
     *     yield 'a';
     *     yield 'b';
     *     yield 'c';
     *     yield 'd';
     *     yield 'e';
     *     yield 'f';
     *     yield 'g';
     * })();
     * $generators = iterator_chunk($generator, 3);
     *
     * // 3要素
     * that(iterator_to_array($generators->current()))->is(['a', 'b', 'c']);
     * that($generators->current()->getReturn())->is(3);
     * // 3要素
     * $generators->next();
     * that(iterator_to_array($generators->current()))->is(['d', 'e', 'f']);
     * that($generators->current()->getReturn())->is(3);
     * // 1要素
     * $generators->next();
     * that(iterator_to_array($generators->current()))->is(['g']);
     * that($generators->current()->getReturn())->is(1);
     * // 大本の Generator は総数を返す
     * $generators->next();
     * that($generators->getReturn())->is(7);
     *
     * // ハイフンが来るたびに分割（クロージャ内で next しているため、ハイフン自体は結果に含まれない）
     * $generator = (function () {
     *     yield 'a';
     *     yield 'b';
     *     yield '-';
     *     yield 'c';
     *     yield 'd';
     *     yield 'e';
     *     yield 'f';
     *     yield '-';
     *     yield 'g';
     * })();
     * $generators = iterator_chunk($generator, function ($v, $k, $n, $c, $it) {
     *     if ($v === '-') {
     *         $it->next();
     *         return false;
     *     }
     *     return true;
     * });
     *
     * that(iterator_to_array($generators->current()))->is(['a', 'b']);
     * $generators->next();
     * that(iterator_to_array($generators->current()))->is(['c', 'd', 'e', 'f']);
     * $generators->next();
     * that(iterator_to_array($generators->current()))->is(['g']);
     * ```
     *
     * @package ryunosuke\Functions\Package\iterator
     *
     * @param iterable $iterator イテレータ
     * @param int|\Closure $length チャンクサイズ。クロージャを渡すと毎ループ(値, キー, ステップ, チャンク番号, イテレータ)でコールされて false を返すと1チャンク終了となる
     * @param bool $preserve_keys キーの保存フラグ
     * @return \Generator[]|\Generator チャンク化された Generator
     */
    function iterator_chunk($iterator, $length, $preserve_keys = false)
    {
        if (!$length instanceof \Closure) {
            if ($length <= 0) {
                throw new \InvalidArgumentException("\$length must be > 0 ($length)");
            }
            $length = fn($v, $k, $n, $chunk, $iterator) => $n < $length;
        }

        // Generator は Iterator であるが Iterator は Generator ではないので変換する
        if (is_iterable($iterator)) {
            /** @var \Iterator $iterator */
            $iterator = (fn() => yield from $iterator)();
        }

        $chunk = 0;
        $total = 0;
        while ($iterator->valid()) {
            yield $g = (function () use ($iterator, $length, $preserve_keys, $chunk) {
                $n = 0;
                while ($iterator->valid()) {
                    $k = $iterator->key();
                    $v = $iterator->current();

                    if (!$length($v, $k, $n, $chunk, $iterator)) {
                        break;
                    }

                    if ($preserve_keys) {
                        yield $k => $v;
                    }
                    else {
                        yield $v;
                    }

                    $n++;
                    $iterator->next();
                }
                return $n;
            })();
            $chunk++;

            // 回しきらないと無限ループする
            while ($g->valid()) {
                $g->next();
            }
            $total += $g->getReturn();
        }

        return $total;
    }
}

assert(!function_exists('ryunosuke\\dbml\\median') || (new \ReflectionFunction('ryunosuke\\dbml\\median'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\median')) {
    /**
     * 引数の中央値を返す
     *
     * - 要素数が奇数の場合は完全な中央値/偶数の場合は中2つの平均。「平均」という概念が存在しない値なら中2つの後の値
     * - 配列は個数ではなくフラット展開した要素を対象にする
     * - 候補がない場合はエラーではなく例外を投げる
     *
     * Example:
     * ```php
     * // 偶数個なので中2つの平均
     * that(median(1, 2, 3, 4, 5, 6))->isSame(3.5);
     * // 奇数個なのでど真ん中
     * that(median(1, 2, 3, 4, 5))->isSame(3);
     * // 偶数個だが文字列なので中2つの後
     * that(median('a', 'b', 'c', 'd'))->isSame('c');
     * ```
     *
     * @package ryunosuke\Functions\Package\math
     *
     * @param mixed ...$variadic 対象の変数・配列・リスト
     * @return mixed 中央値
     */
    function median(...$variadic)
    {
        $args = array_flatten($variadic) or throw new \LengthException("argument's length is 0.");
        $count = count($args);
        $center = (int) ($count / 2);
        sort($args);
        // 偶数で共に数値なら平均値
        if ($count % 2 === 0 && (is_numeric($args[$center - 1]) && is_numeric($args[$center]))) {
            return ($args[$center - 1] + $args[$center]) / 2;
        }
        // 奇数なら単純に中央値
        else {
            return $args[$center];
        }
    }
}

assert(!function_exists('ryunosuke\\dbml\\sum') || (new \ReflectionFunction('ryunosuke\\dbml\\sum'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\sum')) {
    /**
     * 引数の合計値を返す
     *
     * - is_numeric でない値は除外される（計算結果に影響しない）
     * - 配列は個数ではなくフラット展開した要素を対象にする
     * - 候補がない場合はエラーではなく例外を投げる
     *
     * Example:
     * ```php
     * that(sum(1, 2, 3, 4, 5, 6))->isSame(21);
     * ```
     *
     * @package ryunosuke\Functions\Package\math
     *
     * @param mixed ...$variadic 対象の変数・配列・リスト
     * @return mixed 合計値
     */
    function sum(...$variadic)
    {
        $args = array_flatten($variadic) or throw new \LengthException("argument's length is 0.");
        $args = array_filter($args, 'is_numeric') or throw new \LengthException("argument's must be contain munber.");
        return array_sum($args);
    }
}

assert(!function_exists('ryunosuke\\dbml\\evaluate') || (new \ReflectionFunction('ryunosuke\\dbml\\evaluate'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\evaluate')) {
    /**
     * eval のプロキシ関数
     *
     * 一度ファイルに吐いてから require した方が opcache が効くので抜群に速い。
     * また、素の eval は ParseError が起こったときの表示がわかりにくすぎるので少し見やすくしてある。
     *
     * 関数化してる以上 eval におけるコンテキストの引き継ぎはできない。
     *  ただし、引数で変数配列を渡せるようにしてあるので get_defined_vars を併用すれば基本的には同じ。
     * コンテキストに $this がある場合は bind して疑似的に模倣する。
     *
     * Example:
     * ```php
     * $a = 1;
     * $b = 2;
     * $phpcode = ';
     * $c = $a + $b;
     * return $c * 3;
     * ';
     * that(evaluate($phpcode, get_defined_vars()))->isSame(9);
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $phpcode 実行する php コード
     * @param array $contextvars コンテキスト変数配列
     * @return mixed eval の return 値
     */
    function evaluate($phpcode, $contextvars = [])
    {
        $cachefile = function_configure('storagedir') . '/' . rawurlencode(__FUNCTION__) . '-' . sha1($phpcode) . '.php';
        if (!file_exists($cachefile)) {
            file_put_contents($cachefile, "<?php $phpcode", LOCK_EX);
        }

        try {
            $evaler = function () {
                // extract は数値キーをそのまま展開できない
                // しかし "${0}" のような記法で数値変数を利用することはできる（可変変数限定だし php8.2 で非推奨になったが）
                // 要するに数値キーのみをローカルコンテキストに展開しないと完全な eval の代替にならない
                if (func_get_arg(1)) {
                    foreach (func_get_arg(1) as $k => $v) {
                        $$k = $v;
                    }
                    // 現スコープで宣言してしまっているので伏せなければならない
                    unset($k, $v);
                }
                extract(func_get_arg(1));
                return require func_get_arg(0);
            };

            // $this を模倣する
            if (isset($contextvars['this'])) {
                assert(is_object($contextvars['this']));
                $evaler = $evaler->bindTo($contextvars['this'], get_class($contextvars['this']));
                unset($contextvars['this']);
            }

            /** @noinspection PhpMethodParametersCountMismatchInspection */
            return $evaler($cachefile, $contextvars);
        }
        catch (\ParseError $ex) {
            $errline = $ex->getLine();
            $errline_1 = $errline - 1;
            $codes = preg_split('#\\R#u', $phpcode);
            $codes[$errline_1] = '>>> ' . $codes[$errline_1];

            $N = 5; // 前後の行数
            $message = $ex->getMessage();
            $message .= "\n" . implode("\n", array_slice($codes, max(0, $errline_1 - $N), $N * 2 + 1));
            $message .= "\n in " . realpath($cachefile) . " on line " . $errline . "\n";
            throw new \ParseError($message, $ex->getCode(), $ex);
        }
    }
}

assert(!function_exists('ryunosuke\\dbml\\namespace_parse') || (new \ReflectionFunction('ryunosuke\\dbml\\namespace_parse'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\namespace_parse')) {
    /**
     * php ファイルをパースして名前空間配列を返す
     *
     * ファイル内で use/use const/use function していたり、シンボルを定義していたりする箇所を検出して名前空間単位で返す。
     * クラスコンテキストでの解決できないシンボルはその名前空間として返す。
     * つまり、 use せずに いきなり new Hoge() などとしてもその同一名前空間の Hoge として返す。
     * これは同一名前空間であれば use せずとも使用できる php の仕様に合わせるため。
     * 対象はクラスのみであり、定数・関数は対象外。
     * use せずに hoge_function() などとしても、それが同一名前空間なのかグローバルにフォールバックされるのかは静的には決して分からないため。
     *
     * その他、#[AttributeName]や ClassName::class など、おおよそクラス名が必要とされるコンテキストでのシンボルは全て返される。
     *
     * Example:
     * ```php
     * // このような php ファイルをパースすると・・・
     * file_set_contents(sys_get_temp_dir() . '/namespace.php', '
     * <?php
     * namespace NS1;
     * use ArrayObject as AO;
     * use function strlen as SL;
     * function InnerFunc(){}
     * class InnerClass{}
     * define("OUTER\\\\CONST", "OuterConst");
     *
     * namespace NS2;
     * use RuntimeException as RE;
     * use const COUNT_RECURSIVE as CR;
     * class InnerClass{}
     * const InnerConst = 123;
     *
     * // いきなり Hoge を new してみる
     * new Hoge();
     * ');
     * // このような名前空間配列が得られる
     * that(namespace_parse(sys_get_temp_dir() . '/namespace.php'))->isSame([
     *     'NS1' => [
     *         'const'    => [],
     *         'function' => [
     *             'SL'        => 'strlen',
     *             'InnerFunc' => 'NS1\\InnerFunc',
     *         ],
     *         'alias'    => [
     *             'AO'         => 'ArrayObject',
     *             'InnerClass' => 'NS1\\InnerClass',
     *         ],
     *     ],
     *     'OUTER' => [
     *         'const'    => [
     *             'CONST' => 'OUTER\\CONST',
     *         ],
     *         'function' => [],
     *         'alias'    => [],
     *     ],
     *     'NS2' => [
     *         'const'    => [
     *             'CR'         => 'COUNT_RECURSIVE',
     *             'InnerConst' => 'NS2\\InnerConst',
     *         ],
     *         'function' => [],
     *         'alias'    => [
     *             'RE'         => 'RuntimeException',
     *             'InnerClass' => 'NS2\\InnerClass',
     *             'Hoge'       => 'NS2\\Hoge', // 同一名前空間として返される
     *         ],
     *     ],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $filename ファイル名
     * @param array $options オプション配列
     * @return array 名前空間配列
     */
    function namespace_parse($filename, $options = [])
    {
        $filename = realpath($filename);
        $filemtime = filemtime($filename);
        $options += [
            'cache' => null,
        ];

        $storage = json_storage(__FUNCTION__);

        $storage['mtime'] ??= $filemtime;
        $options['cache'] ??= $storage['mtime'] >= $filemtime;
        if (!$options['cache']) {
            unset($storage['mtime']);
            unset($storage[$filename]);
        }
        return $storage[$filename] ??= (function () use ($filename) {
            $namespace = '';
            $classend = null;

            $tokens = php_tokens(file_get_contents($filename));
            $token = $tokens[0];

            $T_ENUM = defined('T_ENUM') ? T_ENUM : -1; // for compatible
            $result = [];
            while (true) {
                $token = $token->next(["define", T_NAMESPACE, T_USE, T_CONST, T_FUNCTION, T_CLASS, T_INTERFACE, T_TRAIT, $T_ENUM, T_EXTENDS, T_IMPLEMENTS, T_ATTRIBUTE, T_NAME_QUALIFIED, T_STRING]);
                if ($token === null) {
                    break;
                }
                if ($classend !== null && $token->index >= $classend) {
                    $classend = null;
                }

                // define は現在の名前空間とは無関係に名前空間定数を宣言することができる
                if ($token->is(T_STRING) && $token->is("define")) {
                    // ただし実行されないと定義されないので class 内は無視
                    if ($classend !== null) {
                        continue;
                    }

                    // しかも変数が使えたりして静的には決まらないので "" or '' のみとする
                    $token = $token->next([T_CONSTANT_ENCAPSED_STRING, ',']);
                    if ($token->is(T_CONSTANT_ENCAPSED_STRING)) {
                        $define = trim(stripslashes(substr($token, 1, -1)), '\\');
                        [$ns, $nm] = namespace_split($define);
                        $result[$ns] ??= [
                            'const'    => [],
                            'function' => [],
                            'alias'    => [],
                        ];
                        $result[$ns]['const'][$nm] = $define;
                    }
                }
                // 識別子。多岐に渡るので文脈を見て無視しなければならない
                if ($token->is(T_STRING)) {
                    if ($token->prev()->is([
                        T_OBJECT_OPERATOR,          // $object->member
                        T_NULLSAFE_OBJECT_OPERATOR, // $object?->member
                        T_CONST,                    // const CONST = 'dummy'
                        T_GOTO,                     // goto LABEL
                    ])) {
                        continue;
                    }
                    // hoge_function(named: $argument)
                    if ($token->next()->is(':')) {
                        continue;
                    }
                    // hoge_function()
                    if (!$token->prev()->is(T_NEW) && $token->next()->is('(')) {
                        continue;
                    }
                    if ($token->is([
                        // typehint
                        ...['never', 'void', 'null', 'false', 'true', 'bool', 'int', 'float', 'string', 'object', 'iterable', 'mixed'],
                        // specials
                        ...['self', 'static', 'parent'],
                    ])) {
                        continue;
                    }
                    if (defined($token->text)) {
                        continue;
                    }

                    if (false
                        || $token->prev()->is(T_NEW)           // new ClassName
                        || $token->prev()->is(':')             // function method(): ClassName
                        || $token->next()->is(T_VARIABLE)      // ClassName $argument
                        || $token->next()->is(T_DOUBLE_COLON)  // ClassName::CONSTANT
                    ) {
                        $result[$namespace]['alias'][$token->text] ??= concat($namespace, '\\') . $token->text;
                    }
                }
                // T_STRING とほぼ同じ（修飾版）。T_NAME_QUALIFIED である時点で Space\Name であることはほぼ確定だがいくつか除外するものがある
                if ($token->is(T_NAME_QUALIFIED)) {
                    // hoge_function()
                    if (!$token->prev()->is(T_NEW) && $token->next()->is('(')) {
                        continue;
                    }
                    // 最近の php は標準でも名前空間を持つものがあるので除外しておく
                    if (defined($token->text)) {
                        continue;
                    }
                    $result[$namespace]['alias'][$token->text] ??= concat($namespace, '\\') . $token->text;
                }
                if ($token->is(T_NAMESPACE)) {
                    $token = $token->next();
                    $namespace = $token->text;
                    $result[$namespace] = [
                        'const'    => [],
                        'function' => [],
                        'alias'    => [],
                    ];
                }
                if ($token->is(T_USE)) {
                    // function () **use** ($var) {...}
                    if ($token->prev()?->is(')')) {
                        continue;
                    }
                    // class {**use** Trait;}
                    if ($classend !== null) {
                        while (!$token->is(['{', ';'])) {
                            $token = $token->next(['{', ';', ',']);
                            if (!$token->prev()->is(T_NAME_FULLY_QUALIFIED)) {
                                $result[$namespace]['alias'][$token->prev()->text] ??= concat($namespace, '\\') . $token->prev()->text;
                            }
                        }
                        continue;
                    }

                    $next = $token->next();
                    $key = 'alias';
                    if ($next->is(T_CONST)) {
                        $key = 'const';
                        $token = $next;
                    }
                    if ($next->is(T_FUNCTION)) {
                        $key = 'function';
                        $token = $next;
                    }

                    $token = $token->next();
                    $qualified = trim($token->text, '\\');

                    $next = $token->next();
                    if ($next->is(T_NS_SEPARATOR)) {
                        while (!$token->is('}')) {
                            $token = $token->next(['}', ',', T_AS]);
                            if ($token->is(T_AS)) {
                                $qualified2 = $qualified . "\\" . $token->prev()->text;
                                $result[$namespace][$key][$token->next()->text] = $qualified2;
                                $token = $token->next()->next();
                            }
                            else {
                                $qualified2 = $qualified . "\\" . $token->prev()->text;
                                $result[$namespace][$key][namespace_split($qualified2)[1]] = $qualified2;
                            }
                        }
                    }
                    elseif ($next->is(T_AS)) {
                        $token = $next->next();
                        $result[$namespace][$key][$token->text] = $qualified;
                    }
                    else {
                        $result[$namespace][$key][namespace_split($qualified)[1]] = $qualified;
                    }
                }
                if ($token->is([T_CLASS, T_TRAIT, T_INTERFACE, $T_ENUM])) {
                    // class ClassName {...}, $anonymous = new class() {...}
                    if ($token->next()->is(T_STRING) || $token->prev()->is(T_NEW) || $token->prev(T_ATTRIBUTE)?->prev()->is(T_NEW)) {
                        // new class {}, new class(new class {}) {}
                        $next = $token->next(['{', '(']);
                        if ($next->is('(')) {
                            $next = $next->end()->next('{');
                        }
                        $classend = max($classend ?? -1, $next->end()->index);
                    }
                    // class ClassName
                    if ($token->next()->is(T_STRING)) {
                        $result[$namespace]['alias'][$token->next()->text] = concat($namespace, '\\') . $token->next()->text;
                    }
                }
                if ($token->is(T_EXTENDS)) {
                    while (!$token->is([T_IMPLEMENTS, '{'])) {
                        $token = $token->next([T_IMPLEMENTS, '{', ',']);
                        if (!$token->prev()->is(T_NAME_FULLY_QUALIFIED)) {
                            $result[$namespace]['alias'][$token->prev()->text] ??= concat($namespace, '\\') . $token->prev()->text;
                        }
                    }
                }
                if ($token->is(T_IMPLEMENTS)) {
                    while (!$token->is(['{'])) {
                        $token = $token->next(['{', ',']);
                        if (!$token->prev()->is(T_NAME_FULLY_QUALIFIED)) {
                            $result[$namespace]['alias'][$token->prev()->text] ??= concat($namespace, '\\') . $token->prev()->text;
                        }
                    }
                }
                if ($token->is(T_CONST)) {
                    // class {**const** HOGE=1;}
                    if ($classend !== null) {
                        continue;
                    }
                    $result[$namespace]['const'][$token->next()->text] ??= concat($namespace, '\\') . $token->next()->text;
                }
                if ($token->is(T_FUNCTION)) {
                    // class {**function** hoge() {}}
                    if ($classend !== null) {
                        continue;
                    }
                    // $closure = function () {};
                    if ($token->next()->is('(')) {
                        continue;
                    }
                    $result[$namespace]['function'][$token->next()->text] ??= concat($namespace, '\\') . $token->next()->text;
                }
                if ($token->is(T_ATTRIBUTE)) {
                    $token = $token->next([T_NAME_FULLY_QUALIFIED, T_NAME_QUALIFIED, T_STRING]);
                    if (!$token->is(T_NAME_FULLY_QUALIFIED)) {
                        $result[$namespace]['alias'][$token->text] ??= concat($namespace, '\\') . $token->text;
                    }
                }
            }

            return $result;
        })();
    }
}

assert(!function_exists('ryunosuke\\dbml\\namespace_resolve') || (new \ReflectionFunction('ryunosuke\\dbml\\namespace_resolve'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\namespace_resolve')) {
    /**
     * エイリアス名を完全修飾名に解決する
     *
     * 例えばあるファイルのある名前空間で `use Hoge\Fuga\Piyo;` してるときの `Piyo` を `Hoge\Fuga\Piyo` に解決する。
     *
     * Example:
     * ```php
     * // このような php ファイルがあるとして・・・
     * file_set_contents(sys_get_temp_dir() . '/symbol.php', '
     * <?php
     * namespace vendor\NS;
     *
     * use ArrayObject as AO;
     * use function strlen as SL;
     *
     * function InnerFunc(){}
     * class InnerClass{}
     * ');
     * // 下記のように解決される
     * that(namespace_resolve('AO', sys_get_temp_dir() . '/symbol.php'))->isSame('ArrayObject');
     * that(namespace_resolve('SL', sys_get_temp_dir() . '/symbol.php'))->isSame('strlen');
     * that(namespace_resolve('InnerFunc', sys_get_temp_dir() . '/symbol.php'))->isSame('vendor\\NS\\InnerFunc');
     * that(namespace_resolve('InnerClass', sys_get_temp_dir() . '/symbol.php'))->isSame('vendor\\NS\\InnerClass');
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $shortname エイリアス名
     * @param string|array $nsfiles ファイル名 or [ファイル名 => 名前空間名]
     * @param array $targets エイリアスタイプ（'const', 'function', 'alias' のいずれか）
     * @return string|null 完全修飾名。解決できなかった場合は null
     */
    function namespace_resolve(string $shortname, $nsfiles, $targets = ['const', 'function', 'alias'])
    {
        // 既に完全修飾されている場合は何もしない
        if (($shortname[0] ?? null) === '\\') {
            return $shortname;
        }

        // use Inner\Space のような名前空間の use の場合を考慮する
        $parts = explode('\\', $shortname, 2);
        $prefix = isset($parts[1]) ? array_shift($parts) : null;

        if (is_string($nsfiles)) {
            $nsfiles = [$nsfiles => []];
        }

        $targets = (array) $targets;
        foreach ($nsfiles as $filename => $namespaces) {
            $namespaces = array_flip(array_map(fn($n) => trim($n, '\\'), (array) $namespaces));
            foreach (namespace_parse($filename) as $namespace => $ns) {
                /** @noinspection PhpIllegalArrayKeyTypeInspection */
                if (!$namespaces || isset($namespaces[$namespace])) {
                    if (isset($ns['alias'][$prefix])) {
                        return $ns['alias'][$prefix] . '\\' . implode('\\', $parts);
                    }
                    foreach ($targets as $target) {
                        if (isset($ns[$target][$shortname])) {
                            return $ns[$target][$shortname];
                        }
                    }
                }
            }
        }
        return null;
    }
}

assert(!function_exists('ryunosuke\\dbml\\php_indent') || (new \ReflectionFunction('ryunosuke\\dbml\\php_indent'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\php_indent')) {
    /**
     * php のコードのインデントを調整する
     *
     * baseline で基準インデント位置を指定する。
     * その基準インデントを削除した後、指定したインデントレベルでインデントするようなイメージ。
     *
     * Example:
     * ```php
     * $phpcode = '
     *     echo 123;
     *
     *     if (true) {
     *         echo 456;
     *     }
     * ';
     * // 数値指定は空白換算
     * that(php_indent($phpcode, 8))->isSame('
     *         echo 123;
     *
     *         if (true) {
     *             echo 456;
     *         }
     * ');
     * // 文字列を指定すればそれが使用される
     * that(php_indent($phpcode, "  "))->isSame('
     *   echo 123;
     *
     *   if (true) {
     *       echo 456;
     *   }
     * ');
     * // オプション指定
     * that(php_indent($phpcode, [
     *     'baseline'  => 1,    // 基準インデントの行番号（負数で下からの指定になる）
     *     'indent'    => 4,    // インデント指定（上記の数値・文字列指定はこれの糖衣構文）
     *     'trimempty' => true, // 空行を trim するか
     *     'heredoc'   => true, // Flexible Heredoc もインデントするか
     * ]))->isSame('
     *     echo 123;
     *
     *     if (true) {
     *         echo 456;
     *     }
     * ');
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @param string $phpcode インデントする php コード
     * @param array|int|string $options オプション
     * @return string インデントされた php コード
     */
    function php_indent($phpcode, $options = [])
    {
        if (!is_array($options)) {
            $options = ['indent' => $options];
        }
        $options += [
            'baseline'  => 1,
            'indent'    => 0,
            'trimempty' => true,
            'heredoc'   => true,
        ];
        if (is_int($options['indent'])) {
            $options['indent'] = str_repeat(' ', $options['indent']);
        }

        $lines = preg_split('#\\R#u', $phpcode);
        $baseline = $options['baseline'];
        if ($baseline < 0) {
            $baseline = count($lines) + $baseline;
        }
        preg_match('@^[ \t]*@u', $lines[$baseline] ?? '', $matches);
        $indent = $matches[0] ?? '';

        $tmp = \PhpToken::tokenize("<?php $phpcode");
        array_shift($tmp);

        // トークンの正規化
        $tokens = [];
        for ($i = 0; $i < count($tmp); $i++) {
            if ($options['heredoc']) {
                // 行コメントと同じ（T_START_HEREDOC には改行が含まれている）
                if ($tmp[$i]->id === T_START_HEREDOC && preg_match('@^(<<<).*?(\\R)@um', $tmp[$i]->text, $matches)) {
                    $tmp[$i]->text = trim($tmp[$i]->text);
                    if (($tmp[$i + 1]->id ?? null) === T_ENCAPSED_AND_WHITESPACE) {
                        $tmp[$i + 1]->text = $matches[2] . $tmp[$i + 1]->text;
                    }
                    else {
                        array_splice($tmp, $i + 1, 0, [new \PhpToken(T_ENCAPSED_AND_WHITESPACE, $matches[2])]);
                    }
                }
                // php 7.3 において T_END_HEREDOC は必ず単一行になる
                if ($tmp[$i]->id === T_ENCAPSED_AND_WHITESPACE) {
                    if (($tmp[$i + 1]->id ?? null) === T_END_HEREDOC && preg_match('@^(\\s+)(.*)@um', $tmp[$i + 1]->text, $matches)) {
                        $tmp[$i]->text = $tmp[$i]->text . $matches[1];
                        $tmp[$i + 1]->text = $matches[2];
                    }
                }
            }

            $tokens[] = $tmp[$i];
        }

        // 改行を置換してインデント
        $hereing = false;
        foreach ($tokens as $i => $token) {
            if ($options['heredoc']) {
                if ($token->id === T_START_HEREDOC) {
                    $hereing = true;
                }
                if ($token->id === T_END_HEREDOC) {
                    $hereing = false;
                }
            }
            if (in_array($token->id, [T_WHITESPACE, T_COMMENT, T_DOC_COMMENT], true) || ($hereing && $token->id === T_ENCAPSED_AND_WHITESPACE)) {
                $token->text = preg_replace("@(\\R)$indent@um", '$1' . $options['indent'], $token->text);
            }
            if ($options['trimempty']) {
                if ($token->id === T_WHITESPACE) {
                    $token->text = preg_replace("@(\\R)[ \\t]+(\\R)@um", '$1$2', $token->text);
                }
            }

            $tokens[$i] = $token;
        }
        return implode('', array_column($tokens, 'text'));
    }
}

assert(!function_exists('ryunosuke\\dbml\\php_tokens') || (new \ReflectionFunction('ryunosuke\\dbml\\php_tokens'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\php_tokens')) {
    /**
     * PhpToken に便利メソッドを生やした配列を返す
     *
     * php_parse とは似て非なる（あっちは何がしたいのかよく分からなくなっている）。
     * この関数はシンプルに PhpToken の拡張版として動作する。
     *
     * 生えているメソッドは下記。
     * - __debugInfo: デバッグしやすい情報で吐き出す
     * - clone: 新プロパティを指定して clone する
     * - name: getTokenName のエイリアス
     * - prev: 条件一致した直前のトークンを返す
     *   - 引数未指定時は isIgnorable でないもの
     * - next: 条件一致した直後のトークンを返す
     *   - 引数未指定時は isIgnorable でないもの
     * - find: ブロック内部を読み飛ばしつつ指定トークンを探す
     * - end: 自身の対応するペアトークンまで飛ばして返す
     *   - 要するに { や (, " などの中途半端ではない終わりのトークンを返す
     * - contents: 自身と end 間のトークンを文字列化する
     * - resolve: text が名前空間を解決して完全修飾になったトークンを返す
     *
     * Example:
     * ```php
     * $phpcode = '<?php
     * // dummy
     * namespace Hogera;
     * class Example
     * {
     *     // something
     * }';
     *
     * $tokens = php_tokens($phpcode);
     * // name でトークン名が得られる
     * that($tokens[0])->name()->is('T_OPEN_TAG');
     * // ↑の次はコメントだが next で namespace が得られる
     * that($tokens[0])->next()->text->is('namespace');
     * // 同じく↑の次はホワイトスペースだが next で Hogera が得られる
     * that($tokens[0])->next()->next()->text->is('Hogera');
     * ```
     *
     * @package ryunosuke\Functions\Package\misc
     *
     * @noinspection PhpPossiblePolymorphicInvocationInspection
     *
     * @param string $phpcode パースする php コード
     * @param int $flags パースオプション
     * @return \PhpTokens[] トークン配列
     */
    function php_tokens(string $code, int $flags = 0)
    {
        $PhpToken = null;
        $PhpToken ??= new #[\AllowDynamicProperties] class (0, "") extends \PhpToken {
            public array $tokens;
            public int   $index;

            public function __debugInfo(): array
            {
                $result = get_object_vars($this);

                unset($result['tokens'], $result['cache']);

                $result['name'] = $this->name();
                $result['prev'] = $this->prev()?->getTokenName();
                $result['next'] = $this->next()?->getTokenName();

                return $result;
            }

            public function clone(...$newparams): self
            {
                $that = clone $this;
                foreach ($newparams as $param => $value) {
                    $that->{$param} = $value;
                }
                return $that;
            }

            public function name(): string
            {
                return $this->getTokenName();
            }

            public function prev($condition = null): ?self
            {
                $condition ??= fn($token) => !$token->isIgnorable();
                return $this->sibling(-1, $condition);
            }

            public function next($condition = null): ?self
            {
                $condition ??= fn($token) => !$token->isIgnorable();
                return $this->sibling(+1, $condition);
            }

            public function find($condition): ?self
            {
                $condition = (array) $condition;
                $token = $this;
                while (true) {
                    $token = $token->sibling(+1, array_merge($condition, ['{', '${', '"', T_START_HEREDOC, '#[', '[', '(']));
                    if ($token === null) {
                        return null;
                    }
                    if ($token->is($condition)) {
                        return $token;
                    }
                    $token = $token->end();
                }
            }

            public function end(): self
            {
                $skip = function ($starts, $ends) {
                    $token = $this;
                    while (true) {
                        $token = $token->sibling(+1, array_merge($starts, $ends)) ?? throw new \DomainException(sprintf("token mismatch(line:%d, pos:%d, '%s')", $token->line, $token->pos, $token->text));
                        if ($token->is($starts)) {
                            $token = $token->end();
                        }
                        elseif ($token->is($ends)) {
                            return $token;
                        }
                    }
                };

                if ($this->is('"')) {
                    return $skip(['{', '${'], ['"']);
                }
                if ($this->is('`')) {
                    return $skip(['{', '${'], ['`']);
                }
                if ($this->is(T_START_HEREDOC)) {
                    return $skip(['{', '${'], [T_END_HEREDOC]);
                }
                if ($this->is('#[')) {
                    return $skip(['#[', '['], [']']);
                }
                if ($this->is('[')) {
                    return $skip(['#[', '['], [']']);
                }
                if ($this->is('${')) {
                    return $skip(['${'], ['}']); // @codeCoverageIgnore deprecated php8.2
                }
                if ($this->is('{')) {
                    return $skip(['{', '"'], ['}']);
                }
                if ($this->is('(')) {
                    return $skip(['('], [')']);
                }

                throw new \DomainException(sprintf("token is not pairable(line:%d, pos:%d, '%s')", $this->line, $this->pos, $this->text));
            }

            public function contents(?int $end = null): string
            {
                $end ??= $this->end()->index;
                return implode('', array_column(array_slice($this->tokens, $this->index, $end - $this->index + 1), 'text'));
            }

            public function resolve($ref): string
            {
                $var_export = fn($v) => var_export($v, true);
                $prev = $this->prev();
                $next = $this->next();

                $text = $this->text;
                if ($this->id === T_STRING) {
                    $namespaces = [$ref->getNamespaceName()];
                    if ($ref instanceof \ReflectionFunctionAbstract) {
                        $namespaces[] = $ref->getClosureScopeClass()?->getNamespaceName();
                    }
                    if ($prev->id === T_NEW || $prev->id === T_ATTRIBUTE || $next->id === T_DOUBLE_COLON || $next->id === T_VARIABLE || $next->text === '{') {
                        $text = namespace_resolve($text, $ref->getFileName(), 'alias') ?? $text;
                    }
                    elseif ($next->text === '(') {
                        $text = namespace_resolve($text, $ref->getFileName(), 'function') ?? $text;
                        // 関数・定数は use しなくてもグローバルにフォールバックされる（=グローバルと名前空間の区別がつかない）
                        foreach ($namespaces as $namespace) {
                            if (!function_exists($text) && function_exists($nstext = "\\$namespace\\$text")) {
                                $text = $nstext;
                                break;
                            }
                        }
                    }
                    else {
                        $text = namespace_resolve($text, $ref->getFileName(), 'const') ?? $text;
                        // 関数・定数は use しなくてもグローバルにフォールバックされる（=グローバルと名前空間の区別がつかない）
                        foreach ($namespaces as $namespace) {
                            if (!const_exists($text) && const_exists($nstext = "\\$namespace\\$text")) {
                                $text = $nstext;
                                break;
                            }
                        }
                    }
                }

                // マジック定数の解決
                if ($this->id === T_DIR) {
                    $text = $var_export(dirname($ref->getFileName()));
                }
                if ($this->id === T_FILE) {
                    $text = $var_export($ref->getFileName());
                }
                if ($this->id === T_NS_C) {
                    $text = $var_export($ref->getNamespaceName());
                }
                return $text;
            }

            private function sibling(int $step, $condition)
            {
                if (is_array($condition) || !is_callback($condition)) {
                    $condition = fn($token) => $token->is($condition);
                }
                for ($i = $this->index + $step; isset($this->tokens[$i]); $i += $step) {
                    if ($condition($this->tokens[$i])) {
                        return $this->tokens[$i];
                    }
                }
                return null;
            }
        };

        $tokens = $PhpToken::tokenize($code, $flags);
        foreach ($tokens as $i => $token) {
            $token->tokens = $tokens;
            $token->index = $i;
        }
        return $tokens;
    }
}

assert(!function_exists('ryunosuke\\dbml\\glob2regex') || (new \ReflectionFunction('ryunosuke\\dbml\\glob2regex'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\glob2regex')) {
    /**
     * glob 記法を正規表現に変換する
     *
     * 原則的に glob/fnmatch における「パスとしてのマッチ（ディレクトリ区切りの特別扱い）」という性質は失われ、あくまで文字列として扱う。
     * サポートしている記法は下記（ https://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%AD%E3%83%96 ）。
     * - `*`: 0文字以上の任意の文字列にマッチ
     * - `?`: 任意の1文字にマッチ
     * - `[...]`: 括弧内で列挙されたどれか1文字にマッチ
     * - `[!...]`: 括弧内で列挙されていない何かの1文字にマッチ
     * - `[0-9]`: 括弧内で指定された範囲内の1文字にマッチ
     * - `[!0-9]`: 括弧内で指定されていない範囲内の1文字にマッチ
     * - `{a,b,c}`: 「a」、「b」あるいは「c」のいずれかにマッチ（要 GLOB_BRACE）
     *
     * GLOB_RECURSIVE を与えた場合、挙動が下記のように変化する。
     * - `*`: "/" を含まない0文字以上の文字列にマッチ
     * - `**`: "/" を含む任意の0文字以上の文字列にマッチ
     *
     * いわゆる double star での再帰パターンのためだが、ディレクトリセパレータは "/" 固定とする（glob の "\" エスケープと絡んで非常にややこしいため）。
     *
     * Example:
     * ```php
     * $files = ['hoge.jpg', 'test1.jpg', 'test12.jpg', 'test123.png', 'testA.jpg', 'testAB.jpg', 'testABC.png', 'test.jpg', 'test.jpeg'];
     * // 先頭一致する jpg
     * that(preg_grep('#' . glob2regex('test*.jpg') . '#', $files))->isSame([
     *     1 => 'test1.jpg',
     *     2 => 'test12.jpg',
     *     4 => 'testA.jpg',
     *     5 => 'testAB.jpg',
     *     7 => 'test.jpg',
     * ]);
     * // 先頭一致した2文字の jpg
     * that(preg_grep('#' . glob2regex('test??.jpg') . '#', $files))->isSame([
     *     2 => 'test12.jpg',
     *     5 => 'testAB.jpg',
     * ]);
     * // 先頭一致した数値1桁の jpg
     * that(preg_grep('#' . glob2regex('test[0-9].jpg') . '#', $files))->isSame([
     *     1 => 'test1.jpg',
     * ]);
     * // 先頭一致した数値1桁でない jpg
     * that(preg_grep('#' . glob2regex('test[!0-9].jpg') . '#', $files))->isSame([
     *     4 => 'testA.jpg',
     * ]);
     * // jpeg, jpg のどちらにもマッチ（GLOB_BRACE 使用）
     * that(preg_grep('#' . glob2regex('test.jp{e,}g', GLOB_BRACE) . '#', $files))->isSame([
     *     7 => 'test.jpg',
     *     8 => 'test.jpeg',
     * ]);
     * // 深い階層を含めたすべての png にマッチ（GLOB_RECURSIVE 使用）
     * that(preg_grep('#^' . glob2regex('/**.png', GLOB_RECURSIVE) . '$#', [
     *     '/path/a.png',
     *     '/path/to/b.png',
     *     '/path/to/dir/c.png',
     * ]))->isSame([
     *     '/path/a.png',
     *     '/path/to/b.png',
     *     '/path/to/dir/c.png',
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\pcre
     *
     * @param string $pattern glob パターン文字列
     * @param int $flags glob フラグ
     * @return string 正規表現パターン文字列
     */
    function glob2regex($pattern, $flags = 0)
    {
    $replacer = [
        // target glob character
        '*'  => '(.*)',
        '?'  => '(.)',
        '[!' => '([^',
        '['  => '([',
        ']'  => '])',
        // quote regex character
        '.'  => '\\.',
        //'\\' => '\\\\',
        '+'  => '\\+',
        //'*' => '\\*',
        //'?' => '\\?',
        //'[' => '\\[',
        '^'  => '\\^',
        //']' => '\\]',
        '$'  => '\\$',
        '('  => '\\(',
        ')'  => '\\)',
        //'{' => '\\{',
        //'}' => '\\}',
        '='  => '\\=',
        '!'  => '\\!',
        '<'  => '\\<',
        '>'  => '\\>',
        '|'  => '\\|',
        ':'  => '\\:',
        //'-' => '\\-',
        '#'  => '\\#',
    ];

    if ($flags & GLOB_RECURSIVE) {
        $replacer['**'] = '(.*)';
        $replacer['*'] = '([^/]*)';
    }

    if (!($flags & GLOB_BRACE)) {
        $replacer += [
            '{' => '\\{',
            '}' => '\\}',
        ];
    }

    $pattern = strtr_escaped($pattern, $replacer);

    if ($flags & GLOB_BRACE) {
        while (true) {
            $brace_s = strpos_escaped($pattern, '{');
            if ($brace_s === null) {
                break;
            }
            $brace_e = strpos_escaped($pattern, '}', $brace_s);
            if ($brace_e === null) {
                break;
            }
            $brace = substr($pattern, $brace_s + 1, $brace_e - $brace_s - 1);
            $brace = strtr_escaped($brace, [',' => '|']);
            $pattern = substr_replace($pattern, "($brace)", $brace_s, $brace_e - $brace_s + 1);
        }
    }

    return $pattern;
    }
}

assert(!function_exists('ryunosuke\\dbml\\preg_capture') || (new \ReflectionFunction('ryunosuke\\dbml\\preg_capture'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\preg_capture')) {
    /**
     * キャプチャを主軸においた preg_match
     *
     * $pattern で $subject をマッチングして $default で埋めて返す。$default はフィルタも兼ねる。
     * 空文字マッチは「マッチしていない」とみなすので注意（$default が使用される）。
     *
     * キャプチャを主軸においているので「マッチしなかった」は検出不可能。
     * $default がそのまま返ってくる。
     *
     * Example:
     * ```php
     * $pattern = '#(\d{4})/(\d{1,2})(/(\d{1,2}))?#';
     * $default = [1 => '2000', 2 => '1', 4 => '1'];
     * // 完全にマッチするのでそれぞれ返ってくる
     * that(preg_capture($pattern, '2014/12/24', $default))->isSame([1 => '2014', 2 => '12', 4 => '24']);
     * // 最後の \d{1,2} はマッチしないのでデフォルト値が使われる
     * that(preg_capture($pattern, '2014/12', $default))->isSame([1 => '2014', 2 => '12', 4 => '1']);
     * // 一切マッチしないので全てデフォルト値が使われる
     * that(preg_capture($pattern, 'hoge', $default))->isSame([1 => '2000', 2 => '1', 4 => '1']);
     * ```
     *
     * @package ryunosuke\Functions\Package\pcre
     *
     * @param string $pattern 正規表現
     * @param string $subject 対象文字列
     * @param array $default デフォルト値
     * @return array キャプチャした配列
     */
    function preg_capture($pattern, $subject, $default)
    {
        preg_match($pattern, $subject, $matches);

        foreach ($matches as $n => $match) {
            if (array_key_exists($n, $default) && strlen($match)) {
                $default[$n] = $match;
            }
        }

        return $default;
    }
}

assert(!function_exists('ryunosuke\\dbml\\preg_replaces') || (new \ReflectionFunction('ryunosuke\\dbml\\preg_replaces'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\preg_replaces')) {
    /**
     * パターン番号を指定して preg_replace する
     *
     * パターン番号を指定してそれのみを置換する。
     * 名前付きキャプチャを使用している場合はキーに文字列も使える。
     * 値にクロージャを渡した場合はコールバックされて置換される。
     *
     * $replacements に単一文字列を渡した場合、 `[1 => $replacements]` と等しくなる（第1キャプチャを置換）。
     *
     * Example:
     * ```php
     * // a と z に囲まれた数字を XXX に置換する
     * that(preg_replaces('#a(\d+)z#', [1 => 'XXX'], 'a123z'))->isSame('aXXXz');
     * // 名前付きキャプチャも指定できる
     * that(preg_replaces('#a(?<digit>\d+)z#', ['digit' => 'XXX'], 'a123z'))->isSame('aXXXz');
     * // クロージャを渡すと元文字列を引数としてコールバックされる
     * that(preg_replaces('#a(?<digit>\d+)z#', ['digit' => fn($src) => $src * 2], 'a123z'))->isSame('a246z');
     * // 複合的なサンプル（a タグの href と target 属性を書き換える）
     * that(preg_replaces('#<a\s+href="(?<href>.*)"\s+target="(?<target>.*)">#', [
     *     'href'   => fn($href) => strtoupper($href),
     *     'target' => fn($target) => strtoupper($target),
     * ], '<a href="hoge" target="fuga">inner text</a>'))->isSame('<a href="HOGE" target="FUGA">inner text</a>');
     * ```
     *
     * @package ryunosuke\Functions\Package\pcre
     *
     * @param string $pattern 正規表現
     * @param array|string|callable $replacements 置換文字列
     * @param string $subject 対象文字列
     * @param int $limit 置換回数
     * @param null $count 置換回数格納変数
     * @return string 置換された文字列
     */
    function preg_replaces($pattern, $replacements, $subject, $limit = -1, &$count = null)
    {
        $offset = 0;
        $count = 0;
        if (!is_arrayable($replacements)) {
            $replacements = [1 => $replacements];
        }

        preg_match_all($pattern, $subject, $matches, PREG_OFFSET_CAPTURE | PREG_SET_ORDER);
        foreach ($matches as $match) {
            if ($limit-- === 0) {
                break;
            }
            $count++;

            foreach ($match as $index => $m) {
                if ($m[1] >= 0 && $index !== 0 && isset($replacements[$index])) {
                    $src = $m[0];
                    $dst = $replacements[$index];
                    if ($dst instanceof \Closure) {
                        $dst = $dst($src);
                    }

                    $srclen = strlen($src);
                    $dstlen = strlen($dst);

                    $subject = substr_replace($subject, $dst, $offset + $m[1], $srclen);
                    $offset += $dstlen - $srclen;
                }
            }
        }
        return $subject;
    }
}

assert(!function_exists('ryunosuke\\dbml\\preg_splice') || (new \ReflectionFunction('ryunosuke\\dbml\\preg_splice'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\preg_splice')) {
    /**
     * キャプチャも行える preg_replace
     *
     * 「置換を行いつつ、キャプチャ文字列が欲しい」状況はまれによくあるはず。
     *
     * $replacement に callable を渡すと preg_replace_callback がコールされる。
     * callable とはいっても単純文字列 callble （"strtoupper" など）は callable とはみなされない。
     * 配列形式の callable や クロージャのみ preg_replace_callback になる。
     *
     * Example:
     * ```php
     * // 数字を除去しつつその除去された数字を得る
     * that(preg_splice('#\\d+#', '', 'abc123', $m))->isSame('abc');
     * that($m)->isSame(['123']);
     *
     * // callable だと preg_replace_callback が呼ばれる
     * that(preg_splice('#[a-z]+#', fn($m) => strtoupper($m[0]), 'abc123', $m))->isSame('ABC123');
     * that($m)->isSame(['abc']);
     *
     * // ただし、 文字列 callable は文字列として扱う
     * that(preg_splice('#[a-z]+#', 'strtoupper', 'abc123', $m))->isSame('strtoupper123');
     * that($m)->isSame(['abc']);
     * ```
     *
     * @package ryunosuke\Functions\Package\pcre
     *
     * @param string $pattern 正規表現
     * @param string|callable $replacement 置換文字列
     * @param string $subject 対象文字列
     * @param array $matches キャプチャ配列が格納される
     * @param int $limit 置換回数
     * @return string 置換された文字列
     */
    function preg_splice($pattern, $replacement, $subject, &$matches = [], $limit = -1)
    {
        // for compatible. $limit => 1
        // preg_match なので $matches は最初しか引っかからないにも関わらず $limit:-1 だとすべて置換されてしまう

        if (preg_match($pattern, $subject, $matches)) {
            if (!is_string($replacement) && is_callable($replacement)) {
                $subject = preg_replace_callback($pattern, $replacement, $subject, $limit);
            }
            else {
                $subject = preg_replace($pattern, $replacement, $subject, $limit);
            }
        }
        return $subject;
    }
}

assert(!function_exists('ryunosuke\\dbml\\random_range') || (new \ReflectionFunction('ryunosuke\\dbml\\random_range'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\random_range')) {
    /**
     * 指定範囲内からランダムで返す
     *
     * $count を null にすると個数すらもランダムで返す。
     * 結果は範囲内では重複しない。
     *
     * 範囲が負数の場合は例外を投げるが、$count の 0 や範囲超過数は許容される（array_rand とは違う）。
     *
     * Example:
     * ```php
     * mt_srand(5); // テストがコケるので種固定
     *
     * // [10~20] の区間でランダムに3件返す
     * that(random_range(10, 20, 3))->is([19, 20, 10]);
     * // 0 を渡しても OK（単に空配列を返す）
     * that(random_range(10, 20, 0))->is([]);
     * // 範囲超過数を渡しても OK（最大個数で返す）
     * that(count(random_range(10, 20, 999)))->is(11);
     * ```
     *
     * @package ryunosuke\Functions\Package\random
     *
     * @param int $min 最小値
     * @param int $max 最大値
     * @param ?int $count 返す個数
     * @return array min～maxの数値の配列
     */
    function random_range($min, $max, $count = null)
    {
        $range = $max - $min;
        if ($range < 0) {
            throw new \InvalidArgumentException("invalid range ($min > $max)");
        }

        if ($count === null) {
            $count = rand(0, $range + 1);
        }

        if ($count > ($range >> 1)) {
            $array = range($min, $max);
            shuffle($array);
            return array_slice($array, 0, $count);
        }

        $result = [];
        while (count($result) < $count) {
            $result[rand($min, $max)] = null;
        }
        return array_keys($result);
    }
}

assert(!function_exists('ryunosuke\\dbml\\unique_string') || (new \ReflectionFunction('ryunosuke\\dbml\\unique_string'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\unique_string')) {
    /**
     * 文字列に含まれない文字列を生成する
     *
     * 例えば http のマルチパートバウンダリのような、「競合しない文字列」を生成する。
     * 実装は愚直に文字列を調べて存在しなければそれを返すようになっている。
     * 一応初期値や文字セットは指定可能。
     *
     * $initial に int を与えると初期値としてその文字数分 $charlist から確保する。
     * 例えば生成後の変更が前提で、ある程度の長さを担保したいときに指定すれば最低でもその長さ以上は保証される。
     * $initial に string を与えるとそれがそのまま初期値として使用される。
     * 例えば「ほぼ存在しない文字列」が予測できるのであればそれを指定すれば無駄な処理が省ける。
     *
     * Example:
     * ```php
     * // 単純に呼ぶと生成1,2文字程度の文字列になる
     * that(unique_string('hello, world'))->stringLengthEqualsAny([1, 2]);
     * // 数値を含んでいないので候補文字に数値のみを指定すれば1文字で「存在しない文字列」となる
     * that(unique_string('hello, world', null, range(0, 9)))->stringLengthEquals(1);
     * // int を渡すと最低でもそれ以上は保証される
     * that(unique_string('hello, world', 5))->stringLengthEqualsAny([5, 6]);
     * // string を渡すとそれが初期値となる
     * that(unique_string('hello, world', 'prefix-'))->stringStartsWith('prefix');
     * ```
     *
     * @package ryunosuke\Functions\Package\random
     *
     * @param string $source 元文字列
     * @param string|int $initial 初期文字列あるいは文字数
     * @param string|array $charlist 使用する文字セット
     * @return string 一意な文字列
     */
    function unique_string($source, $initial = null, $charlist = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')
    {
        assert(is_stringable($initial) || is_int($initial) || is_null($initial));

        if (is_stringable($charlist)) {
            $charlist = preg_split('//', $charlist, -1, PREG_SPLIT_NO_EMPTY);
        }

        $charlength = count($charlist);
        if ($charlength === 0) {
            throw new \InvalidArgumentException('charlist is empty.');
        }

        $result = '';
        if (is_int($initial)) {
            shuffle($charlist);
            $result = implode('', array_slice($charlist, 0, $initial));
        }
        elseif (is_null($initial)) {
            $result .= $charlist[mt_rand(0, $charlength - 1)];
        }
        else {
            $result = $initial;
        }

        while ((($p = strpos($source, $result, $p ?? 0)) !== false)) {
            $result .= $charlist[mt_rand(0, $charlength - 1)];
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\callable_code') || (new \ReflectionFunction('ryunosuke\\dbml\\callable_code'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\callable_code')) {
    /**
     * callable のコードブロックを返す
     *
     * 返り値は2値の配列。0番目の要素が定義部、1番目の要素が処理部を表す。
     *
     * Example:
     * ```php
     * list($meta, $body) = callable_code(function (...$args) {return true;});
     * that($meta)->isSame('function (...$args)');
     * that($body)->isSame('{return true;}');
     *
     * // ReflectionFunctionAbstract を渡しても動作する
     * list($meta, $body) = callable_code(new \ReflectionFunction(function (...$args) {return true;}));
     * that($meta)->isSame('function (...$args)');
     * that($body)->isSame('{return true;}');
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param callable|\ReflectionFunctionAbstract $callable コードを取得する callable
     * @param bool $return_token true にすると生のトークン配列で返す
     * @return array ['定義部分', '{処理コード}']
     */
    function callable_code($callable, bool $return_token = false)
    {
        $ref = $callable instanceof \ReflectionFunctionAbstract ? $callable : reflect_callable($callable);
        $contents = file($ref->getFileName());
        $start = $ref->getStartLine();
        $end = $ref->getEndLine();
        $codeblock = implode('', array_slice($contents, $start - 1, $end - $start + 1));

        $tokens = php_tokens("<?php $codeblock");

        $begin = $tokens[0]->next([T_FUNCTION, T_FN]);
        $close = $begin->next(['{', T_DOUBLE_ARROW]);

        if ($begin->is(T_FN)) {
            $meta = array_slice($tokens, $begin->index, $close->prev()->index - $begin->index + 1);
            $temp = $close->find([';', ',', T_CLOSE_TAG]);
            // アロー関数は終了トークンが明確ではない
            // - $x = fn() => 123;         // セミコロン
            // - $x = fn() => [123];       // セミコロンであって ] ではない
            // - $x = [fn() => 123, null]; // こうだとカンマになるし
            // - $x = [fn() => 123];       // こうだと ] になる
            // しっかり実装できなくもないが、（多分）戻り読みが必要なのでここでは構文チェックをパスするまでループする実装とした
            while ($temp) {
                $test = array_slice($tokens, $close->next()->index, $temp->index - $close->next()->index);
                $text = implode('', array_column($test, 'text'));
                try {
                    /** @noinspection PhpExpressionResultUnusedInspection */
                    token_get_all("<?php $text;", TOKEN_PARSE);
                    break;
                }
                catch (\Throwable) {
                    $temp = $temp->prev();
                }
            }
            $body = array_slice($tokens, $close->next()->index, $temp ? $temp->index - $close->next()->index : null);
        }
        else {
            $meta = array_slice($tokens, $begin->index, $close->index - $begin->index);
            $body = $close->end();
            $body = array_slice($tokens, $close->index, $body->index - $close->index + 1);
        }

        if ($return_token) {
            return [$meta, $body];
        }

        return [trim(implode('', array_column($meta, 'text'))), trim(implode('', array_column($body, 'text')))];
    }
}

assert(!function_exists('ryunosuke\\dbml\\function_parameter') || (new \ReflectionFunction('ryunosuke\\dbml\\function_parameter'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\function_parameter')) {
    /**
     * 関数/メソッドの引数定義を取得する
     *
     * ほぼ内部向けで外から呼ぶことはあまり想定していない。
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param \ReflectionFunctionAbstract|callable $eitherReffuncOrCallable 関数/メソッドリフレクション or callable
     * @return array [引数名 => 引数宣言] の配列
     */
    function function_parameter($eitherReffuncOrCallable)
    {
        $reffunc = $eitherReffuncOrCallable instanceof \ReflectionFunctionAbstract
            ? $eitherReffuncOrCallable
            : reflect_callable($eitherReffuncOrCallable);

        $result = [];
        foreach ($reffunc->getParameters() as $parameter) {
            $declare = '';

            if ($parameter->hasType()) {
                $declare .= reflect_type_resolve($parameter->getType()) . ' ';
            }

            if ($parameter->isPassedByReference()) {
                $declare .= '&';
            }

            if ($parameter->isVariadic()) {
                $declare .= '...';
            }

            $declare .= '$' . $parameter->getName();

            if ($parameter->isOptional()) {
                $defval = null;

                if ($parameter->isDefaultValueAvailable()) {
                    // 修飾なしでデフォルト定数が使われているとその名前空間で解決してしまうので場合分けが必要
                    if ($parameter->isDefaultValueConstant() && strpos($parameter->getDefaultValueConstantName(), '\\') === false) {
                        // 存在チェック＋$dummy でグローバル定数を回避しているが、いっそのこと一律 \\ を付与してしまっても良いような気がする
                        if (const_exists(...(explode('::', $parameter->getDefaultValueConstantName()) + [1 => '$dummy']))) {
                            $defval = '\\' . $parameter->getDefaultValueConstantName();
                        }
                        else {
                            $defval = $parameter->getDefaultValueConstantName();
                        }
                    }
                    else {
                        $default = $parameter->getDefaultValue();
                        $defval = var_export2($default, true);
                    }
                }
                // isOptional だが isDefaultValueAvailable でないし isVariadic でもない（稀にある（stream_filter_append で確認））
                elseif (!$parameter->isVariadic()) {
                    // Type に応じたデフォルト値が得られればベストだがそこまでする必要もない
                    // 少なくとも 8.0 時点では = null してしまえば型エラーも起きない（8.4 で非推奨になってるけど）
                    $defval = "null";
                }

                if (isset($defval)) {
                    $declare .= ' = ' . $defval;
                }
            }

            $name = ($parameter->isPassedByReference() ? '&' : '') . '$' . $parameter->getName();
            $result[$name] = $declare;
        }

        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\parameter_default') || (new \ReflectionFunction('ryunosuke\\dbml\\parameter_default'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\parameter_default')) {
    /**
     * callable のデフォルト引数を返す
     *
     * オプションで指定もできる。
     * 負数を指定した場合「最後の引数から数えた位置」になる。
     *
     * 内部関数には使用できない（リフレクションが対応していない）。
     *
     * Example:
     * ```php
     * $f = function ($a, $b = 'b') {};
     * // デフォルト引数である b を返す
     * that(parameter_default($f))->isSame([1 => 'b']);
     * // 引数で与えるとそれが優先される
     * that(parameter_default($f, ['A', 'B']))->isSame(['A', 'B']);
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param callable $callable 対象 callable
     * @param iterable|array $arguments デフォルト引数
     * @return array デフォルト引数
     */
    function parameter_default(callable $callable, $arguments = [])
    {
        static $cache = [];

        // $call_name でキャッシュ。しかしクロージャはすべて「Closure::__invoke」になるのでキャッシュできない
        is_callable($callable, true, $call_name);
        if (!isset($cache[$call_name]) || $callable instanceof \Closure) {
            /** @var \ReflectionFunctionAbstract $refunc */
            $refunc = reflect_callable($callable);
            $cache[$call_name] = [
                'length'  => $refunc->getNumberOfParameters(),
                'default' => [],
            ];
            foreach ($refunc->getParameters() as $n => $param) {
                if ($param->isDefaultValueAvailable()) {
                    $cache[$call_name]['default'][$n] = $param->getDefaultValue();
                }
            }
        }

        // 指定されていないならそのまま返せば良い（高速化）
        if (is_array($arguments) && !$arguments) {
            return $cache[$call_name]['default'];
        }

        $args2 = [];
        foreach ($arguments as $n => $arg) {
            if ($n < 0) {
                $n += $cache[$call_name]['length'];
            }
            $args2[$n] = $arg;
        }

        return array_merge2($cache[$call_name]['default'], $args2);
    }
}

assert(!function_exists('ryunosuke\\dbml\\parameter_length') || (new \ReflectionFunction('ryunosuke\\dbml\\parameter_length'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\parameter_length')) {
    /**
     * callable の引数の数を返す
     *
     * Example:
     * ```php
     * // trim の引数は2つ
     * that(parameter_length('trim'))->isSame(2);
     * // trim の必須引数は1つ
     * that(parameter_length('trim', true))->isSame(1);
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param callable $callable 対象 callable
     * @param bool $require_only true を渡すと必須パラメータの数を返す
     * @param bool $thought_variadic 可変引数を考慮するか。 true を渡すと可変引数の場合に無限長を返す
     * @return int 引数の数
     */
    function parameter_length($callable, $require_only = false, $thought_variadic = false)
    {
        /** @var \ReflectionFunctionAbstract $ref */
        $ref = reflect_callable($callable);
        if ($thought_variadic && $ref->isVariadic()) {
            return INF;
        }
        elseif ($require_only) {
            return $ref->getNumberOfRequiredParameters();
        }
        else {
            return $ref->getNumberOfParameters();
        }
    }
}

assert(!function_exists('ryunosuke\\dbml\\reflect_callable') || (new \ReflectionFunction('ryunosuke\\dbml\\reflect_callable'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\reflect_callable')) {
    /**
     * callable から ReflectionFunctionAbstract を生成する
     *
     * 実際には ReflectionFunctionAbstract を下記の独自拡張した Reflection クラスを返す（メソッドのオーバーライド等はしていないので完全互換）。
     * - __invoke: 元となったオブジェクトを $this として invoke する（関数・クロージャは invoke と同義）
     * - call: 実行 $this を指定して invoke する（クロージャ・メソッドのみ）
     *   - 上記二つは __call/__callStatic のメソッドも呼び出せる
     * - getDeclaration: 宣言部のコードを返す
     * - getCode: 定義部のコードを返す
     * - isAnonymous: 無名関数なら true を返す（8.2 の isAnonymous 互換）
     * - isArrow: アロー演算子で定義されたかを返す（クロージャのみ）
     * - isStatic: $this バインド可能かを返す（クロージャのみ）
     * - getUsedVariables: use している変数配列を返す（クロージャのみ）
     * - getClosure: 元となったオブジェクトを $object としたクロージャを返す（メソッドのみ）
     *   - 上記二つは __call/__callStatic のメソッドも呼び出せる
     * - getTraitMethod: トレイト側のリフレクションを返す（メソッドのみ）
     *
     * Example:
     * ```php
     * that(reflect_callable('sprintf'))->isInstanceOf(\ReflectionFunction::class);
     * that(reflect_callable('\Closure::bind'))->isInstanceOf(\ReflectionMethod::class);
     *
     * $x = 1;
     * $closure = function ($a, $b) use (&$x) { return $a + $b; };
     * $reflection = reflect_callable($closure);
     * // 単純実行
     * that($reflection(1, 2))->is(3);
     * // 無名クラスを $this として実行
     * that($reflection->call(new class(){}, 1, 2))->is(3);
     * // 宣言部を返す
     * that($reflection->getDeclaration())->is('function ($a, $b) use (&$x)');
     * // 定義部を返す
     * that($reflection->getCode())->is('{ return $a + $b; }');
     * // static か返す
     * that($reflection->isStatic())->is(false);
     * // use 変数を返す
     * that($reflection->getUsedVariables())->is(['x' => 1]);
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param callable $callable 対象 callable
     * @return \ReflectCallable|\ReflectionFunction|\ReflectionMethod リフレクションインスタンス
     */
    function reflect_callable($callable)
    {
        // callable チェック兼 $call_name 取得
        if (!is_callable($callable, true, $call_name)) {
            throw new \InvalidArgumentException("'$call_name' is not callable");
        }

        if (is_string($call_name) && strpos($call_name, '::') === false) {
            return new class($callable) extends \ReflectionFunction {
                private $definition;

                public function __invoke(...$args): mixed
                {
                    return $this->invoke(...$args);
                }

                public function getDeclaration(): string
                {
                    return ($this->definition ??= callable_code($this))[0];
                }

                public function getCode(): string
                {
                    return ($this->definition ??= callable_code($this))[1];
                }

                public function isAnonymous(): bool
                {
                    return false;
                }
            };
        }
        elseif ($callable instanceof \Closure) {
            return new class($callable) extends \ReflectionFunction {
                private $callable;
                private $definition;

                public function __construct($function)
                {
                    parent::__construct($function);

                    $this->callable = $function;
                }

                public function __invoke(...$args): mixed
                {
                    return $this->invoke(...$args);
                }

                public function call($newThis = null, ...$args): mixed
                {
                    return ($this->callable)->call($newThis ?? $this->getClosureThis(), ...$args);
                }

                public function getDeclaration(): string
                {
                    return ($this->definition ??= callable_code($this))[0];
                }

                public function getCode(): string
                {
                    return ($this->definition ??= callable_code($this))[1];
                }

                public function isAnonymous(): bool
                {
                    if (method_exists(\ReflectionFunction::class, 'isAnonymous')) {
                        return parent::isAnonymous(); // @codeCoverageIgnore
                    }

                    return strpos($this->name, '{closure}') !== false;
                }

                public function isArrow(): bool
                {
                    // しっかりやるなら PHPToken を使った方がいいけど今の php 構文ならこれで大丈夫のはず
                    return str_starts_with($this->getDeclaration(), 'fn') !== false;
                }

                public function isStatic(): bool
                {
                    return !is_bindable_closure($this->callable);
                }

                public function getUsedVariables(): array
                {
                    if (method_exists(\ReflectionFunction::class, 'getClosureUsedVariables')) {
                        return parent::getClosureUsedVariables(); // @codeCoverageIgnore
                    }

                    $uses = object_properties($this->callable);
                    unset($uses['this']);
                    return $uses;
                }
            };
        }
        else {
            [$class, $method] = explode('::', $call_name, 2);
            // for タイプ 5: 相対指定による静的クラスメソッドのコール (PHP 5.3.0 以降)
            if (strpos($method, 'parent::') === 0) {
                [, $method] = explode('::', $method);
                $class = get_parent_class($class);
            }

            $called_name = '';
            if (!method_exists(is_array($callable) && is_object($callable[0]) ? $callable[0] : $class, $method)) {
                $called_name = $method;
                $method = is_array($callable) && is_object($callable[0]) ? '__call' : '__callStatic';
            }

            return new class($class, $method, $callable, $called_name) extends \ReflectionMethod {
                private $callable;
                private $call_name;
                private $definition;

                public function __construct($class, $method, $callable, $call_name)
                {
                    parent::__construct($class, $method);

                    $this->setAccessible(true); // 8.1 はデフォルトで true になるので模倣する
                    $this->callable = $callable;
                    $this->call_name = $call_name;
                }

                public function __invoke(...$args): mixed
                {
                    if ($this->call_name) {
                        $args = [$this->call_name, $args];
                    }
                    return $this->invoke($this->isStatic() ? null : $this->callable[0], ...$args);
                }

                public function call($newThis = null, ...$args): mixed
                {
                    if ($this->call_name) {
                        $args = [$this->call_name, $args];
                    }
                    return $this->getClosure($newThis ?? ($this->isStatic() ? null : $this->callable[0]))(...$args);
                }

                public function getDeclaration(): string
                {
                    return ($this->definition ??= callable_code($this))[0];
                }

                public function getCode(): string
                {
                    return ($this->definition ??= callable_code($this))[1];
                }

                public function isAnonymous(): bool
                {
                    return false;
                }

                public function getClosure(?object $object = null): \Closure
                {
                    $name = strtolower($this->name);

                    if ($this->isStatic()) {
                        if ($name === '__callstatic') {
                            return \Closure::fromCallable([$this->class, $this->call_name]);
                        }
                        return parent::getClosure();
                    }

                    $object ??= $this->callable[0];
                    if ($name === '__call') {
                        return \Closure::fromCallable([$object, $this->call_name]);
                    }
                    return parent::getClosure($object);
                }

                public function getTraitMethod(): ?\ReflectionMethod
                {
                    $name = strtolower($this->name);
                    $class = $this->getDeclaringClass();
                    $aliases = array_change_key_case($class->getTraitAliases(), CASE_LOWER);

                    if (!isset($aliases[$name])) {
                        if ($this->getFileName() === $class->getFileName()) {
                            return null;
                        }
                        else {
                            return $this;
                        }
                    }

                    [$tname, $mname] = explode('::', $aliases[$name]);
                    $result = new self($tname, $mname, $this->callable, $this->call_name);

                    // alias を張ったとしても自身で再宣言はエラーなく可能で、その場合自身が採用されるようだ
                    if (false
                        || $this->getFileName() !== $result->getFileName()
                        || $this->getStartLine() !== $result->getStartLine()
                        || $this->getEndLine() !== $result->getEndLine()
                    ) {
                        return null;
                    }

                    return $result;
                }
            };
        }
    }
}

assert(!function_exists('ryunosuke\\dbml\\reflect_type_resolve') || (new \ReflectionFunction('ryunosuke\\dbml\\reflect_type_resolve'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\reflect_type_resolve')) {
    /**
     * ReflectionType の型に \\ を付与する
     *
     * php8.0 で ReflectionType の __toString が解放されたけど、それをそのまま埋め込んだりすると \\ がないのでエラーになったりする。
     * この関数を通してから埋め込めば \\ が付くので回避できる、という非常にニッチな関数。
     *
     * 型 exists で判定するため、付与するクラスは存在している必要がある（オプション引数で対応するかもしれない）。
     *
     * Example:
     * ```php
     * // このような DNF 型も形式を保ったまま \\ を付与できる
     * that(reflect_type_resolve('(Countable&Traversable)|object'))->is('(\\Countable&\\Traversable)|object');
     * ```
     *
     * @package ryunosuke\Functions\Package\reflection
     *
     * @param ?string $type string だが実用上は getType 等で得られるインスタンスでよい
     * @return ?string 解決された文字列
     */
    function reflect_type_resolve(?string $type): ?string
    {
        if ($type === null) {
            return null;
        }

        // 拡張関数が string|null ではなく ?string で返すことがあるので ? を含める
        // 8.1以上では交差型もあり得るので (&) も含める
        // そして PREG_SPLIT_DELIM_CAPTURE で分割して再結合すれば元の形式のまま得られる
        $types = preg_split('#([?()|&])#', $type, -1, PREG_SPLIT_DELIM_CAPTURE);
        $types = array_map(fn($v) => type_exists($v) ? "\\" . ltrim($v, '\\') : $v, $types);
        return implode('', $types);
    }
}

assert(!function_exists('ryunosuke\\dbml\\concat') || (new \ReflectionFunction('ryunosuke\\dbml\\concat'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\concat')) {
    /**
     * strcat の空文字回避版
     *
     * 基本は strcat と同じ。ただし、**引数の内1つでも空文字を含むなら空文字を返す**。
     * さらに*引数の内1つでも null を含むなら null を返す**。
     *
     * 「プレフィックスやサフィックスを付けたいんだけど、空文字の場合はそのままで居て欲しい」という状況はまれによくあるはず。
     * コードで言えば `strlen($string) ? 'prefix-' . $string : '';` のようなもの。
     * 可変引数なので 端的に言えば mysql の CONCAT みたいな動作になる。
     *
     * ```php
     * that(concat('prefix-', 'middle', '-suffix'))->isSame('prefix-middle-suffix');
     * that(concat('prefix-', '', '-suffix'))->isSame('');
     * that(concat('prefix-', null, '-suffix'))->isSame(null);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param ?string ...$variadic 結合する文字列（可変引数）
     * @return ?string 結合した文字列
     */
    function concat(...$variadic)
    {
        if (count(array_filter($variadic, 'is_null')) > 0) {
            return null;
        }
        $result = '';
        foreach ($variadic as $s) {
            if (strlen($s) === 0) {
                return '';
            }
            $result .= $s;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\mb_substr_replace') || (new \ReflectionFunction('ryunosuke\\dbml\\mb_substr_replace'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\mb_substr_replace')) {
    /**
     * マルチバイト対応 substr_replace
     *
     * 本家は配列を与えたりできるが、ややこしいし使う気がしないので未対応。
     *
     * Example:
     * ```php
     * // 2文字目から5文字を「あいうえお」に置換する
     * that(mb_substr_replace('０１２３４５６７８９', 'あいうえお', 2, 5))->isSame('０１あいうえお７８９');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param string $replacement 置換文字列
     * @param int $start 開始位置
     * @param ?int $length 置換長
     * @return string 置換した文字列
     */
    function mb_substr_replace(?string $string, ?string $replacement, $start, $length = null)
    {
        $strlen = mb_strlen($string);
        if ($start < 0) {
            $start += $strlen;
        }
        if ($length === null) {
            $length = $strlen;
        }
        if ($length < 0) {
            $length += $strlen - $start;
        }

        return mb_substr($string, 0, $start) . $replacement . mb_substr($string, $start + $length);
    }
}

assert(!function_exists('ryunosuke\\dbml\\multiexplode') || (new \ReflectionFunction('ryunosuke\\dbml\\multiexplode'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\multiexplode')) {
    /**
     * explode の配列対応と $limit の挙動を変えたもの
     *
     * $delimiter には配列が使える。いわゆる「複数文字列での分割」の動作になる。
     *
     * $limit に負数を与えると「その絶対値-1までを結合したものと残り」を返す。
     * 端的に言えば「正数を与えると後詰めでその個数で返す」「負数を与えると前詰めでその（絶対値）個数で返す」という動作になる。
     *
     * Example:
     * ```php
     * // 配列を与えると複数文字列での分割
     * that(multiexplode([',', ' ', '|'], 'a,b c|d'))->isSame(['a', 'b', 'c', 'd']);
     * // 負数を与えると前詰め
     * that(multiexplode(',', 'a,b,c,d', -2))->isSame(['a,b,c', 'd']);
     * // もちろん上記2つは共存できる
     * that(multiexplode([',', ' ', '|'], 'a,b c|d', -2))->isSame(['a,b c', 'd']);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string|array $delimiter 分割文字列。配列可
     * @param string $string 対象文字列
     * @param int $limit 分割数
     * @return array 分割された配列
     */
    function multiexplode($delimiter, ?string $string, $limit = \PHP_INT_MAX)
    {
        $limit = (int) $limit;
        if ($limit < 0) {
            // 下手に php で小細工するよりこうやって富豪的にやるのが一番速かった
            return array_reverse(array_map('strrev', multiexplode($delimiter, strrev($string), -$limit)));
        }
        // explode において 0 は 1 と等しい
        if ($limit === 0) {
            $limit = 1;
        }
        $delimiter = array_map(fn($v) => preg_quote($v, '#'), arrayize($delimiter));
        return preg_split('#' . implode('|', $delimiter) . '#', $string, $limit);
    }
}

assert(!function_exists('ryunosuke\\dbml\\namespace_split') || (new \ReflectionFunction('ryunosuke\\dbml\\namespace_split'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\namespace_split')) {
    /**
     * 文字列を名前空間とローカル名に区切ってタプルで返す
     *
     * class_namespace/class_shorten や function_shorten とほぼ同じだが下記の違いがある。
     *
     * - あくまで文字列として処理する
     *     - 例えば class_namespace は get_class されるが、この関数は（いうなれば） strval される
     * - \\ を trim しないし、特別扱いもしない
     *     - `ns\\hoge` と `\\ns\\hoge` で返り値が微妙に異なる
     *     - `ns\\` のような場合は名前空間だけを返す
     *
     * Example:
     * ```php
     * that(namespace_split('ns\\hoge'))->isSame(['ns', 'hoge']);
     * that(namespace_split('hoge'))->isSame(['', 'hoge']);
     * that(namespace_split('ns\\'))->isSame(['ns', '']);
     * that(namespace_split('\\hoge'))->isSame(['', 'hoge']);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @return array [namespace, localname]
     */
    function namespace_split(?string $string)
    {
        $pos = strrpos($string, '\\');
        if ($pos === false) {
            return ['', $string];
        }
        return [substr($string, 0, $pos), substr($string, $pos + 1)];
    }
}

assert(!function_exists('ryunosuke\\dbml\\pascal_case') || (new \ReflectionFunction('ryunosuke\\dbml\\pascal_case'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\pascal_case')) {
    /**
     * PascalCase に変換する
     *
     * Example:
     * ```php
     * that(pascal_case('this_is_a_pen'))->isSame('ThisIsAPen');
     * that(pascal_case('this_is-a-pen', '-_'))->isSame('ThisIsAPen');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param string $delimiter デリミタ（複数可）
     * @return string 変換した文字列
     */
    function pascal_case(?string $string, ?string $delimiter = '_')
    {
        $replacemap = array_combine(str_split($delimiter), array_pad([], strlen($delimiter), ' '));
        return strtr(ucwords(strtr($string, $replacemap)), [' ' => '']);
    }
}

assert(!function_exists('ryunosuke\\dbml\\quoteexplode') || (new \ReflectionFunction('ryunosuke\\dbml\\quoteexplode'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\quoteexplode')) {
    /**
     * エスケープやクオートに対応した explode
     *
     * $enclosures は配列で開始・終了文字が別々に指定できるが、実装上の都合で今のところ1文字ずつのみ。
     *
     * Example:
     * ```php
     * // シンプルな例
     * that(quoteexplode(',', 'a,b,c\\,d,"e,f"'))->isSame([
     *     'a', // 普通に分割される
     *     'b', // 普通に分割される
     *     'c\\,d', // \\ でエスケープしているので区切り文字とみなされない
     *     '"e,f"', // "" でクオートされているので区切り文字とみなされない
     * ]);
     *
     * // $enclosures で囲い文字の開始・終了文字を明示できる
     * that(quoteexplode(',', 'a,b,{e,f}', null, ['{' => '}']))->isSame([
     *     'a', // 普通に分割される
     *     'b', // 普通に分割される
     *     '{e,f}', // { } で囲まれているので区切り文字とみなされない
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string|array $delimiter 分割文字列
     * @param string $string 対象文字列
     * @param ?int $limit 分割数。負数未対応
     * @param array|string $enclosures 囲い文字。 ["start" => "end"] で開始・終了が指定できる
     * @param string $escape エスケープ文字
     * @param array $options オプション
     * @return array 分割された配列
     */
    function quoteexplode($delimiter, ?string $string, $limit = null, $enclosures = "'\"", $escape = '\\', $options = [])
    {
        $options += [
            'delim-capture' => false, // デリミタも結果に含まれるようになる
        ];

        if ($limit === null) {
            $limit = PHP_INT_MAX;
        }
        $limit = max(1, $limit);

        $delimiters = arrayize($delimiter);
        $current = 0;
        $result = [];
        for ($i = 0, $l = strlen($string); $i < $l; $i++) {
            if (count($result) === $limit - 1) {
                break;
            }
            $i = strpos_quoted($string, $delimiters, $i, $enclosures, $escape);
            if ($i === null) {
                break;
            }
            foreach ($delimiters as $delimiter) {
                $delimiterlen = strlen($delimiter);
                if (substr_compare($string, $delimiter, $i, $delimiterlen) === 0) {
                    $result[] = substr($string, $current, $i - $current);
                    if ($options['delim-capture']) {
                        $result[] = $delimiter;
                    }
                    $current = $i + $delimiterlen;
                    $i += $delimiterlen - 1;
                    break;
                }
            }
        }
        $result[] = substr($string, $current, $l);
        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\snake_case') || (new \ReflectionFunction('ryunosuke\\dbml\\snake_case'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\snake_case')) {
    /**
     * snake_case に変換する
     *
     * Example:
     * ```php
     * that(snake_case('ThisIsAPen'))->isSame('this_is_a_pen');
     * that(snake_case('URLEncode', '-'))->isSame('u-r-l-encode');     // デフォルトでは略語も分割される
     * that(snake_case('URLEncode', '-', true))->isSame('url-encode'); // 第3引数 true で略語は維持される
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param string $delimiter デリミタ
     * @param bool $keep_abbr すべて大文字の単語を1単語として扱うか
     * @return string 変換した文字列
     */
    function snake_case(?string $string, ?string $delimiter = '_', $keep_abbr = false)
    {
        $pattern = $keep_abbr ? '/[A-Z]([A-Z](?![a-z]))*/' : '/[A-Z]/';
        return ltrim(strtolower(preg_replace($pattern, $delimiter . '\0', $string)), $delimiter);
    }
}

assert(!function_exists('ryunosuke\\dbml\\split_noempty') || (new \ReflectionFunction('ryunosuke\\dbml\\split_noempty'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\split_noempty')) {
    /**
     * 空文字を除外する文字列分割
     *
     * - 空文字を任意の区切り文字で分割しても常に空配列
     * - キーは連番で返す（歯抜けがないただの配列）
     *
     * $triming を指定した場合、結果配列にも影響する。
     * つまり「除外は trim したいが結果配列にはしたくない」はできない。
     *
     * Example:
     * ```php
     * that(split_noempty(',', 'a, b, c'))->isSame(['a', 'b', 'c']);
     * that(split_noempty(',', 'a, , , b, c'))->isSame(['a', 'b', 'c']);
     * that(split_noempty(',', 'a, , , b, c', false))->isSame(['a', ' ', ' ', ' b', ' c']);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $delimiter 区切り文字
     * @param string $string 対象文字
     * @param string|bool $trimchars 指定した文字を trim する。true を指定すると trim する
     * @return array 指定文字で分割して空文字を除いた配列
     */
    function split_noempty(?string $delimiter, ?string $string, $trimchars = true)
    {
        // trim しないなら preg_split(PREG_SPLIT_NO_EMPTY) で十分
        if (strlen($trimchars) === 0) {
            return preg_split('#' . preg_quote($delimiter, '#') . '#u', $string, -1, PREG_SPLIT_NO_EMPTY);
        }

        // trim するなら preg_split だと無駄にややこしくなるのでベタにやる
        $trim = ($trimchars === true) ? 'trim' : fn($v) => trim($v, $trimchars);
        $parts = explode($delimiter, $string);
        $parts = array_map($trim, $parts);
        $parts = array_filter($parts, 'strlen');
        $parts = array_values($parts);
        return $parts;
    }
}

assert(!function_exists('ryunosuke\\dbml\\starts_with') || (new \ReflectionFunction('ryunosuke\\dbml\\starts_with'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\starts_with')) {
    /**
     * 指定文字列で始まるか調べる
     *
     * $with に配列を渡すといずれかで始まるときに true を返す。
     *
     * Example:
     * ```php
     * that(starts_with('abcdef', 'abc'))->isTrue();
     * that(starts_with('abcdef', 'ABC', true))->isTrue();
     * that(starts_with('abcdef', 'xyz'))->isFalse();
     * that(starts_with('abcdef', ['a', 'b', 'c']))->isTrue();
     * that(starts_with('abcdef', ['x', 'y', 'z']))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 探される文字列
     * @param string|string[] $with 探す文字列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return bool 指定文字列で始まるなら true を返す
     */
    function starts_with(?string $string, $with, $case_insensitivity = false)
    {
        foreach ((array) $with as $w) {
            $w = (string) $w;

            // All strings end with the empty string
            if ($w === '') {
                return true;
            }

            if (str_equals(substr($string, 0, strlen($w)), $w, $case_insensitivity)) {
                return true;
            }
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\dbml\\str_between') || (new \ReflectionFunction('ryunosuke\\dbml\\str_between'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\str_between')) {
    /**
     * 指定文字で囲まれた文字列を取得する
     *
     * $from, $to で指定した文字間を取得する（$from, $to 自体は結果に含まれない）。
     * ネストしている場合、一番外側の文字間を返す。
     *
     * $enclosure で「特定文字に囲まれている」場合を無視することができる。
     * $escape で「特定文字が前にある」場合を無視することができる。
     *
     * $position を与えた場合、その場所から走査を開始する。
     * さらに結果があった場合、 $position には「次の走査開始位置」が代入される。
     * これを使用すると連続で「次の文字, 次の文字, ...」と言った動作が可能になる。
     *
     * Example:
     * ```php
     * // $position を利用して "first", "second", "third" を得る（"で囲まれた "blank" は返ってこない）。
     * that(str_between('{first} and {second} and "{blank}" and {third}', '{', '}', $n))->isSame('first');
     * that(str_between('{first} and {second} and "{blank}" and {third}', '{', '}', $n))->isSame('second');
     * that(str_between('{first} and {second} and "{blank}" and {third}', '{', '}', $n))->isSame('third');
     * // ネストしている場合は最も外側を返す
     * that(str_between('{nest1{nest2{nest3}}}', '{', '}'))->isSame('nest1{nest2{nest3}}');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param string $from 開始文字列
     * @param string $to 終了文字列
     * @param int $position 開始位置。渡した場合次の開始位置が設定される
     * @param string $enclosure 囲い文字。この文字中にいる $from, $to 文字は走査外になる
     * @param string $escape エスケープ文字。この文字が前にある $from, $to 文字は走査外になる
     * @return ?string $from, $to で囲まれた文字。見つからなかった場合は null
     */
    function str_between(?string $string, ?string $from, ?string $to, &$position = 0, $enclosure = '\'"', $escape = '\\')
    {
        $strlen = strlen($string);
        $fromlen = strlen($from);
        $tolen = strlen($to);
        $position = intval($position);
        $nesting = 0;
        $start = null;
        for ($i = $position; $i < $strlen; $i++) {
            $i = strpos_quoted($string, [$from, $to], $i, $enclosure, $escape);
            if ($i === null) {
                break;
            }

            // 開始文字と終了文字が重複している可能性があるので $to からチェックする
            if (substr_compare($string, $to, $i, $tolen) === 0) {
                if (--$nesting === 0) {
                    $position = $i + $tolen;
                    return substr($string, $start, $i - $start);
                }
                // いきなり終了文字が来た場合は無視する
                if ($nesting < 0) {
                    $nesting = 0;
                }
            }
            if (substr_compare($string, $from, $i, $fromlen) === 0) {
                if ($nesting++ === 0) {
                    $start = $i + $fromlen;
                }
            }
        }
        return null;
    }
}

assert(!function_exists('ryunosuke\\dbml\\str_chop') || (new \ReflectionFunction('ryunosuke\\dbml\\str_chop'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\str_chop')) {
    /**
     * 先頭・末尾の指定文字列を削ぎ落とす
     *
     * Example:
     * ```php
     * // 文字列からパス文字列と拡張子を削ぎ落とす
     * $PATH = '/path/to/something';
     * that(str_chop("$PATH/hoge.php", "$PATH/", '.php'))->isSame('hoge');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param string $prefix 削ぎ落とす先頭文字列
     * @param string $suffix 削ぎ落とす末尾文字列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return string 削ぎ落とした文字列
     */
    function str_chop(?string $string, ?string $prefix = '', ?string $suffix = '', $case_insensitivity = false)
    {
        $pattern = [];
        if (strlen($prefix)) {
            $pattern[] = '(\A' . preg_quote($prefix, '#') . ')';
        }
        if (strlen($suffix)) {
            $pattern[] = '(' . preg_quote($suffix, '#') . '\z)';
        }
        $flag = 'u' . ($case_insensitivity ? 'i' : '');
        return preg_replace('#' . implode('|', $pattern) . '#' . $flag, '', $string);
    }
}

assert(!function_exists('ryunosuke\\dbml\\str_ellipsis') || (new \ReflectionFunction('ryunosuke\\dbml\\str_ellipsis'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\str_ellipsis')) {
    /**
     * 文字列を指定数に丸める
     *
     * mb_strimwidth と似ているが、省略文字の差し込み位置を $pos で指定できる。
     * $pos は負数が指定できる。負数の場合後ろから数えられる。
     * 省略した場合は真ん中となる。
     *
     * Example:
     * ```php
     * // 8文字に丸める（$pos 省略なので真ん中が省略される）
     * that(str_ellipsis('1234567890', 8, '...'))->isSame('12...890');
     * // 8文字に丸める（$pos=1 なので1文字目から省略される）
     * that(str_ellipsis('1234567890', 8, '...', 1))->isSame('1...7890');
     * // 8文字に丸める（$pos=-1 なので後ろから1文字目から省略される）
     * that(str_ellipsis('1234567890', 8, '...', -1))->isSame('1234...0');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param int $width 丸める幅
     * @param string $trimmarker 省略文字列
     * @param int|null $pos 省略記号の差し込み位置
     * @return string 丸められた文字列
     */
    function str_ellipsis(?string $string, $width, $trimmarker = '...', $pos = null)
    {
        $strlen = mb_strlen($string);
        if ($strlen <= $width) {
            return $string;
        }

        $markerlen = mb_strlen($trimmarker);
        if ($markerlen >= $width) {
            return $trimmarker;
        }

        $length = $width - $markerlen;
        $pos ??= (int) ($length / 2);
        if ($pos < 0) {
            $pos += $length;
        }
        $pos = max(0, min($pos, $length));

        return mb_substr_replace($string, $trimmarker, $pos, $strlen - $length);
    }
}

assert(!function_exists('ryunosuke\\dbml\\str_equals') || (new \ReflectionFunction('ryunosuke\\dbml\\str_equals'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\str_equals')) {
    /**
     * 文字列比較の関数版
     *
     * 文字列以外が与えられた場合は常に false を返す。ただし __toString を実装したオブジェクトは別。
     *
     * Example:
     * ```php
     * that(str_equals('abc', 'abc'))->isTrue();
     * that(str_equals('abc', 'ABC', true))->isTrue();
     * that(str_equals('\0abc', '\0abc'))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $str1 文字列1
     * @param string $str2 文字列2
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return bool 同じ文字列なら true
     */
    function str_equals($str1, $str2, $case_insensitivity = false)
    {
        // __toString 実装のオブジェクトは文字列化する（strcmp がそうなっているから）
        if (is_object($str1) && method_exists($str1, '__toString')) {
            $str1 = (string) $str1;
        }
        if (is_object($str2) && method_exists($str2, '__toString')) {
            $str2 = (string) $str2;
        }

        // この関数は === の関数版という位置づけなので例外は投げないで不一致とみなす
        if (!is_string($str1) || !is_string($str2)) {
            return false;
        }

        if ($case_insensitivity) {
            return strcasecmp($str1, $str2) === 0;
        }

        return $str1 === $str2;
    }
}

assert(!function_exists('ryunosuke\\dbml\\str_exists') || (new \ReflectionFunction('ryunosuke\\dbml\\str_exists'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\str_exists')) {
    /**
     * 指定文字列を含むか返す
     *
     * Example:
     * ```php
     * that(str_exists('abc', 'b'))->isTrue();
     * that(str_exists('abc', 'B', true))->isTrue();
     * that(str_exists('abc', ['b', 'x'], false, false))->isTrue();
     * that(str_exists('abc', ['b', 'x'], false, true))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $haystack 対象文字列
     * @param string|array $needle 調べる文字列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @param bool $and_flag すべて含む場合に true を返すか
     * @return bool $needle を含むなら true
     */
    function str_exists(?string $haystack, $needle, $case_insensitivity = false, $and_flag = false)
    {
        if (!is_array($needle)) {
            $needle = [$needle];
        }

        $needle = array_filter(array_map('strval', $needle), 'strlen');

        foreach ($needle as $str) {
            $pos = $case_insensitivity ? stripos($haystack, $str) : strpos($haystack, $str);
            if ($and_flag && $pos === false) {
                return false;
            }
            if (!$and_flag && $pos !== false) {
                return true;
            }
        }
        return !!$and_flag;
    }
}

assert(!function_exists('ryunosuke\\dbml\\str_lchop') || (new \ReflectionFunction('ryunosuke\\dbml\\str_lchop'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\str_lchop')) {
    /**
     * 先頭の指定文字列を削ぎ落とす
     *
     * Example:
     * ```php
     * // 文字列からパス文字列を削ぎ落とす
     * $PATH = '/path/to/something';
     * that(str_lchop("$PATH/hoge.php", "$PATH/"))->isSame('hoge.php');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param string $prefix 削ぎ落とす先頭文字列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return string 削ぎ落とした文字列
     */
    function str_lchop(?string $string, ?string $prefix, $case_insensitivity = false)
    {
        return str_chop($string, $prefix, '', $case_insensitivity);
    }
}

assert(!function_exists('ryunosuke\\dbml\\str_quote') || (new \ReflectionFunction('ryunosuke\\dbml\\str_quote'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\str_quote')) {
    /**
     * 文字列をダブルクォート文字列に変換する
     *
     * 文字ではうまく表現できないが、例えば「本当の改行」が \n になり、「本当のタブ文字」が \t になる。
     * コントロール文字は "\code" 形式のようになる。
     * 「得られた文字列は eval すると元に戻る」とでも言えばいいか。
     *
     * 制御文字をそのまま出力するとまずい状況が稀によくある（特に行指向媒体への改行文字）。
     * この関数を通せば php の文字列の体裁を保ったまま1行化できる。
     * 端的に言えば var_export の文字列特化版。
     *
     * 挙動は $options である程度制御可能。
     * 各 $options は原則的に文字のマップか true を渡す（true の場合はデフォルトが使用される）。
     * 一部、それ以外の値・型に対応しているものもある。
     *
     * - escape-character: 制御文字のうち、明確なエスケープシーケンスが存在する場合はそれを使用する
     *   - control-character にオーバーラップするがこちらが優先される
     * - control-character: 00 ～ 1F+7F の制御文字を \code 形式にする
     *   - 文字列で "oct", "hex", "HEX" も指定できる。その場合それぞれ \oct, \xhex, \xHEX 形式になる
     * - special-character: ダブルクオート内の文字列が文字列であるための変換を行う
     *   - 原則的にデフォルトに任せて指定すべきではない
     *
     * Example:
     * ```php
     * // （非常に分かりにくいが）下記のように変換される
     * that(str_quote("\$a\nb\rc\x00"))->isSame("\"\\\$a\\nb\\rc\\0\"");
     * // 文字としての意味は一緒であり要するに表現形式の違いなので、php の世界で eval すれば元の文字列に戻る
     * that(eval('return ' . str_quote("\$a\nb\rc\x00") . ';'))->isSame("\$a\nb\rc\x00");
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param array $options オプション配列
     * @return string クォート文字列
     */
    function str_quote(string $string, array $options = []): string
    {
        $options += [
            'escape-character'  => true,
            'control-character' => true,
            'special-character' => true,
            'heredoc'           => '',
            'nowdoc'            => '',
            'indent'            => 0,
        ];

        assert(!($options['heredoc'] && $options['nowdoc']));

        // nowdoc にエスケープは存在しないのでそのまま埋め込む（その結果壊れてもこの関数の責務ではない）
        if (strlen($options['nowdoc'])) {
            $indent = str_repeat(" ", $options['indent']);
            $string = preg_replace('#(\R)#u', '$1' . $indent, $string);
            return "<<<'{$options['nowdoc']}'\n{$indent}{$string}\n{$indent}{$options['nowdoc']}";
        }

        // @see https://www.php.net/manual/ja/language.types.string.php#language.types.string.syntax.double
        $special_chars = [
            '\\' => '\\\\', // バックスラッシュ
            '"'  => '\\"',  // 二重引用符
            '$'  => '\\$',  // ドル記号
        ];
        $escape_chars = [
            "\11" => '\\t', // 水平タブ (HT またはアスキーの 0x09 (9))
            "\12" => '\\n', // ラインフィード (LF またはアスキーの 0x0A (10))
            "\13" => '\\v', // 垂直タブ (VT またはアスキーの 0x0B (11))
            "\14" => '\\f', // フォームフィード (FF またはアスキーの 0x0C (12))
            "\15" => '\\r', // キャリッジリターン (CR またはアスキーの 0x0D (13))
            "\33" => '\\e', // エスケープ (ESC あるいはアスキーの 0x1B (27))
        ];
        $control_chars = [
            "\0"   => "\\0",
            "\1"   => "\\1",
            "\2"   => "\\2",
            "\3"   => "\\3",
            "\4"   => "\\4",
            "\5"   => "\\5",
            "\6"   => "\\6",
            "\7"   => "\\7",
            "\10"  => "\\10",
            "\11"  => "\\11",
            "\12"  => "\\12",
            "\13"  => "\\13",
            "\14"  => "\\14",
            "\15"  => "\\15",
            "\16"  => "\\16",
            "\17"  => "\\17",
            "\20"  => "\\20",
            "\21"  => "\\21",
            "\22"  => "\\22",
            "\23"  => "\\23",
            "\24"  => "\\24",
            "\25"  => "\\25",
            "\26"  => "\\26",
            "\27"  => "\\27",
            "\30"  => "\\30",
            "\31"  => "\\31",
            "\32"  => "\\32",
            "\33"  => "\\33",
            "\34"  => "\\34",
            "\35"  => "\\35",
            "\36"  => "\\36",
            "\37"  => "\\37",
            "\177" => "\\177",
        ];

        // heredoc 用の特殊処理（タイプ可能な文字はエスケープしなくてもよいだろう）
        if (strlen($options['heredoc'])) {
            $control_chars = array_diff_key($control_chars, $escape_chars);
            $escape_chars = [];
            unset($special_chars['"']);
        }

        $charmap = [];
        if ($options['special-character']) {
            $charmap += is_array($options['special-character']) ? $options['special-character'] : $special_chars;
        }
        if ($options['escape-character']) {
            $charmap += is_array($options['escape-character']) ? $options['escape-character'] : $escape_chars;
        }
        if ($options['control-character']) {
            if ($options['control-character'] === 'oct') {
                // デフォで oct にしてあるので変換不要
                assert(end($control_chars) === "\\177");
            }
            if ($options['control-character'] === 'hex') {
                $control_chars = array_map(fn($v) => sprintf('\\x%02x', octdec(trim($v, '\\'))), $control_chars);
            }
            if ($options['control-character'] === 'HEX') {
                $control_chars = array_map(fn($v) => sprintf('\\x%02X', octdec(trim($v, '\\'))), $control_chars);
            }
            $charmap += is_array($options['control-character']) ? $options['control-character'] : $control_chars;
        }

        $string = strtr($string, $charmap);

        if (strlen($options['heredoc'])) {
            $indent = str_repeat(" ", $options['indent']);
            $string = preg_replace('#(\R)#u', '$1' . $indent, $string);
            return "<<<{$options['heredoc']}\n{$indent}{$string}\n{$indent}{$options['heredoc']}";
        }

        return '"' . $string . '"';
    }
}

assert(!function_exists('ryunosuke\\dbml\\str_subreplace') || (new \ReflectionFunction('ryunosuke\\dbml\\str_subreplace'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\str_subreplace')) {
    /**
     * 指定文字列を置換する
     *
     * $subject 内の $search を $replaces に置換する。
     * str_replace とは「N 番目のみ置換できる」点で異なる。
     * つまり、$search='hoge', $replace=[2 => 'fuga'] とすると「2 番目の 'hoge' が 'fuga' に置換される」という動作になる（0 ベース）。
     *
     * $replace に 非配列を与えた場合は配列化される。
     * つまり `$replaces = 'hoge'` は `$replaces = [0 => 'hoge']` と同じ（最初のマッチを置換する）。
     *
     * $replace に空配列を与えると何もしない。
     * 負数キーは後ろから数える動作となる。
     * また、置換後の文字列は置換対象にはならない。
     *
     * N 番目の検索文字列が見つからない場合は例外を投げる。
     * ただし、文字自体が見つからない場合は投げない。
     *
     * Example:
     * ```php
     * // 1番目（0ベースなので2番目）の x を X に置換
     * that(str_subreplace('xxx', 'x', [1 => 'X']))->isSame('xXx');
     * // 0番目（最前列）の x を Xa に、-1番目（最後尾）の x を Xz に置換
     * that(str_subreplace('!xxx!', 'x', [0 => 'Xa', -1 => 'Xz']))->isSame('!XaxXz!');
     * // 置換結果は置換対象にならない
     * that(str_subreplace('xxx', 'x', [0 => 'xxx', 1 => 'X']))->isSame('xxxXx');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $subject 対象文字列
     * @param string $search 検索文字列
     * @param array|string $replaces 置換文字列配列（単一指定は配列化される）
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return string 置換された文字列
     */
    function str_subreplace(?string $subject, ?string $search, $replaces, $case_insensitivity = false)
    {
        $replaces = is_iterable($replaces) ? $replaces : [$replaces];

        // 空はそのまま返す
        if (is_empty($replaces)) {
            return $subject;
        }

        // 負数対応のために逆数計算（ついでに整数チェック）
        $subcount = $case_insensitivity ? substr_count(strtolower($subject), strtolower($search)) : substr_count($subject, $search);
        if ($subcount === 0) {
            return $subject;
        }
        $mapping = [];
        foreach ($replaces as $n => $replace) {
            $origN = $n;
            if (!is_int($n)) {
                throw new \InvalidArgumentException('$replaces key must be integer.');
            }
            if ($n < 0) {
                $n += $subcount;
            }
            if (!(0 <= $n && $n < $subcount)) {
                throw new \InvalidArgumentException("notfound search string '$search' of {$origN}th.");
            }
            $mapping[$n] = $replace;
        }
        $maxseq = max(array_keys($mapping));
        $offset = 0;
        for ($n = 0; $n <= $maxseq; $n++) {
            $pos = $case_insensitivity ? stripos($subject, $search, $offset) : strpos($subject, $search, $offset);
            if (isset($mapping[$n])) {
                $subject = substr_replace($subject, $mapping[$n], $pos, strlen($search));
                $offset = $pos + strlen($mapping[$n]);
            }
            else {
                $offset = $pos + strlen($search);
            }
        }
        return $subject;
    }
}

assert(!function_exists('ryunosuke\\dbml\\strpos_array') || (new \ReflectionFunction('ryunosuke\\dbml\\strpos_array'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\strpos_array')) {
    /**
     * 複数の文字列で strpos する
     *
     * $needles のそれぞれの位置を配列で返す。
     * ただし、見つからなかった文字は結果に含まれない。
     *
     * Example:
     * ```php
     * // 見つかった位置を返す
     * that(strpos_array('hello world', ['hello', 'world']))->isSame([
     *     0 => 0,
     *     1 => 6,
     * ]);
     * // 見つからない文字は含まれない
     * that(strpos_array('hello world', ['notfound', 'world']))->isSame([
     *     1 => 6,
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $haystack 対象文字列
     * @param iterable $needles 位置を取得したい文字列配列
     * @param int $offset 開始位置
     * @return array $needles それぞれの位置配列
     */
    function strpos_array(?string $haystack, $needles, $offset = 0)
    {
        if ($offset < 0) {
            $offset += strlen($haystack);
        }

        $result = [];
        foreach (arrayval($needles, false) as $key => $needle) {
            $pos = strpos($haystack, $needle, $offset);
            if ($pos !== false) {
                $result[$key] = $pos;
            }
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\strpos_escaped') || (new \ReflectionFunction('ryunosuke\\dbml\\strpos_escaped'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\strpos_escaped')) {
    /**
     * エスケープを考慮して strpos する
     *
     * 文字列中のエスケープ中でない生の文字を検索する。
     * 例えば `"abc\nxyz"` という文字列で `"n"` という文字は存在しないとみなす。
     * `"\n"` は改行のエスケープシーケンスであり、 `"n"` という文字ではない（エスケープシーケンスとして "n" を流用しているだけ）。
     * 逆に `"\\n"` はバックスラッシュと `"n"` という文字であり `"n"` が存在する。
     * 簡単に言えば「直前にバックスラッシュがある場合はヒットしない strpos」である。
     * バックスラッシュは $escape 引数で指定可能。
     *
     * $needle 自体にエスケープ文字を含む場合、反対の意味で検索する。
     * つまり、「直前にバックスラッシュがある場合のみヒットする strpos」になる。
     *
     * $offset 引数を指定するとその位置から探索を開始するが、戻り読みはしないのでエスケープ文字の真っ只中を指定する場合は注意。
     * 例えば `"\n"` は改行文字だけであるが、offset に 1 に指定して "n" を探すとマッチする。
     *
     * Example:
     * ```php
     * # 分かりにくいので \ ではなく % をエスケープ文字とする
     * $defargs = [0, '%'];
     *
     * // これは null である（"%d" という文字の列であるため "d" という文字は存在しない）
     * that(strpos_escaped('%d', 'd', ...$defargs))->isSame(null);
     * // これは 2 である（"%" "d" という文字の列であるため（d の前の % は更にその前の % に呑まれておりメタ文字ではない））
     * that(strpos_escaped('%%d', 'd', ...$defargs))->isSame(2);
     *
     * // これは 0 である（% をつけて検索するとそのエスケープシーケンス的なものそのものを探すため）
     * that(strpos_escaped('%d', '%d', ...$defargs))->isSame(0);
     * // これは null である（"%" "d" という文字の列であるため "%d" という文字は存在しない）
     * that(strpos_escaped('%%d', '%d', ...$defargs))->isSame(null);
     * // これは 2 である（"%" "%d" という文字の列であるため）
     * that(strpos_escaped('%%%d', '%d', ...$defargs))->isSame(2);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $haystack 対象文字列
     * @param string|array $needle 探す文字
     * @param int $offset 開始位置
     * @param string $escape エスケープ文字
     * @param ?string $found 見つかった文字が格納される
     * @return ?int 見つかった位置
     */
    function strpos_escaped(?string $haystack, $needle, $offset = 0, $escape = '\\', &$found = null)
    {
        $q_escape = preg_quote($escape, '#');
        if (is_stringable($needle)) {
            $needle = preg_split("#($q_escape?.)#u", $needle, -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);
        }

        $needles = arrayval($needle);
        assert(!in_array($escape, $needles, true), sprintf('$needle must not contain only escape charactor ("%s")', implode(', ', $needles)));

        $matched = [];
        foreach (array_map(fn($c) => preg_quote($c, '#'), $needles) as $need) {
            if (preg_match_all("#((?:$q_escape)*?)($need)#u", $haystack, $matches, PREG_OFFSET_CAPTURE | PREG_SET_ORDER, $offset)) {
                foreach ($matches as [, $m_escape, $m_needle]) {
                    if ((strlen($m_escape[0]) / strlen($escape)) % 2 === 0) {
                        $matched[$m_needle[1]] ??= $m_needle[0];
                    }
                }
            }
        }
        if (!$matched) {
            $found = null;
            return null;
        }

        ksort($matched);
        $min = array_key_first($matched);
        $found = $matched[$min];
        return $min;
    }
}

assert(!function_exists('ryunosuke\\dbml\\strpos_quoted') || (new \ReflectionFunction('ryunosuke\\dbml\\strpos_quoted'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\strpos_quoted')) {
    /**
     * クオートを考慮して strpos する
     *
     * Example:
     * ```php
     * // クオート中は除外される
     * that(strpos_quoted('hello "this" is world', 'is'))->isSame(13);
     * // 開始位置やクオート文字は指定できる（5文字目以降の \* に囲まれていない hoge の位置を返す）
     * that(strpos_quoted('1:hoge, 2:*hoge*, 3:hoge', 'hoge', 5, '*'))->isSame(20);
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $haystack 対象文字列
     * @param string|iterable $needle 位置を取得したい文字列
     * @param int $offset 開始位置
     * @param string|array $enclosure 囲い文字。この文字中にいる $from, $to 文字は走査外になる
     * @param string $escape エスケープ文字。この文字が前にある $from, $to 文字は走査外になる
     * @param ?string $found $needle の内、見つかった文字列が格納される
     * @return ?int $needle の位置
     */
    function strpos_quoted(?string $haystack, $needle, $offset = 0, $enclosure = "'\"", $escape = '\\', &$found = null)
    {
        if (is_string($enclosure)) {
            if (strlen($enclosure)) {
                $chars = str_split($enclosure);
                $enclosure = array_combine($chars, $chars);
            }
            else {
                $enclosure = [];
            }
        }
        $needles = arrayval($needle, false);

        $strlen = strlen($haystack);

        if ($offset < 0) {
            $offset += $strlen;
        }

        $found = null;
        $enclosing = [];
        for ($i = $offset; $i < $strlen; $i++) {
            if ($i !== 0 && $haystack[$i - 1] === $escape) {
                continue;
            }
            foreach ($enclosure as $start => $end) {
                if (substr_compare($haystack, $end, $i, strlen($end)) === 0) {
                    if ($enclosing && $enclosing[count($enclosing) - 1] === $end) {
                        array_pop($enclosing);
                        $i += strlen($end) - 1;
                        continue 2;
                    }
                }
                if (substr_compare($haystack, $start, $i, strlen($start)) === 0) {
                    $enclosing[] = $end;
                    $i += strlen($start) - 1;
                    continue 2;
                }
            }

            if (empty($enclosing)) {
                foreach ($needles as $needle) {
                    if (substr_compare($haystack, $needle, $i, strlen($needle)) === 0) {
                        $found = $needle;
                        return $i;
                    }
                }
            }
        }
        return null;
    }
}

assert(!function_exists('ryunosuke\\dbml\\strtr_escaped') || (new \ReflectionFunction('ryunosuke\\dbml\\strtr_escaped'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\strtr_escaped')) {
    /**
     * エスケープを考慮して strtr する
     *
     * 「エスケープ」についての詳細は strpos_escaped を参照。
     *
     * $replace_pairs は [from => to] な配列を指定する。
     * to がクロージャの場合はキーとオフセットでコールバックされる。
     *
     * strtr と同様、最も長いキーから置換を行い、置換後の文字列は対象にならない。
     *
     * Example:
     * ```php
     * # 分かりにくいので \ ではなく % をエスケープ文字とする
     * that(strtr_escaped('XYZ ab %% %s', [
     *     'ab'  => 'AB',  // 2. 1 で置換された文字は対象にならない
     *     'A'   => '%a',  // 使われない
     *     'Z'   => '%z',  // 使われない
     *     '%%'  => 'p',   // 普通に置換される
     *     's'   => 'S',   // エスケープが対象なので置換されない（%s は文字 "s" ではない（\n が文字 "n" ではないのと同じ））
     *     'XYZ' => 'abc', // 1. 後ろにあるがまず置換される
     * ], '%'))->isSame('abc AB p %s');
     * ```
     *
     * @package ryunosuke\Functions\Package\strings
     *
     * @param string $string 対象文字列
     * @param array $replace_pairs 置換するペア
     * @param string $escape エスケープ文字
     * @return string 置換された文字列
     */
    function strtr_escaped(?string $string, $replace_pairs, $escape = '\\')
    {
        uksort($replace_pairs, fn($a, $b) => strlen($b) - strlen($a));
        $froms = array_keys($replace_pairs);

        $offset = 0;
        while (($pos = strpos_escaped($string, $froms, $offset, $escape, $found)) !== null) {
            $to = $replace_pairs[$found];
            $replaced = $to instanceof \Closure ? $to($found, $pos) : $to;
            $string = substr_replace($string, $replaced, $pos, strlen($found));
            $offset = $pos + strlen($replaced);
        }
        return $string;
    }
}

assert(!function_exists('ryunosuke\\dbml\\blank_if') || (new \ReflectionFunction('ryunosuke\\dbml\\blank_if'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\blank_if')) {
    /**
     * 値が空なら null を返す
     *
     * `is_empty($value) ? $value : null` とほぼ同じ。
     * 言ってしまえば「falsy な値を null に変換する」とも言える。
     *
     * ここでいう falsy とは php 標準の `empty` ではなく本ライブラリの `is_empty` であることに留意（"0" は空ではない）。
     * さらに利便性のため 0, 0.0 も空ではない判定をする（strpos や array_search などで「0 は意味のある値」という事が多いので）。
     * 乱暴に言えば「仮に文字列化したとき、情報量がゼロ」が falsy になる。
     *
     * - 「 `$var ?: 'default'` で十分なんだけど "0" が…」
     * - 「 `$var ?? 'default'` で十分なんだけど false が…」
     *
     * という状況はまれによくあるはず。
     *
     * ?? との親和性のため null を返す動作がデフォルトだが、そのデフォルト値は引数で渡すこともできる。
     * 用途は Example を参照。
     *
     * Example:
     * ```php
     * // falsy な値は null を返すので null 合体演算子でデフォルト値が得られる
     * that(blank_if(null) ?? 'default')->isSame('default');
     * that(blank_if('')   ?? 'default')->isSame('default');
     * // falsy じゃない値の場合は引数をそのまま返すので null 合体演算子には反応しない
     * that(blank_if(0)   ?? 'default')->isSame(0);   // 0 は空ではない
     * that(blank_if('0') ?? 'default')->isSame('0'); // "0" は空ではない
     * that(blank_if(1)   ?? 'default')->isSame(1);
     * that(blank_if('X') ?? 'default')->isSame('X');
     * // 第2引数で返る値を指定できるので下記も等価となる。ただし、php の仕様上第2引数が必ず評価されるため、関数呼び出しなどだと無駄な処理となる
     * that(blank_if(null, 'default'))->isSame('default');
     * that(blank_if('',   'default'))->isSame('default');
     * that(blank_if(0,    'default'))->isSame(0);
     * that(blank_if('0',  'default'))->isSame('0');
     * that(blank_if(1,    'default'))->isSame(1);
     * that(blank_if('X',  'default'))->isSame('X');
     * // 第2引数の用途は少し短く書けることと演算子の優先順位のつらみの回避程度（`??` は結構優先順位が低い。下記を参照）
     * that(0 < blank_if(null) ?? 1)->isFalse();  // (0 < null) ?? 1 となるので false
     * that(0 < blank_if(null, 1))->isTrue();     // 0 < 1 となるので true
     * that(0 < (blank_if(null) ?? 1))->isTrue(); // ?? で同じことしたいならこのように括弧が必要
     *
     * # ここから下は既存言語機構との比較（愚痴っぽいので読まなくてもよい）
     *
     * // エルビス演算子は "0" にも反応するので正直言って使いづらい（php における falsy の定義は広すぎる）
     * that(null ?: 'default')->isSame('default');
     * that(''   ?: 'default')->isSame('default');
     * that(1    ?: 'default')->isSame(1);
     * that('0'  ?: 'default')->isSame('default'); // こいつが反応してしまう
     * that('X'  ?: 'default')->isSame('X');
     * // 逆に null 合体演算子は null にしか反応しないので微妙に使い勝手が悪い（php の標準関数が false を返したりするし）
     * that(null ?? 'default')->isSame('default'); // こいつしか反応しない
     * that(''   ?? 'default')->isSame('');
     * that(1    ?? 'default')->isSame(1);
     * that('0'  ?? 'default')->isSame('0');
     * that('X'  ?? 'default')->isSame('X');
     * // 恣意的な例だが、 array_search は false も 0 も返し得るので ?: は使えない。 null を返すこともないので ?? も使えない（エラーも吐かない）
     * that(array_search('a', ['a', 'b', 'c']) ?: 'default')->isSame('default'); // 見つかったのに 0 に反応するので 'default' になってしまう
     * that(array_search('x', ['a', 'b', 'c']) ?? 'default')->isSame(false);     // 見つからないので 'default' としたいが false になってしまう
     * // 要するに単に「見つからなかった場合に 'default' としたい」だけなんだが、下記のようにめんどくさいことをせざるを得ない
     * that(array_search('x', ['a', 'b', 'c']) === false ? 'default' : array_search('x', ['a', 'b', 'c']))->isSame('default'); // 3項演算子で2回呼ぶ
     * that(($tmp = array_search('x', ['a', 'b', 'c']) === false) ? 'default' : $tmp)->isSame('default');                      // 一時変数を使用する（あるいは if 文）
     * // このように書きたかった
     * that(blank_if(array_search('x', ['a', 'b', 'c'])) ?? 'default')->isSame('default'); // null 合体演算子版
     * that(blank_if(array_search('x', ['a', 'b', 'c']), 'default'))->isSame('default');   // 第2引数版
     * ```
     *
     * @package ryunosuke\Functions\Package\syntax
     *
     * @param mixed $var 判定する値
     * @param mixed $default 空だった場合のデフォルト値
     * @return mixed 空なら $default, 空じゃないなら $var をそのまま返す
     */
    function blank_if($var, $default = null)
    {
        if (is_object($var)) {
            // 文字列化できるかが優先
            if (is_stringable($var)) {
                return strlen($var) ? $var : $default;
            }
            // 次点で countable
            if (is_countable($var)) {
                return count($var) ? $var : $default;
            }
            return $var;
        }

        // 0, 0.0, "0" は false
        if ($var === 0 || $var === 0.0 || $var === '0') {
            return $var;
        }

        // 上記以外は empty に任せる
        return empty($var) ? $default : $var;
    }
}

assert(!function_exists('ryunosuke\\dbml\\cast') || (new \ReflectionFunction('ryunosuke\\dbml\\cast'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\cast')) {
    /**
     * php の型変換に準じてキャストする
     *
     * 「php の型変換」とは strict_type=0 の時の暗黙の変換を指す（(type)等のキャストではない）。
     * eval で呼び出して判定するため、決して $type に外部入力を渡してはならない。
     *
     * この関数を使うシチュエーションはほぼない。
     * 呼び先のためならそれを普通に呼べば同じエラーになるし、用途が分かっているなら通常のキャストで十分。
     * 「呼び先が型宣言されていない」とか「numeric であることを担保したい」とか、限られた状況でしか使えないし使うべきではない。
     * 通常の(type)キャストが強すぎる（特に int）のため、「エラーになってくれる弱いキャスト」のようなイメージ。
     *
     * Example:
     * ```php
     * # 下記のように変換される
     * that(cast("1", 'int'))->isSame(1);
     * that(cast(1, 'string'))->isSame('1');
     * that(cast(1, 'int|string'))->isSame(1);
     * that(cast([], 'array|ArrayAccess'))->isSame([]);
     * that(cast($ao = new \ArrayObject(), 'ArrayAccess&Countable'))->isSame($ao);
     *
     * # 下記はすべて TypeError になる
     * // cast("hoge", 'int');             // 非数値文字列 は int に変換できない
     * // cast([], 'string');              // array は string に変換できない
     * // cast(new \stdClass(), 'bool');   // object は bool に変換できない
     * ```
     *
     * @package ryunosuke\Functions\Package\syntax
     *
     * @param mixed $value 取得される配列・オブジェクト
     * @param string $type 型文字列
     * @param mixed $default 失敗したときのデフォルト値（null も立派な値なので例外を飛ばすためには未指定時にしなければならない）
     * @return mixed キャストされた値
     */
    function cast($value, string $type, $default = null)
    {
        // 気休め程度だが一応チェック（呼び元の責務なのであんまり厳密にやってもしょうがない）
        if (!preg_match('#^[?\\\\_a-z0-9|&()]+$#i', $type)) {
            throw new \InvalidArgumentException("$type is illegal type");
        }

        // php8.2 の DNF の模倣（8.2 に対応したらまるっと不要）
        if (strpbrk($type, '(&)') !== false) {
            if (!is_typeof($value, $type)) {
                if (func_num_args() === 3) {
                    return $default;
                }
                throw new \TypeError(sprintf("must be of type %s, %s given", $type, get_debug_type($type)));
            }
            // ↑でとりあえずマッチすることは保証されたのであとは変換のために | 繋ぎで呼び出せばよい
            $type = implode('|', preg_split('#([?()|&])#', $type, -1, PREG_SPLIT_NO_EMPTY));
        }

        // 緩い変換なので一部は互換型を追加する必要がある
        $types = array_map(fn($type) => trim(trim($type, '\\')), preg_split('#([?()|&])#', $type, -1, PREG_SPLIT_NO_EMPTY));
        if (in_array('Stringable', $types) && !in_array('string', $types)) {
            $types[] = 'string';
        }
        $type = implode('|', $types);

        // 判定・変換が複雑極まるため実際に投げてその値を返すのが最も間違いが少ない
        static $test_functions = [];
        $test_functions[$type] ??= evaluate("return static fn({$type} \$value) => \$value;");
        try {
            return $test_functions[$type]($value);
        }
        catch (\TypeError $e) {
            if (func_num_args() === 3) {
                return $default;
            }
            throw $e;
        }
    }
}

assert(!function_exists('ryunosuke\\dbml\\instance_of') || (new \ReflectionFunction('ryunosuke\\dbml\\instance_of'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\instance_of')) {
    /**
     * instanceof 構文の関数版
     *
     * ただし、bool ではなく ?object を返す。
     * つまり「instanceof が true ならそのまま、false なら null」を返す。
     * これは ?-> との親和性を考慮している。
     *
     * Example:
     * ```php
     *  // 実質的に下記は同じ
     * $object = new \Exception('message');
     * that(($object instanceof \Exception ? $object : null)?->getMessage())->is('message');
     * that(instance_of($object, \Exception::class)?->getMessage())->is('message');
     *
     * $object = new \stdClass();
     * that(($object instanceof \Exception ? $object : null)?->getMessage())->isNull();
     * that(instance_of($object, \Exception::class)?->getMessage())->isNull();
     * // Exception ではないが null でもないので下記のようにはできない
     * // $object?->getMessage();
     * ```
     *
     * @package ryunosuke\Functions\Package\syntax
     *
     * @template T of object
     * @param T $object 調べるオブジェクト
     * @param string|object $class クラス名
     * @return ?T $object が $class のインスタンスなら $object, そうでなければ null
     */
    function instance_of($object, $class)
    {
        return $object instanceof $class ? $object : null;
    }
}

assert(!function_exists('ryunosuke\\dbml\\base64url_encode') || (new \ReflectionFunction('ryunosuke\\dbml\\base64url_encode'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\base64url_encode')) {
    /**
     * url safe な base64_encode
     *
     * れっきとした RFC があるのかは分からないが '+' => '-', '/' => '_' がデファクトだと思うのでそのようにしてある。
     * パディングの = も外す。
     *
     * @package ryunosuke\Functions\Package\url
     *
     * @param string $string 変換元文字列
     * @return string base64url 文字列
     */
    function base64url_encode($string)
    {
        return rtrim(strtr(base64_encode($string), ['+' => '-', '/' => '_']), '=');
    }
}

assert(!function_exists('ryunosuke\\dbml\\query_parse') || (new \ReflectionFunction('ryunosuke\\dbml\\query_parse'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\query_parse')) {
    /**
     * parse_str の返り値版
     *
     * 標準の parse_str は参照で受ける謎シグネチャなのでそれを返り値に変更したもの。
     * と同時に parse_str はドットやスペースをアンダースコアに置換するため、それを避ける独自実装がある。
     * $arg_separator や $encoding_type を指定すると独自実装で動きかつその引数の挙動でパースされる。
     *
     * Example:
     * ```php
     * // 普通に使えばネイティブの返り値版
     * that(query_parse('a.b=ab&x[y][z]=xyz'))->is([
     *     'a_b' => 'ab',
     *     'x'   => ['y' => ['z' => 'xyz']],
     * ]);
     * // パラメータを渡せば独自実装（& 以外を指定できたり . を維持できたりする）
     * that(query_parse('a.b=ab|x[y][z]=xyz', '|'))->is([
     *     'a.b' => 'ab',
     *     'x'   => ['y' => ['z' => 'xyz']],
     * ]);
     * ```
     *
     * @package ryunosuke\Functions\Package\url
     *
     * @param string $query クエリ文字列
     * @param ?string $arg_separator クエリ文字列
     * @param ?int $encoding_type クエリ文字列
     * @return array クエリのパース結果配列
     */
    function query_parse($query, $arg_separator = null, $encoding_type = null)
    {
        // 指定されていないなら php ネイティブ
        if ($arg_separator === null && $encoding_type === null) {
            parse_str($query, $result);
            return $result;
        }

        $arg_separator ??= ini_get('arg_separator.input');
        $encoding_type ??= PHP_QUERY_RFC1738;

        $params = multiexplode(str_split($arg_separator), $query);
        $result = [];
        foreach ($params as $param) {
            [$name, $value] = explode("=", trim($param), 2) + [1 => ''];
            if ($name === '') {
                continue;
            }
            if ($encoding_type === PHP_QUERY_RFC1738) {
                $name = urldecode($name);
                $value = urldecode($value);
            }
            elseif ($encoding_type === PHP_QUERY_RFC3986) {
                $name = rawurldecode($name);
                $value = rawurldecode($value);
            }

            if (preg_match_all('#\[([^]]*)\]#mu', $name, $matches, PREG_OFFSET_CAPTURE)) {
                $name = substr($name, 0, $matches[0][0][1]);
                $keys = array_column($matches[1], 0);

                $receiver = &$result[$name];
                foreach ($keys as $key) {
                    if (strlen($key) === 0) {
                        if (!is_array($receiver)) {
                            $receiver = [];
                        }
                        $key = max(array_filter(array_keys($receiver ?? []), 'is_int') ?: [-1]) + 1;
                    }
                    $receiver = &$receiver[$key];
                }
            }
            else {
                $receiver = &$result[$name];
            }

            $receiver = $value;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\cache') || (new \ReflectionFunction('ryunosuke\\dbml\\cache'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\cache')) {
    /**
     * シンプルにキャッシュする
     *
     * この関数は get/set/delete を兼ねる。
     * キャッシュがある場合はそれを返し、ない場合は $provider を呼び出してその結果をキャッシュしつつそれを返す。
     *
     * $provider に null を与えるとキャッシュの削除となる。
     *
     * Example:
     * ```php
     * $provider = fn() => rand();
     * // 乱数を返す処理だが、キャッシュされるので同じ値になる
     * $rand1 = cache('rand', $provider);
     * $rand2 = cache('rand', $provider);
     * that($rand1)->isSame($rand2);
     * // $provider に null を与えると削除される
     * cache('rand', null);
     * $rand3 = cache('rand', $provider);
     * that($rand1)->isNotSame($rand3);
     * ```
     *
     * @package ryunosuke\Functions\Package\utility
     * @deprecated delete in future scope
     * @codeCoverageIgnore
     *
     * @param string $key キャッシュのキー
     * @param ?callable $provider キャッシュがない場合にコールされる callable
     * @param ?string $namespace 名前空間
     * @return mixed キャッシュ
     */
    function cache($key, $provider, $namespace = null)
    {
        static $cacheobject;
        $cacheobject ??= new class(function_configure('cachedir')) {
            const CACHE_EXT = '.php-cache';

            /** @var string キャッシュディレクトリ */
            private $cachedir;

            /** @var array 内部キャッシュ */
            private $cache;

            /** @var array 変更感知配列 */
            private $changed;

            public function __construct($cachedir)
            {
                $this->cachedir = $cachedir;
                $this->cache = [];
                $this->changed = [];
            }

            public function __destruct()
            {
                // 変更されているもののみ保存
                foreach ($this->changed as $namespace => $dummy) {
                    $filepath = $this->cachedir . '/' . rawurlencode($namespace) . self::CACHE_EXT;
                    $content = "<?php\nreturn " . var_export($this->cache[$namespace], true) . ";\n";

                    $temppath = tempnam(sys_get_temp_dir(), 'cache');
                    if (file_put_contents($temppath, $content) !== false) {
                        @chmod($temppath, 0644);
                        if (!@rename($temppath, $filepath)) {
                            @unlink($temppath); // @codeCoverageIgnore
                        }
                    }
                }
            }

            public function has($namespace, $key)
            {
                // ファイルから読み込む必要があるので get しておく
                $this->get($namespace, $key);
                return array_key_exists($key, $this->cache[$namespace]);
            }

            public function get($namespace, $key)
            {
                // 名前空間自体がないなら作る or 読む
                if (!isset($this->cache[$namespace])) {
                    $nsarray = [];
                    $cachpath = $this->cachedir . '/' . rawurlencode($namespace) . self::CACHE_EXT;
                    if (file_exists($cachpath)) {
                        $nsarray = require $cachpath;
                    }
                    $this->cache[$namespace] = $nsarray;
                }

                return $this->cache[$namespace][$key] ?? null;
            }

            public function set($namespace, $key, $value)
            {
                // 新しい値が来たら変更フラグを立てる
                if (!isset($this->cache[$namespace]) || !array_key_exists($key, $this->cache[$namespace]) || $this->cache[$namespace][$key] !== $value) {
                    $this->changed[$namespace] = true;
                }

                $this->cache[$namespace][$key] = $value;
            }

            public function delete($namespace, $key)
            {
                $this->changed[$namespace] = true;
                unset($this->cache[$namespace][$key]);
            }

            public function clear()
            {
                // インメモリ情報をクリアして・・・
                $this->cache = [];
                $this->changed = [];

                // ファイルも消す
                foreach (glob($this->cachedir . '/*' . self::CACHE_EXT) as $file) {
                    unlink($file);
                }
            }
        };

        // flush (for test)
        if ($key === null) {
            if ($provider === null) {
                $cacheobject->clear();
            }
            $cacheobject = null;
            return;
        }

        $namespace ??= __FILE__;

        $exist = $cacheobject->has($namespace, $key);
        if ($provider === null) {
            $cacheobject->delete($namespace, $key);
            return $exist;
        }
        if (!$exist) {
            $cacheobject->set($namespace, $key, $provider());
        }
        return $cacheobject->get($namespace, $key);
    }
}

assert(!function_exists('ryunosuke\\dbml\\cache_fetch') || (new \ReflectionFunction('ryunosuke\\dbml\\cache_fetch'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\cache_fetch')) {
    /**
     * psr-16 cache で「無かったらコールバックを実行して set」する
     *
     * @package ryunosuke\Functions\Package\utility
     *
     * @param \Psr\SimpleCache\CacheInterface $cacher キャッシュオブジェクト
     * @param string $key キャッシュキー
     * @param callable $provider データプロバイダ
     * @param ?int $ttl キャッシュ時間
     * @return mixed キャッシュデータ
     */
    function cache_fetch($cacher, $key, $provider, $ttl = null)
    {
        $data = $cacher->get($key);
        if ($data === null) {
            $data = $provider();
            $cacher->set($key, $data, $ttl);
        }
        return $data;
    }
}

assert(!function_exists('ryunosuke\\dbml\\cacheobject') || (new \ReflectionFunction('ryunosuke\\dbml\\cacheobject'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\cacheobject')) {
    /**
     * psr-16 を実装したキャッシュオブジェクトを返す
     *
     * このオブジェクトはあくまで「他のパッケージに依存したくない」場合のデフォルト実装としての使用を想定している。
     *
     * - キャッシュはファイルシステムに保存される
     * - キャッシュキーの . はディレクトリ区切りとして使用される
     * - TTL を指定しなかったときのデフォルト値は約100年（実質無期限だろう）
     * - psr-16 にはない getOrSet(fetch) が生えている（利便性が非常に高く使用頻度が多いため）
     *
     * 性質上、参照されない期限切れキャッシュが溜まり続けるが $clean_probability を渡すと一定確率で削除される。
     * さらに $clean_execution_time を指定すると削除の実行時間が制限される。
     * $clean_probability は 1 が 100%（必ず削除）、 0 が 0%（削除しない）である。
     * 削除処理は軽くはないため高頻度な実行は避けなければならない。
     * clean メソッドが生えているので明示的に呼ぶことも可能。
     *
     * psr/simple-cache （\Psr\SimpleCache\CacheInterface）が存在するなら implement される。
     * 存在しないなら素の無名クラスで返す。
     * 動作に違いはないが instanceoof や class_implements に違いが出てくるので注意。
     *
     * @package ryunosuke\Functions\Package\utility
     *
     * @param ?string $directory キャッシュ保存ディレクトリ
     * @param float $clean_probability 不要キャッシュの削除確率
     * @param ?float $clean_execution_time 不要キャッシュの最大実行時間
     * @return \Cacheobject psr-16 実装オブジェクト
     */
    function cacheobject($directory = null, $clean_probability = 0, $clean_execution_time = null)
    {
        static $cacheobjects = [];

        $cachedir = function_configure('cachedir');

        // 相対パスは cachedir からの相対とする
        if ($directory !== null && !path_is_absolute($directory)) {
            $directory = $cachedir . DIRECTORY_SEPARATOR . strtr($directory, ['\\' => '%']);
        }
        $directory ??= $cachedir;

        $cacheobject = $cacheobjects[$directory] ??= (function ($directory) {
            $cacheobject = new class($directory) {
                private $directory;
                private $entries = [];

                public function __construct(string $directory)
                {
                    assert(strlen($directory));
                    $this->directory = $directory;
                }

                public function __debugInfo()
                {
                    $class = self::class;
                    $props = (array) $this;

                    // 全キャッシュは情報量としてでかすぎるが、何がどこに配置されているかくらいは有ってもいい
                    $ekey = "\0$class\0entries";
                    assert(array_key_exists($ekey, $props));
                    $props[$ekey] = array_reduce(array_keys($props[$ekey]), fn($acc, $k) => $acc + [$k => $this->_getFilename($k)], []);

                    return $props;
                }

                private function _exception(string $message = "", int $code = 0, \Throwable $previous = null): \Throwable
                {
                    return interface_exists(\Psr\SimpleCache\InvalidArgumentException::class)
                        ? new class ( $message, $code, $previous ) extends \InvalidArgumentException implements \Psr\SimpleCache\InvalidArgumentException { }
                        : new class ( $message, $code, $previous ) extends \InvalidArgumentException { };
                }

                private function _validateKey(string $key): void
                {
                    if ($key === '') {
                        throw $this->_exception("\$key is empty string");
                    }
                    if (strpbrk($key, '{}()/\\@:') !== false) {
                        throw $this->_exception("\$key contains reserved character({}()/\\@:)");
                    }
                }

                private function _normalizeTtl($ttl): int
                {
                    if ($ttl === null) {
                        return 60 * 60 * 24 * 365 * 100;
                    }
                    if (is_int($ttl)) {
                        return $ttl;
                    }
                    if ($ttl instanceof \DateInterval) {
                        return (new \DateTime())->setTimestamp(0)->add($ttl)->getTimestamp();
                    }
                    throw $this->_exception("\$ttl must be null|int|DateInterval(" . gettype($ttl) . ")");
                }

                private function _getFilename(string $key): string
                {
                    return $this->directory . DIRECTORY_SEPARATOR . strtr(rawurlencode($key), ['.' => DIRECTORY_SEPARATOR]) . ".php-cache";
                }

                private function _getCacheFilenames(): array
                {
                    return file_list($this->directory, [
                        '!type'     => ['dir', 'link'],
                        'extension' => ['php-cache'],
                    ]) ?? [];
                }

                private function _getMetadata(string $filename): ?array
                {
                    $fp = @fopen($filename, "r");
                    if ($fp === false) {
                        return null;
                    }
                    try {
                        $first = fgets($fp);
                        $meta = @json_decode(substr($first, strpos($first, '#') + 1), true);
                        return $meta ?: null;
                    }
                    finally {
                        fclose($fp);
                    }
                }

                public function keys(?string $pattern = null)
                {
                    $files = $this->_getCacheFilenames();

                    $now = time();
                    $result = [];
                    foreach ($files as $file) {
                        $meta = $this->_getMetadata($file);
                        if ($meta && ($pattern === null || fnmatch($pattern, $meta['key']))) {
                            $result[$meta['key']] = [
                                'realpath' => $file,
                                'size'     => filesize($file),
                                'ttl'      => $meta['expire'] - $now,
                            ];
                        }
                    }
                    return $result;
                }

                public function clean($max_execution_time = null)
                {
                    $files = file_list($this->directory, [
                        '!type' => 'link',
                    ]);

                    set_error_handler(fn() => true);
                    try {
                        $end = microtime(true) + ($max_execution_time ?? 0);
                        foreach ($files as $file) {
                            if ($max_execution_time !== null && microtime(true) >= $end) {
                                break; // @codeCoverageIgnore
                            }
                            if (is_file($file)) {
                                $meta = $this->_getMetadata($file);
                                if (isset($meta['expire']) && $meta['expire'] < time()) {
                                    unset($this->entries[$meta['key']]);
                                    unlink($file);
                                }
                            }
                            elseif (is_dir($file)) {
                                rmdir($file);
                            }
                        }
                    }
                    finally {
                        restore_error_handler();
                    }
                }

                public function fetch($key, $provider, $ttl = null)
                {
                    $value = $this->get($key);
                    if ($value === null) {
                        $value = $provider($this);
                        $this->set($key, $value, $ttl);
                    }
                    return $value;
                }

                public function fetchMultiple($providers, $ttl = null)
                {
                    $result = $this->getMultiple(array_keys($providers));
                    foreach ($providers as $key => $provider) {
                        $result[$key] ??= $this->fetch($key, $provider, $ttl);
                    }
                    return $result;
                }

                public function get($key, $default = null)
                {
                    $this->_validateKey($key);

                    if (!isset($this->entries[$key])) {
                        error_clear_last();
                        $this->entries[$key] = @include $this->_getFilename($key);
                        if (error_get_last() !== null) {
                            $this->entries[$key] = [0, null];
                        }
                    }
                    $entry = $this->entries[$key];
                    if ($entry[0] < time()) {
                        $this->delete($key);
                        return $default;
                    }

                    $this->entries[$key] = $entry;
                    return $entry[1];
                }

                public function set($key, $value, $ttl = null)
                {
                    $this->_validateKey($key);
                    $ttl = $this->_normalizeTtl($ttl);

                    if ($ttl <= 0) {
                        return $this->delete($key);
                    }

                    $expire = time() + $ttl;
                    $this->entries[$key] = [$expire, $value];
                    $meta = json_encode(['key' => $key, 'expire' => $expire]);
                    // var_export3 はあらゆる出力を可能にしているので **読み込み時** のオーバーヘッドがでかく、もし var_export が使えるならその方が格段に速い
                    // しかし要素を再帰的に全舐め（is_exportable）しないと「var_export できるか？」は分からないというジレンマがある
                    // このコンテキストは「キャッシュ」なので書き込み時のオーバーヘッドよりも読み込み時のオーバーヘッドを優先して判定を行っている
                    if (is_exportable($this->entries[$key])) {
                        $code = var_export($this->entries[$key], true);
                    }
                    else {
                        $code = var_export3($this->entries[$key], true);
                    }
                    return !!file_set_contents($this->_getFilename($key), "<?php # $meta\nreturn $code;\n");
                }

                public function delete($key)
                {
                    $this->_validateKey($key);

                    unset($this->entries[$key]);
                    return @unlink($this->_getFilename($key));
                }

                public function provide($provider, ...$args)
                {
                    $provider_hash = (string) new \ReflectionFunction($provider);
                    $cacheid = "autoprovide." . hash('fnv164', $provider_hash);
                    $key = $provider_hash . '@' . serialize($args);

                    $cache = $this->get($cacheid) ?? [];
                    if (!array_key_exists($key, $cache)) {
                        $result = $provider(...$args);
                        if ($result === null) {
                            return null;
                        }
                        $cache[$key] = $result;
                        $this->set($cacheid, $cache);
                    }
                    return $cache[$key];
                }

                public function hash($key, $provider, $ttl = null)
                {
                    $now = time();
                    $args = is_iterable($key) ? $key : [$key];
                    $key = is_stringable($key) ? "$key" : json_encode($key);
                    $cacheid = "hash." . hash('fnv164', $key);
                    $ttl = $ttl === null ? null : $this->_normalizeTtl($ttl);

                    $cache = $this->get($cacheid) ?? [];

                    // ttl チェック
                    if (isset($cache[$key][2]) && ($cache[$key][1] + $cache[$key][2]) <= $now) {
                        // アイテム自体の ttl を max($ttls) にしているため、原則として↑の $this->>get の時点でフィルタされてこのコードは通らない
                        // ここを通るのはハッシュが衝突してそれぞれの ttl がバラバラの場合のみ
                        // レアすぎてテストできないので ignore する（A(ttl:100) と B(ttl:50) が衝突してその間（75）で B を取得したときに通ることになる）
                        unset($cache[$key]); // @codeCoverageIgnore
                    }
                    // getter モード
                    if ($provider === null && $ttl === null) {
                        return $cache[$key][0] ?? null;
                    }
                    // ttl 0 は psr16 と同様に削除モード
                    if ($ttl !== null && $ttl <= 0) {
                        $result = isset($cache[$key]);
                        unset($cache[$key]);
                        $ttls = array_filter(array_column($cache, 2), fn($v) => $v !== null);
                        $this->set($cacheid, $cache, $ttls ? max($ttls) : null);
                        return $result;
                    }

                    if (!array_key_exists($key, $cache)) {
                        $cache[$key] = [$provider(...$args), $now, $ttl];
                        $ttls = array_filter(array_column($cache, 2), fn($v) => $v !== null);
                        $this->set($cacheid, $cache, $ttls ? max($ttls) : null);
                    }
                    return $cache[$key][0];
                }

                public function clear()
                {
                    $this->entries = [];

                    $files = $this->_getCacheFilenames();
                    return count($files) === count(array_filter(array_map('unlink', $files)));
                }

                public function getMultiple($keys, $default = null)
                {
                    return array_each($keys, function (&$result, $v) use ($default) {
                        $result[$v] = $this->get($v, $default);
                    }, []);
                }

                public function setMultiple($values, $ttl = null)
                {
                    return array_each($values, function (&$result, $v, $k) use ($ttl) {
                        $result = $this->set($k, $v, $ttl) && $result;
                    }, true);
                }

                public function deleteMultiple($keys)
                {
                    return array_each($keys, function (&$result, $v) {
                        $result = $this->delete($v) && $result;
                    }, true);
                }

                public function has($key)
                {
                    return $this->get($key) !== null;
                }
            };

            return !interface_exists(\Psr\SimpleCache\CacheInterface::class) ? $cacheobject : new class($cacheobject) implements \Psr\SimpleCache\CacheInterface {
                public function __construct(private $cacheobject) { }

                // @formatter:off
                public function clean($max_execution_time = null)                { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
                public function keys($pattern = null): iterable                  { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
                public function fetch($key, $provider, $ttl = null): mixed       { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
                public function fetchMultiple($providers, $ttl = null): iterable { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
                public function get($key, $default = null): mixed                { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
                public function set($key, $value, $ttl = null): bool             { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
                public function delete($key): bool                               { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
                public function provide($provider, ...$args): mixed              { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
                public function hash($key, $provider, $ttl = null): mixed        { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
                public function clear(): bool                                    { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
                public function getMultiple($keys, $default = null): iterable    { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
                public function setMultiple($values, $ttl = null): bool          { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
                public function deleteMultiple($keys): bool                      { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
                public function has($key): bool                                  { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
                // @formatter:on
            };
        })($directory);

        static $cleaned = [];
        if ($clean_probability !== 0 && !($cleaned[$directory] ?? false)) {
            $cleaned[$directory] = true;
            if ($clean_probability * 100 >= rand(1, 100)) {
                $cacheobject->clean($clean_execution_time);
            }
        }

        /** @noinspection PhpIncompatibleReturnTypeInspection */
        return $cacheobject;
    }
}

assert(!function_exists('ryunosuke\\dbml\\function_configure') || (new \ReflectionFunction('ryunosuke\\dbml\\function_configure'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\function_configure')) {
    /**
     * 本ライブラリの設定を行う
     *
     * 各関数の挙動を変えたり、デフォルトオプションを設定できる。
     *
     * @package ryunosuke\Functions\Package\utility
     *
     * @param array|?string $option 設定。文字列指定時はその値を返す
     * @return array|string 設定値
     */
    function function_configure($option)
    {
        static $config = [];

        // default
        $config['cachedir'] ??= sys_get_temp_dir() . DIRECTORY_SEPARATOR . 'rf' . DIRECTORY_SEPARATOR . strtr(__NAMESPACE__, ['\\' => '%']);
        $config['storagedir'] ??= DIRECTORY_SEPARATOR === '/' ? '/var/tmp/rf/' . strtr(__NAMESPACE__, ['\\' => '%']) : (getenv('ALLUSERSPROFILE') ?: sys_get_temp_dir()) . '\\rf\\' . strtr(__NAMESPACE__, ['\\' => '%']);
        $config['placeholder'] ??= '';
        $config['var_stream'] ??= 'VarStreamV010000';
        $config['memory_stream'] ??= 'MemoryStreamV010000';
        $config['array.variant'] ??= false;
        $config['chain.version'] ??= 2;
        $config['chain.nullsafe'] ??= false;
        $config['process.autoload'] ??= [];
        $config['datetime.class'] ??= \DateTimeImmutable::class;

        // setting
        if (is_array($option)) {
            foreach ($option as $name => $entry) {
                $option[$name] = $config[$name] ?? null;
                switch ($name) {
                    default:
                        $config[$name] = $entry;
                        break;
                    case 'cachedir':
                    case 'storagedir':
                        $entry ??= $config[$name];
                        if (!file_exists($entry)) {
                            @mkdir($entry, 0777 & (~umask()), true);
                        }
                        $config[$name] = realpath($entry);
                        break;
                    case 'placeholder':
                        if (strlen($entry)) {
                            $entry = ltrim($entry[0] === '\\' ? $entry : __NAMESPACE__ . '\\' . $entry, '\\');
                            if (!defined($entry)) {
                                define($entry, tmpfile() ?: [] ?: '' ?: 0.0 ?: null ?: false);
                            }
                            if (!is_resourcable(constant($entry))) {
                                // もしリソースじゃないと一意性が保てず致命的になるので例外を投げる
                                throw new \RuntimeException('placeholder is not resource'); // @codeCoverageIgnore
                            }
                            $config[$name] = $entry;
                        }
                        break;
                }
            }
            return $option;
        }

        // getting
        if ($option === null) {
            return $config;
        }
        if (is_string($option)) {
            switch ($option) {
                default:
                    return $config[$option] ?? null;
                case 'cachedir':
                case 'storagedir':
                    $dirname = $config[$option];
                    if (!file_exists($dirname)) {
                        @mkdir($dirname, 0777 & (~umask()), true); // @codeCoverageIgnore
                    }
                    return realpath($dirname);
            }
        }

        throw new \InvalidArgumentException(sprintf('$option is unknown type(%s)', gettype($option)));
    }
}

assert(!function_exists('ryunosuke\\dbml\\json_storage') || (new \ReflectionFunction('ryunosuke\\dbml\\json_storage'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\json_storage')) {
    /**
     * キーが json 化されてファイルシステムに永続化される ArrayAccess を返す
     *
     * 非常にシンプルで PSR-16 も実装せず、クリア手段も（基本的には）存在しない。
     * ArrayAccess なので `$storage['hoge'] ??= something()` として使うのがほぼ唯一の利用法。
     * その仕様・利用上、値として null を使用することはできない（使用した場合の動作は未定義とする）。
     *
     * キーに指定できるのは json_encode 可能なもののみ。
     * 値に指定できるのは var_export 可能なもののみ。
     * 上記以外を与えたときの動作は未定義。
     * TTL を指定すると次回読み込み時に期限切れをチェックし、切れていた場合 null を返す。
     * 一度読み込まれればそのリクエスト中は期限切れになることはない。
     *
     * 得てして簡単な関数・メソッドのメモ化や内部的なキャッシュに使用する。
     *
     * Example:
     * ```php
     * // ??= を使えば「無かったら値を、有ったらそれを」を単純に実現できる
     * $storage = json_storage();
     * that($storage['key'] ??= (fn() => 123)())->is(123);
     * that($storage['key'] ??= (fn() => 456)())->is(123);
     * // 引数に与えた prefix で別空間になる
     * $storage = json_storage('other');
     * that($storage['key'] ??= (fn() => 789)())->is(789);
     * ```
     *
     * @package ryunosuke\Functions\Package\utility
     *
     * @param string $directory 永続化ディレクトリ
     * @param int $ttl TTL
     * @return \ArrayObject
     */
    function json_storage(string $prefix = 'global', int $ttl = PHP_INT_MAX)
    {
        $cachedir = function_configure('cachedir') . '/' . strtr(__FUNCTION__, ['\\' => '%']);
        if (!file_exists($cachedir)) {
            @mkdir($cachedir, 0777, true);
        }

        static $objects = [];
        $objects[$prefix] ??= new class("$cachedir/" . strtr($prefix, ['\\' => '%', '/' => '-'])) extends \ArrayObject {
            public int $defaultTtl = PHP_INT_MAX;

            public function __construct(private string $directory)
            {
                parent::__construct();
            }

            public function offsetExists(mixed $key): bool
            {
                return $this->offsetGet($key) !== null;
            }

            public function offsetGet(mixed $key): mixed
            {
                $json = $this->json($key);

                // 有るならそれでよい
                if (parent::offsetExists($json)) {
                    return parent::offsetGet($json);
                }

                // 無くてもストレージにある可能性がある
                $filename = $this->filename($json);
                clearstatcache(true, $filename);
                if (file_exists($filename)) {
                    [$k, $v, $t] = include $filename;
                    // TTL 兼 hash 化してるので万が一競合すると異なるデータを返してしまう
                    if (($k !== $key) || ((time() - $t) >= $this->defaultTtl)) {
                        return null;
                    }
                    // ストレージに有ったら内部キャッシュしてそれを使う
                    parent::offsetSet($json, $v);
                    return $v;
                }

                return null;
            }

            public function offsetSet(mixed $key, mixed $value): void
            {
                $json = $this->json($key);

                // 値が変化したらストレージにも保存
                if (!parent::offsetExists($json) || parent::offsetGet($json) !== $value) {
                    assert(is_exportable($value));
                    $filename = $this->filename($json);
                    if ($value === null) {
                        opcache_invalidate($filename, true);
                        @unlink($filename);
                    }
                    else {
                        file_put_contents($filename, '<?php return ' . var_export([$key, $value, time()], true) . ';', LOCK_EX);
                    }
                }

                parent::offsetSet($json, $value);
            }

            public function offsetUnset(mixed $key): void
            {
                $this->offsetSet($key, null);
            }

            private function json(mixed $data): string
            {
                assert((function () use ($data) {
                    $tmp = [$data];
                    array_walk_recursive($tmp, function ($value) {
                        if (is_resourcable($value)) {
                            throw new \Exception("\$value is resource");
                        }
                        if (is_object($value) && (!$value instanceof \JsonSerializable && get_class($value) !== \stdClass::class)) {
                            throw new \Exception("\$value is not JsonSerializable");
                        }
                    });
                    return true;
                })());
                return json_encode($data, JSON_UNESCAPED_UNICODE | JSON_THROW_ON_ERROR);
            }

            private function filename(string $json): string
            {
                $filename = base64url_encode(implode("\n", [
                    hash('fnv164', $json, true),
                    hash('crc32', $json, true),
                ]));
                return "{$this->directory}-$filename.php-cache";
            }

            /** @noinspection PhpUnusedPrivateMethodInspection */
            private function debug($closure)
            {
                return $closure->call($this);
            }
        };
        $objects[$prefix]->defaultTtl = $ttl;
        return $objects[$prefix];
    }
}

assert(!function_exists('ryunosuke\\dbml\\arrayval') || (new \ReflectionFunction('ryunosuke\\dbml\\arrayval'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\arrayval')) {
    /**
     * array キャストの関数版
     *
     * intval とか strval とかの array 版。
     * ただキャストするだけだが、関数なのでコールバックとして使える。
     *
     * $recursive を true にすると再帰的に適用する（デフォルト）。
     * 入れ子オブジェクトを配列化するときなどに使える。
     *
     * Example:
     * ```php
     * // キャストなので基本的には配列化される
     * that(arrayval(123))->isSame([123]);
     * that(arrayval('str'))->isSame(['str']);
     * that(arrayval([123]))->isSame([123]); // 配列は配列のまま
     *
     * // $recursive = false にしない限り再帰的に適用される
     * $stdclass = (object) ['key' => 'val'];
     * that(arrayval([$stdclass], true))->isSame([['key' => 'val']]); // true なので中身も配列化される
     * that(arrayval([$stdclass], false))->isSame([$stdclass]);       // false なので中身は変わらない
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var array 化する値
     * @param bool $recursive 再帰的に行うなら true
     * @return array array 化した配列
     */
    function arrayval($var, $recursive = true)
    {
        // return json_decode(json_encode($var), true);

        // 無駄なループを回したくないので非再帰で配列の場合はそのまま返す
        if (!$recursive && is_array($var)) {
            return $var;
        }

        if (is_primitive($var)) {
            return (array) $var;
        }

        $result = [];
        foreach ($var as $k => $v) {
            if ($recursive && !is_primitive($v)) {
                $v = arrayval($v, $recursive);
            }
            $result[$k] = $v;
        }
        return $result;
    }
}

assert(!function_exists('ryunosuke\\dbml\\flagval') || (new \ReflectionFunction('ryunosuke\\dbml\\flagval'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\flagval')) {
    /**
     * falsy の範囲を少し拡張した bool キャスト
     *
     * 例えば ajax 等で {hoge: false} とすると "false" が飛んできてしまうが、その場合も false 判定されるようになる。
     * この処理は FILTER_VALIDATE_BOOLEAN で行うので "off", "no", 等も false を返す。
     *
     * あとドキュメントには空白文字について言及がないが、どうも trim される模様。
     * trim するかどうかは呼び元で判断すべきだと思う（" true " が true, "    " が false になるのは果たして正しいのか）ので、第2引数で分岐できるようにしてある。
     * boolval やキャストでは trim されないようなのでデフォルト false にしてある。
     *
     * Example:
     * ```php
     * // こういう文字列も false になる
     * that(flagval('false'))->isFalse();
     * that(flagval('off'))->isFalse();
     * that(flagval('no'))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var bool 化する値
     * @param bool $trim $var が文字列の場合に trim するか
     * @return bool bool 化した値
     */
    function flagval($var, $trim = false)
    {
        if ($trim === false && is_string($var)) {
            if (strlen(trim($var)) !== strlen($var)) {
                return true;
            }
        }
        return filter_var($var, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE) ?? (bool) $var;
    }
}

assert(!function_exists('ryunosuke\\dbml\\is_arrayable') || (new \ReflectionFunction('ryunosuke\\dbml\\is_arrayable'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\is_arrayable')) {
    /**
     * 変数が配列アクセス可能か調べる
     *
     * Example:
     * ```php
     * that(is_arrayable([]))->isTrue();
     * that(is_arrayable(new \ArrayObject()))->isTrue();
     * that(is_arrayable(new \stdClass()))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool 配列アクセス可能なら true
     */
    function is_arrayable($var)
    {
        return is_array($var) || $var instanceof \ArrayAccess;
    }
}

assert(!function_exists('ryunosuke\\dbml\\is_empty') || (new \ReflectionFunction('ryunosuke\\dbml\\is_empty'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\is_empty')) {
    /**
     * 値が空か検査する
     *
     * `empty` とほぼ同じ。ただし
     *
     * - string: "0"
     * - countable でない object
     * - countable である object で count() > 0
     *
     * は false 判定する。
     * ただし、 $empty_stcClass に true を指定すると「フィールドのない stdClass」も true を返すようになる。
     * これは stdClass の立ち位置はかなり特殊で「フィールドアクセスできる組み込み配列」のような扱いをされることが多いため。
     * （例えば `json_decode('{}')` は stdClass を返すが、このような状況は空判定したいことが多いだろう）。
     *
     * なお、関数の仕様上、未定義変数を true 判定することはできない。
     * 未定義変数をチェックしたい状況は大抵の場合コードが悪いが `$array['key1']['key2']` を調べたいことはある。
     * そういう時には使えない（?? する必要がある）。
     *
     * 「 `if ($var) {}` で十分なんだけど "0" が…」という状況はまれによくあるはず。
     *
     * Example:
     * ```php
     * // この辺は empty と全く同じ
     * that(is_empty(null))->isTrue();
     * that(is_empty(false))->isTrue();
     * that(is_empty(0))->isTrue();
     * that(is_empty(''))->isTrue();
     * // この辺だけが異なる
     * that(is_empty('0'))->isFalse();
     * // 第2引数に true を渡すと空の stdClass も empty 判定される
     * $stdclass = new \stdClass();
     * that(is_empty($stdclass, true))->isTrue();
     * // フィールドがあれば empty ではない
     * $stdclass->hoge = 123;
     * that(is_empty($stdclass, true))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 判定する値
     * @param bool $empty_stdClass 空の stdClass を空とみなすか
     * @return bool 空なら true
     */
    function is_empty($var, $empty_stdClass = false)
    {
        // object は is_countable 次第
        if (is_object($var)) {
            // が、 stdClass だけは特別扱い（stdClass は継承もできるので、クラス名で判定する（継承していたらそれはもう stdClass ではないと思う））
            if ($empty_stdClass && get_class($var) === 'stdClass') {
                return !(array) $var;
            }
            if (is_countable($var)) {
                return !count($var);
            }
            return false;
        }

        // "0" は false
        if ($var === '0') {
            return false;
        }

        // 上記以外は empty に任せる
        return empty($var);
    }
}

assert(!function_exists('ryunosuke\\dbml\\is_exportable') || (new \ReflectionFunction('ryunosuke\\dbml\\is_exportable'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\is_exportable')) {
    /**
     * 値が var_export で出力可能か検査する
     *
     * 「出力可能」とは「意味のある出力」を意味する。
     * 例えば set_state のないオブジェクトはエラーなく set_state コール形式で出力されるが意味のある出力ではない。
     * リソース型はエラーなく NULL で出力されるが意味のある出力ではない。
     * 循環参照は出力できるものの warning が出てかつ循環は切れるため意味のある出力ではない。
     *
     * Example:
     * ```php
     * that(is_primitive(null))->isTrue();
     * that(is_primitive(false))->isTrue();
     * that(is_primitive(123))->isTrue();
     * that(is_primitive(STDIN))->isTrue();
     * that(is_primitive(new \stdClass))->isFalse();
     * that(is_primitive(['array']))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool 出力可能なら true
     */
    function is_exportable($var): bool
    {
        // スカラー/NULL は OK
        if (is_scalar($var) || is_null($var)) {
            return true;
        }

        // リソース型の変数は、この関数ではエクスポートする事ができません
        if (is_resourcable($var)) {
            return false;
        }

        // var_export() では循環参照を扱うことができません
        if (is_recursive($var)) {
            return false;
        }

        // 配列に制限はない。それゆえに全要素を再帰的に見なければならない
        if (is_array($var)) {
            foreach ($var as $v) {
                if (!is_exportable($v)) {
                    return false;
                }
            }
            return true;
        }

        if (is_object($var)) {
            // 無名クラスは非常に特殊で、出力は class@anonymous{filename}:123$456::__set_state(...) のようになる
            // set_state さえ実装してれば復元可能に思えるが php コードとして不正なのでそのまま実行するとシンタックスエラーになる
            // 'class@anonymous{filename}:123$456'::__set_state(...) のようにクオートすれば実行可能になるが、それは標準 var_export の動作ではない
            // 復元する側がクオートして読み込み…とすれば復元可能だが、そもそもクラスがロードされている保証もない
            // これらのことを考慮するなら「意味のある出力」ではないとみなした方が手っ取り早い
            if ((new \ReflectionClass($var))->isAnonymous()) {
                return false;
            }
            // var_export() が生成する PHP を評価できるようにするためには、処理対象のすべてのオブジェクトがマジックメソッド __set_state を実装している必要があります
            if (method_exists($var, '__set_state')) {
                return true;
            }
            // これの唯一の例外は stdClass です。 stdClass は、配列をオブジェクトにキャストした形でエクスポートされます
            if (get_class($var) === \stdClass::class) {
                return true;
            }
            // マニュアルに記載はないが enum は export できる
            if ($var instanceof \UnitEnum) {
                return true;
            }
            return false;
        }
    }
}

assert(!function_exists('ryunosuke\\dbml\\is_primitive') || (new \ReflectionFunction('ryunosuke\\dbml\\is_primitive'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\is_primitive')) {
    /**
     * 値が複合型でないか検査する
     *
     * 「複合型」とはオブジェクトと配列のこと。
     * つまり
     *
     * - is_scalar($var) || is_null($var) || is_resource($var)
     *
     * と同義（!is_array($var) && !is_object($var) とも言える）。
     *
     * Example:
     * ```php
     * that(is_primitive(null))->isTrue();
     * that(is_primitive(false))->isTrue();
     * that(is_primitive(123))->isTrue();
     * that(is_primitive(STDIN))->isTrue();
     * that(is_primitive(new \stdClass))->isFalse();
     * that(is_primitive(['array']))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool 複合型なら false
     */
    function is_primitive($var)
    {
        return is_scalar($var) || is_null($var) || is_resourcable($var);
    }
}

assert(!function_exists('ryunosuke\\dbml\\is_recursive') || (new \ReflectionFunction('ryunosuke\\dbml\\is_recursive'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\is_recursive')) {
    /**
     * 変数が再帰参照を含むか調べる
     *
     * Example:
     * ```php
     * // 配列の再帰
     * $array = [];
     * $array['recursive'] = &$array;
     * that(is_recursive($array))->isTrue();
     * // オブジェクトの再帰
     * $object = new \stdClass();
     * $object->recursive = $object;
     * that(is_recursive($object))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool 再帰参照を含むなら true
     */
    function is_recursive($var)
    {
        $core = function ($var, $parents) use (&$core) {
            // 複合型でないなら間違いなく false
            if (is_primitive($var)) {
                return false;
            }

            // 「親と同じ子」は再帰以外あり得ない。よって === で良い（オブジェクトに関してはそもそも等値比較で絶対に一致しない）
            // sql_object_hash とか serialize でキーに保持して isset の方が速いか？
            // → ベンチ取ったところ in_array の方が10倍くらい速い。多分生成コストに起因
            // raw な比較であれば瞬時に比較できるが、isset だと文字列化が必要でかなり無駄が生じていると考えられる
            foreach ($parents as $parent) {
                if ($parent === $var) {
                    return true;
                }
            }

            // 全要素を再帰的にチェック
            $parents[] = $var;
            foreach ($var as $v) {
                if ($core($v, $parents)) {
                    return true;
                }
            }
            return false;
        };
        return $core($var, []);
    }
}

assert(!function_exists('ryunosuke\\dbml\\is_resourcable') || (new \ReflectionFunction('ryunosuke\\dbml\\is_resourcable'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\is_resourcable')) {
    /**
     * 閉じたリソースでも true を返す is_resource
     *
     * マニュアル（ https://www.php.net/manual/ja/function.is-resource.php ）に記載の通り、 isresource は閉じたリソースで false を返す。
     * リソースはリソースであり、それでは不便なこともあるので、閉じていようとリソースなら true を返す関数。
     *
     * Example:
     * ```php
     * // 閉じたリソースを用意
     * $resource = tmpfile();
     * fclose($resource);
     * // is_resource は false を返すが・・・
     * that(is_resource($resource))->isFalse();
     * // is_resourcable は true を返す
     * that(is_resourcable($resource))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool リソースなら true
     */
    function is_resourcable($var)
    {
        if (is_resource($var)) {
            return true;
        }
        // もっといい方法があるかもしれないが、簡単に調査したところ gettype するしか術がないような気がする
        if (strpos(gettype($var), 'resource') === 0) {
            return true;
        }
        return false;
    }
}

assert(!function_exists('ryunosuke\\dbml\\is_stringable') || (new \ReflectionFunction('ryunosuke\\dbml\\is_stringable'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\is_stringable')) {
    /**
     * 変数が文字列化できるか調べる
     *
     * 「配列」「__toString を持たないオブジェクト」が false になる。
     * （厳密に言えば配列は "Array" になるので文字列化できるといえるがここでは考えない）。
     *
     * Example:
     * ```php
     * // こいつらは true
     * that(is_stringable(null))->isTrue();
     * that(is_stringable(true))->isTrue();
     * that(is_stringable(3.14))->isTrue();
     * that(is_stringable(STDOUT))->isTrue();
     * that(is_stringable(new \Exception()))->isTrue();
     * // こいつらは false
     * that(is_stringable(new \ArrayObject()))->isFalse();
     * that(is_stringable([1, 2, 3]))->isFalse();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @return bool 文字列化できるなら true
     */
    function is_stringable($var)
    {
        if (is_array($var)) {
            return false;
        }
        if (is_object($var) && !method_exists($var, '__toString')) {
            return false;
        }
        return true;
    }
}

assert(!function_exists('ryunosuke\\dbml\\is_typeof') || (new \ReflectionFunction('ryunosuke\\dbml\\is_typeof'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\is_typeof')) {
    /**
     * 変数が型に合致するか調べる
     *
     * is_a のビルトイン＋DNF 対応版。
     *
     * DNF の場合、括弧は必須だしネストも不可。
     * 実質的には ReflectionType の文字列表現を与えるのみ。
     *
     * いわゆる strict_types=1 で、型の変換は伴わない。
     * それはそれで不便なことがある（stringable とか）ので対応するかもしれない。
     *
     * Example:
     * ```php
     * that(is_typeof(null, 'null'))->isTrue();
     * that(is_typeof(null, '?int'))->isTrue();
     * that(is_typeof(1234, '?int'))->isTrue();
     * that(is_typeof(1234, 'int|string'))->isTrue();
     * that(is_typeof('ss', 'int|string'))->isTrue();
     * that(is_typeof(null, 'int|string'))->isFalse();
     * that(is_typeof([], 'array|(ArrayAccess&Countable&iterable)'))->isTrue();
     * that(is_typeof(new \ArrayObject(), 'array|(ArrayAccess&Countable&iterable)'))->isTrue();
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 調べる値
     * @param string $typestring 型文字列
     * @param null|object|string $context self,static のコンテキスト
     * @return bool $typestring に合致するなら true
     */
    function is_typeof($var, string $typestring, $context = null)
    {
        $context ??= '';

        $match = function ($type) use ($var, $context) {
            $type = trim($type);
            // ?type は 7.4 を最後に姿を消したが $typestring はただの文字列なので与えられる可能性がなくはない
            if ($type[0] === '?') {
                if ($var === null) {
                    return true;
                }
                $type = substr($type, 1);
            }
            return match ($type) {
                'void', 'never'  => false, // 単一戻り値専用なのでオマケのようなもの
                'mixed'          => true,
                'null'           => $var === null,
                'true'           => $var === true,
                'false'          => $var === false,
                'bool'           => is_bool($var),
                'int'            => is_int($var),
                'float'          => is_float($var),
                'string'         => is_string($var),
                'array'          => is_array($var),
                'object'         => is_object($var),
                'iterable'       => is_iterable($var),
                'callable'       => is_callable($var),
                'countable'      => is_countable($var),   // Countable は配列が引っかからないので Countable/countable を区別している
                'resource'       => is_resourcable($var), // 型宣言できないのでオマケのようなもの
                'self', 'static' => is_a($var, is_object($context) ? get_class($context) : $context),
                default          => is_a($var, $type),
            };
        };

        // DNF の()は必須かつネストしないので単純 explode で問題ない
        foreach (explode('|', $typestring) as $ortype) {
            if (preg_match('#\(?([^)]+)\)?#u', $ortype, $m)) {
                foreach (explode('&', $m[1]) as $andtype) {
                    if (!$match($andtype)) {
                        continue 2;
                    }
                }
                return true;
            }
        }

        return false;
    }
}

assert(!function_exists('ryunosuke\\dbml\\numval') || (new \ReflectionFunction('ryunosuke\\dbml\\numval'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\numval')) {
    /**
     * 値を数値化する
     *
     * int か float ならそのまま返す。
     * 文字列の場合、一言で言えば「.を含むなら float、含まないなら int」を返す。
     * int でも float でも stringable でもない場合は実装依存（ただの int キャスト）。
     *
     * Example:
     * ```php
     * that(numval(3.14))->isSame(3.14);   // int や float はそのまま返す
     * that(numval('3.14'))->isSame(3.14); // . を含む文字列は float を返す
     * that(numval('11', 8))->isSame(9);   // 基数が指定できる
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 数値化する値
     * @param int $base 基数。int 的な値のときしか意味をなさない
     * @return int|float 数値化した値
     */
    function numval($var, $base = 10)
    {
        if (is_int($var) || is_float($var)) {
            return $var;
        }
        if (is_object($var)) {
            $var = (string) $var;
        }
        if (is_string($var) && strpos($var, '.') !== false) {
            return (float) $var;
        }
        return intval($var, $base);
    }
}

assert(!function_exists('ryunosuke\\dbml\\si_unprefix') || (new \ReflectionFunction('ryunosuke\\dbml\\si_unprefix'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\si_unprefix')) {
    /**
     * SI 接頭辞が付与された文字列を数値化する
     *
     * 典型的な用途は ini_get で得られた値を数値化したいとき。
     * ただし、 ini は 1m のように小文字で指定することもあるので大文字化する必要はある。
     *
     * Example:
     * ```php
     * // 1k = 1000
     * that(si_unprefix('1k'))->isSame(1000);
     * // 1k = 1024
     * that(si_unprefix('1k', 1024))->isSame(1024);
     * // m はメガではなくミリ
     * that(si_unprefix('1m'))->isSame(0.001);
     * // M がメガ
     * that(si_unprefix('1M'))->isSame(1000000);
     * // K だけは特別扱いで大文字小文字のどちらでもキロになる
     * that(si_unprefix('1K'))->isSame(1000);
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 数値化する値
     * @param int $unit 桁単位。実用上は 1000, 1024 の2値しか指定することはないはず
     * @return int|float SI 接頭辞を取り払った実際の数値
     */
    function si_unprefix($var, $unit = 1000, $format = '%d%s')
    {
        assert($unit > 0);

        $var = trim($var);
        $num = numval($var);

        foreach (SI_UNITS as $exp => $sis) {
            foreach ($sis as $si) {
                if (sprintf($format, $num, $si) === $var) {
                    return $num * pow($unit, $exp);
                }
            }
        }

        return $num;
    }
}

assert(!function_exists('ryunosuke\\dbml\\stringify') || (new \ReflectionFunction('ryunosuke\\dbml\\stringify'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\stringify')) {
    /**
     * 値を何とかして文字列化する
     *
     * この関数の出力は互換性を考慮しない。頻繁に変更される可能性がある。
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var 文字列化する値
     * @return string $var を文字列化したもの
     */
    function stringify($var)
    {
        $type = gettype($var);
        switch ($type) {
            case 'NULL':
                return 'null';
            case 'boolean':
                return $var ? 'true' : 'false';
            case 'array':
                return var_export2($var, true);
            case 'object':
                if (method_exists($var, '__toString')) {
                    return (string) $var;
                }
                if (method_exists($var, '__serialize') || $var instanceof \Serializable) {
                    return serialize($var);
                }
                if ($var instanceof \JsonSerializable) {
                    return get_class($var) . ':' . json_encode($var, JSON_UNESCAPED_UNICODE);
                }
                return get_class($var);

            default:
                return (string) $var;
        }
    }
}

assert(!function_exists('ryunosuke\\dbml\\var_apply') || (new \ReflectionFunction('ryunosuke\\dbml\\var_apply'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\var_apply')) {
    /**
     * 値にコールバックを適用する
     *
     * 普通のスカラー値であれば `$callback($var)` と全く同じ。
     * この関数は「$var が配列だったら中身に適用して返す（再帰）」という点で上記とは異なる。
     *
     * 「配列が与えられたら要素に適用して配列で返す、配列じゃないなら直に適用してそれを返す」という状況はまれによくあるはず。
     *
     * Example:
     * ```php
     * // 素の値は素の呼び出しと同じ
     * that(var_apply(' x ', 'trim'))->isSame('x');
     * // 配列は中身に適用して配列で返す（再帰）
     * that(var_apply([' x ', ' y ', [' z ']], 'trim'))->isSame(['x', 'y', ['z']]);
     * // 第3引数以降は残り引数を意味する
     * that(var_apply(['!x!', '!y!'], 'trim', '!'))->isSame(['x', 'y']);
     * // 「まれによくある」の具体例
     * that(var_apply(['<x>', ['<y>']], 'htmlspecialchars', ENT_QUOTES, 'utf-8'))->isSame(['&lt;x&gt;', ['&lt;y&gt;']]);
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $var $callback を適用する値
     * @param callable $callback 値変換コールバック
     * @param mixed ...$args $callback の残り引数（可変引数）
     * @return mixed|array $callback が適用された値。元が配列なら配列で返す
     */
    function var_apply($var, $callback, ...$args)
    {
        $iterable = is_iterable($var);
        if ($iterable) {
            $result = [];
            foreach ($var as $k => $v) {
                $result[$k] = var_apply($v, $callback, ...$args);
            }
            return $result;
        }

        return $callback($var, ...$args);
    }
}

assert(!function_exists('ryunosuke\\dbml\\var_export2') || (new \ReflectionFunction('ryunosuke\\dbml\\var_export2'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\var_export2')) {
    /**
     * 組み込みの var_export をいい感じにしたもの
     *
     * 下記の点が異なる。
     *
     * - 配列は 5.4 以降のショートシンタックス（[]）で出力
     * - ただの配列は1行（[1, 2, 3]）でケツカンマなし、連想配列は桁合わせインデントでケツカンマあり
     * - 文字列はダブルクオート
     * - null は null（小文字）
     * - 再帰構造を渡しても警告がでない（さらに NULL ではなく `'*RECURSION*'` という文字列になる）
     * - 配列の再帰構造の出力が異なる（Example参照）
     *
     * Example:
     * ```php
     * // 単純なエクスポート
     * that(var_export2(['array' => [1, 2, 3], 'hash' => ['a' => 'A', 'b' => 'B', 'c' => 'C']], true))->isSame('[
     *     "array" => [1, 2, 3],
     *     "hash"  => [
     *         "a" => "A",
     *         "b" => "B",
     *         "c" => "C",
     *     ],
     * ]');
     * // 再帰構造を含むエクスポート（標準の var_export は形式が異なる。 var_export すれば分かる）
     * $rarray = [];
     * $rarray['a']['b']['c'] = &$rarray;
     * $robject = new \stdClass();
     * $robject->a = new \stdClass();
     * $robject->a->b = new \stdClass();
     * $robject->a->b->c = $robject;
     * that(var_export2(compact('rarray', 'robject'), true))->isSame('[
     *     "rarray"  => [
     *         "a" => [
     *             "b" => [
     *                 "c" => "*RECURSION*",
     *             ],
     *         ],
     *     ],
     *     "robject" => (object) [
     *         "a" => (object) [
     *             "b" => (object) [
     *                 "c" => "*RECURSION*",
     *             ],
     *         ],
     *     ],
     * ]');
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $value 出力する値
     * @param bool|array $options オプション配列（var_export に寄せるため bool も受け付ける）
     * @return string|null $return=true の場合は出力せず結果を返す
     */
    function var_export2($value, $options = [])
    {
        if (!is_array($options)) {
            $options = [
                'return' => !!$options,
            ];
        }

        $options += [
            'minify' => false, // 短縮形で返す（実質的には情報を減らして1行で返す）
            'indent' => 4,     // インデントの空白数
            'return' => false, // 値を戻すか出力するか
        ];

        // 再帰用クロージャ
        $export = function ($value, $context, $nest = 0, $parents = []) use (&$export, $options) {
            // 再帰を検出したら *RECURSION* とする（処理に関しては is_recursive のコメント参照）
            foreach ($parents as $parent) {
                if ($parent === $value) {
                    return $export('*RECURSION*', 'recursion');
                }
            }

            $space = $options['minify'] ? "" : " ";
            $break = $options['minify'] ? "" : "\n";

            // 配列は連想判定したり再帰したり色々
            if (is_array($value)) {
                $spacer1 = str_repeat($space, ($nest + 1) * $options['indent']);
                $spacer2 = str_repeat($space, $nest * $options['indent']);

                $hashed = is_hasharray($value);

                // スカラー値のみで構成されているならシンプルな再帰
                if (!$hashed && array_and($value, fn(...$args) => is_primitive(...$args))) {
                    return '[' . implode(",$space", array_map(fn($v) => $export($v, 'array-value'), $value)) . ']';
                }

                // 連想配列はキーを含めて桁あわせ
                if ($hashed) {
                    $keys = array_map(fn($v) => $export($v, 'array-key'), array_combine($keys = array_keys($value), $keys));
                    $maxlen = max(array_map('strlen', $keys));
                }
                $kvl = '';
                $lastkey = array_key_last($value);
                $parents[] = $value;
                foreach ($value as $k => $v) {
                    $keystr = $hashed ? $keys[$k] . str_repeat($space, $maxlen - strlen($keys[$k])) . "$space=>$space" : '';
                    $kvl .= $spacer1 . $keystr . $export($v, 'array-value', $nest + 1, $parents) . ($k === $lastkey && $options['minify'] ? "" : ",") . "$break";
                }
                return "[$break{$kvl}{$spacer2}]";
            }
            // オブジェクトは単にプロパティを __set_state する文字列を出力する
            elseif (is_object($value)) {
                $parents[] = $value;
                $classname = get_class($value);
                if ($classname === \stdClass::class) {
                    return "(object)$space" . $export((array) $value, 'object', $nest, $parents);
                }
                return $classname . '::__set_state(' . $export(object_properties($value), 'object', $nest, $parents) . ')';
            }
            // 文字列はダブルクオート（場合によってはヒアドキュメント）
            elseif (is_string($value)) {
                // 列揃えのため配列のキーは常にダブルクォート
                if ($context === 'array-key') {
                    return str_quote($value);
                }
                // 改行を含むならヒアドキュメント
                if (!$options['minify'] && str_exists($value, ["\r", "\n"])) {
                    // ただし、改行文字だけの場合は除く（何らかの引数で改行文字だけを渡すシチュエーションはそれなりにあるのでヒアドキュメントだと冗長）
                    if (trim($value, "\r\n") !== '') {
                        return str_quote($value, [
                            'heredoc' => unique_string($value, 'TEXT', '_'),
                            'indent'  => $nest * $options['indent'],
                        ]);
                    }
                }
                return str_quote($value);
            }
            // null は小文字で居て欲しい
            elseif (is_null($value)) {
                return 'null';
            }
            // それ以外は標準に従う
            else {
                return var_export($value, true);
            }
        };

        // 結果を返したり出力したり
        $result = $export($value, null);
        if ($options['return']) {
            return $result;
        }
        echo $result, "\n";
    }
}

assert(!function_exists('ryunosuke\\dbml\\var_export3') || (new \ReflectionFunction('ryunosuke\\dbml\\var_export3'))->isUserDefined());
if (!function_exists('ryunosuke\\dbml\\var_export3')) {
    /**
     * var_export を色々と出力できるようにしたもの
     *
     * php のコードに落とし込むことで serialize と比較してかなり高速に動作する。
     *
     * 各種オブジェクトやクロージャ、循環参照を含む配列など様々なものが出力できる。
     * ただし、下記は不可能あるいは復元不可（今度も対応するかは未定）。
     *
     * - 特定の内部クラス（PDO など）
     * - 大部分のリソース
     *
     * ただし args キーに指定した値は出力されず、import 時にそれらを引数とするクロージャを返すようになるため、疑似的に出力することは可能。
     *
     * オブジェクトは「リフレクションを用いてコンストラクタなしで生成してプロパティを代入する」という手法で復元する。
     * ただしコンストラクタが必須引数無しの場合はコールされる。
     * のでクラスによってはおかしな状態で復元されることがある（大体はリソース型のせいだが…）。
     * sleep, wakeup, Serializable などが実装されているとそれはそのまま機能する。
     * set_state だけは呼ばれないので注意。
     *
     * Generator は元となった関数/メソッドを再コールすることで復元される。
     * その仕様上、引数があると呼べないし、実行位置はリセットされる。
     *
     * クロージャはコード自体を引っ張ってきて普通に function (){} として埋め込む。
     * クラス名のエイリアスや use, $this バインドなど可能な限り復元するが、おそらくあまりに複雑なことをしてると失敗する。
     *
     * リソースはファイル的なリソースであればメタ情報を出力して復元時に再オープンする。
     *
     * 軽くベンチを取ったところ、オブジェクトを含まない純粋な配列の場合、serialize の 200 倍くらいは速い（それでも var_export の方が速いが…）。
     * オブジェクトを含めば含むほど遅くなり、全要素がオブジェクトになると serialize と同程度になる。
     * 大体 var_export:var_export3:serialize が 1:5:1000 くらい。
     *
     * Example:
     * ```php
     * // 出力不可を含む配列
     * $value = [
     *     'stdout' => STDOUT,
     *     'pdo'    => new \PDO('sqlite::memory:'),
     * ];
     * // args を指定すると実際はエクスポートされず、クロージャ表現を返すようになる（値だけ見るのでキーはなんでもよい）
     * $exported = var_export3($value, ['outmode' => 'eval', 'args' => ['k1' => STDOUT, 'k2' => $value['pdo']]]);
     * // import するとクロージャが得られる
     * $closure = eval($exported);
     * that($closure)->isInstanceOf(\Closure::class);
     * // 引数付きで実行すれば値が得られる（この引数のキーは出力時のキーと合わせなければならない）
     * $imported = $closure(['k1' => STDOUT, 'k2' => $value['pdo']]);
     * that($imported['stdout'])->isSame($value['stdout']);
     * that($imported['pdo'])->isSame($value['pdo']);
     * // 要するに実行時に与えられるわけなので、やる気になれば全く関係ない値でも可能
     * $imported = $closure(['k1' => 123, 'k2' => 456]);
     * that($imported['stdout'])->isSame(123);
     * that($imported['pdo'])->isSame(456);
     * ```
     *
     * @package ryunosuke\Functions\Package\var
     *
     * @param mixed $value エクスポートする値
     * @param bool|array $return 返り値として返すなら true. 配列を与えるとオプションになる
     * @return string エクスポートされた文字列
     */
    function var_export3($value, $return = false)
    {
        // 原則として var_export に合わせたいのでデフォルトでは bool: false で単に出力するのみとする
        if (is_bool($return)) {
            $return = [
                'return' => $return,
            ];
        }
        $options = $return;
        $options += [
            'format'  => 'pretty', // pretty or minify
            'outmode' => null,     // null: 本体のみ, 'eval': return ...;, 'file': <?php return ...;
            'args'    => [],       // ここで指定した値は export に含まれず、import 時に引数で要求されるようになる
        ];
        $options['return'] ??= !!$options['outmode'];

        $var_manager = new class() {
            private $vars = [];
            private $refs = [];

            private function arrayHasReference($array)
            {
                foreach ($array as $k => $v) {
                    $ref = \ReflectionReference::fromArrayElement($array, $k);
                    if ($ref) {
                        return true;
                    }
                    if (is_array($v) && $this->arrayHasReference($v)) {
                        return true;
                    }
                }
                return false;
            }

            public function varId($var)
            {
                // オブジェクトは明確な ID が取れる（generator/closure/object の区分けに処理的な意味はない）
                if (is_object($var)) {
                    $id = ($var instanceof \Generator ? 'generator' : ($var instanceof \Closure ? 'closure' : 'object')) . (spl_object_id($var) + 1);
                    $this->vars[$id] = $var;
                    return $id;
                }
                // 配列は明確な ID が存在しないので、貯めて検索して ID を振る（参照さえ含まなければ ID に意味はないので参照込みのみ）
                // 何度か検証してしまったので備忘:
                // ID を振らない方が格段に速いのでそのための分岐の目的もある
                // ID を振ると参照は関係なく・・・
                // - return $this->array1 = [$this->array2 = [$this->array3 = [...]]];
                // のようになり、（多分プロパティの動的作成で）結構遅くなる
                // ID を振らなければ・・・
                // - return [[[...]]];
                // のようになり、実質的に opcache を返すだけになる
                if (is_array($var) && $this->arrayHasReference($var)) {
                    $id = array_search($var, $this->vars, true);
                    if (!$id) {
                        $id = 'array' . (count($this->vars) + 1);
                    }
                    $this->vars[$id] = $var;
                    return $id;
                }
                // リソースも一応は ID がある
                if (is_resourcable($var)) {
                    $id = 'resource' . (int) $var;
                    $this->vars[$id] = $var;
                    return $id;
                }
            }

            public function refId($array, $k)
            {
                static $ids = [];
                $ref = \ReflectionReference::fromArrayElement($array, $k);
                if ($ref) {
                    $refid = $ref->getId();
                    $ids[$refid] = ($ids[$refid] ?? count($ids) + 1);
                    $id = 'reference' . $ids[$refid];
                    $this->refs[$id] = $array[$k];
                    return $id;
                }
            }

            public function orphan()
            {
                foreach ($this->refs as $rid => $var) {
                    $vid = array_search($var, $this->vars, true);
                    yield $rid => [!!$vid, $vid, $var];
                }
            }
        };

        // 再帰用クロージャ
        $vars = [];
        $export = function ($value, $nest = 0, $raw = false) use (&$export, &$vars, $var_manager, $options) {
            $spacer0 = str_repeat(" ", 4 * max(0, $nest + 0));
            $spacer1 = str_repeat(" ", 4 * max(0, $nest + 1));
            $raw_export = fn($v) => $v;
            $var_export = fn($v) => var_export($v, true);

            $vid = $var_manager->varId($value);
            if ($vid) {
                if (isset($vars[$vid])) {
                    return "\$this->$vid";
                }
                $vars[$vid] = $value;
            }

            if (($arg = array_search($value, $options['args'], true)) !== false) {
                return "\$this->$vid = \$this->args[{$var_export($arg)}]";
            }

            if (is_array($value)) {
                $hashed = is_hasharray($value);
                if (!$hashed && array_and($value, fn(...$args) => is_primitive(...$args))) {
                    [$begin, $middle, $end] = ["", ", ", ""];
                }
                else {
                    [$begin, $middle, $end] = ["\n{$spacer1}", ",\n{$spacer1}", ",\n{$spacer0}"];
                }

                $keys = array_map($var_export, array_combine($keys = array_keys($value), $keys));
                $maxlen = max(array_map('strlen', $keys ?: ['']));
                $kvl = [];
                foreach ($value as $k => $v) {
                    $refid = $var_manager->refId($value, $k);
                    $keystr = $hashed ? $keys[$k] . str_repeat(" ", $maxlen - strlen($keys[$k])) . " => " : '';
                    $valstr = $refid ? "&\$this->$refid" : $export($v, $nest + 1);
                    $kvl[] = $keystr . $valstr;
                }
                $kvl = implode($middle, $kvl);
                $declare = $vid ? "\$this->$vid = " : "";
                return "{$declare}[$begin{$kvl}$end]";
            }
            if ($value instanceof \Generator) {
                $ref = new \ReflectionGenerator($value);
                $reffunc = $ref->getFunction();

                if ($reffunc->getNumberOfRequiredParameters() > 0) {
                    throw new \DomainException('required argument Generator is not support.');
                }

                $caller = null;
                if ($reffunc instanceof \ReflectionFunction) {
                    if ($reffunc->isClosure()) {
                        $caller = "({$export($reffunc->getClosure(), $nest)})";
                    }
                    else {
                        $caller = $reffunc->name;
                    }
                }
                if ($reffunc instanceof \ReflectionMethod) {
                    if ($reffunc->isStatic()) {
                        $caller = "{$reffunc->class}::{$reffunc->name}";
                    }
                    else {
                        $caller = "{$export($ref->getThis(), $nest)}->{$reffunc->name}";
                    }
                }
                return "\$this->$vid = {$caller}()";
            }
            if ($value instanceof \Closure) {
                $ref = new \ReflectionFunction($value);
                $bind = $ref->getClosureThis();
                $class = $ref->getClosureScopeClass();
                $statics = $ref->getStaticVariables();

                // 内部由来はきちんと fromCallable しないと差異が出てしまう
                if ($ref->isInternal()) {
                    $receiver = $bind ?? $class?->getName();
                    $callee = $receiver ? [$receiver, $ref->getName()] : $ref->getName();
                    return "\$this->$vid = \\Closure::fromCallable({$export($callee, $nest)})";
                }

                [$meta, $body] = callable_code($value);
                $arrow = starts_with($meta, 'fn') ? ' => ' : ' ';
                $tokens = array_slice(php_tokens("<?php $meta{$arrow}$body;", TOKEN_PARSE), 1, -1);

                $uses = [];
                $context = [
                    'class' => 0,
                    'brace' => 0,
                ];
                foreach ($tokens as $n => $token) {
                    $prev = $token->prev() ?? (object) ['id' => null, 'text' => null, 'line' => null];
                    $next = $token->next() ?? (object) ['id' => null, 'text' => null, 'line' => null];
                    assert([$prev, $next]); // あらかじめ取得しておかないとズレるかもしれない

                    // クロージャは何でもかける（クロージャ・無名クラス・ジェネレータ etc）のでネスト（ブレース）レベルを記録しておく
                    if ($token->text === '{') {
                        $context['brace']++;
                    }
                    if ($token->text === '}') {
                        $context['brace']--;
                    }

                    // 無名クラスは色々厄介なので読み飛ばすために覚えておく
                    if ($prev->id === T_NEW && $token->id === T_CLASS) {
                        $context['class'] = $context['brace'];
                    }
                    // そして無名クラスは色々かける上に終了条件が自明ではない（シンタックスエラーでない限りは {} が一致するはず）
                    if ($token->text === '}' && $context['class'] === $context['brace']) {
                        $context['class'] = 0;
                    }

                    // fromCallable 由来だと名前がついてしまう
                    if (!$context['class'] && $prev->id === T_FUNCTION && $token->id === T_STRING) {
                        unset($tokens[$n]);
                        continue;
                    }

                    // use 変数の導出
                    if ($token->id === T_VARIABLE) {
                        $varname = substr($token->text, 1);
                        // クロージャ内クロージャの use に反応してしまうので存在するときのみとする
                        if (array_key_exists($varname, $statics) && !isset($uses[$varname])) {
                            $recurself = $statics[$varname] === $value ? '&' : '';
                            $uses[$varname] = "$spacer1\$$varname = $recurself{$export($statics[$varname], $nest + 1)};\n";
                        }
                    }

                    $tokens[$n] = $token->clone(text: $token->resolve($ref));
                }

                $code = php_indent(implode('', array_column($tokens, 'text')), [
                    'indent'   => $spacer1,
                    'baseline' => -1,
                ]);

                $attrs = [];
                foreach ($ref->getAttributes() as $attr) {
                    $attrs[] = "#[{$raw_export($attr->getName())}({$raw_export(implode(', ', array_map($export, $attr->getArguments())))})]";
                }
                $attrs = $attrs ? (implode(' ', $attrs) . ' ') : '';

                if ($bind) {
                    $instance = $export($bind, $nest + 1);
                    if ($class->isAnonymous()) {
                        $scope = "get_class({$export($bind, $nest + 1)})";
                    }
                    else {
                        $scope = $var_export($class?->getName() === 'Closure' ? 'static' : $class?->getName());
                    }
                    $code = "\Closure::bind({$attrs}$code, $instance, $scope)";
                }
                elseif (!is_bindable_closure($value)) {
                    $code = "{$attrs}static $code";
                }

                return "\$this->$vid = (function () {\n{$raw_export(implode('', $uses))}{$spacer1}return $code;\n$spacer0})->call(\$this)";
            }
            if (is_object($value)) {
                $ref = new \ReflectionObject($value);

                // enum はリテラルを返せばよい
                if ($value instanceof \UnitEnum) {
                    $declare = "\\$ref->name::$value->name";
                    if ($ref->getConstant($value->name) === $value) {
                        return "\$this->$vid = $declare";
                    }
                    // enum の polyfill で、__callStatic を利用して疑似的にエミュレートしているライブラリは多い
                    // もっとも、「多い」だけであり、そうとは限らないので値は見る必要はある（例外が飛ぶかもしれないので try も必要）
                    if ($ref->hasMethod('__callStatic')) {
                        try {
                            if ($declare() === $value) {
                                return "\$this->$vid = $declare()";
                            }
                        }
                        catch (\Throwable) { // @codeCoverageIgnore
                            // through. treat regular object
                        }
                    }
                }

                // 弱参照系は同時に渡ってきていれば復元できる
                if ($value instanceof \WeakReference) {
                    $weakreference = $value->get();
                    if ($weakreference === null) {
                        $weakreference = new \stdClass();
                    }
                    return "\$this->$vid = \\WeakReference::create({$export($weakreference, $nest)})";
                }
                if ($value instanceof \WeakMap) {
                    $weakmap = "{$spacer1}\$this->$vid = new \\WeakMap();\n";
                    foreach ($value as $object => $data) {
                        $weakmap .= "{$spacer1}\$this->{$vid}[{$export($object)}] = {$export($data)};\n";
                    }
                    return "\$this->$vid = (function () {\n{$weakmap}{$spacer1}return \$this->$vid;\n$spacer0})->call(\$this)";
                }

                // 内部クラスで serialize 出来ないものは __PHP_Incomplete_Class で代替（復元時に無視する）
                try {
                    if ($ref->isInternal()) {
                        serialize($value);
                    }
                }
                catch (\Exception $e) {
                    // ただし無名クラス由来の失敗なら何とかできる（かもしれない。やってみないと分からない）のでスルー
                    if (!str_contains($e->getMessage(), '@anonymous')) {
                        return "\$this->$vid = new \\__PHP_Incomplete_Class()";
                    }
                }

                // 無名クラスは定義がないのでパースが必要
                // さらにコンストラクタを呼ぶわけには行かない（引数を検出するのは不可能）ので潰す必要もある
                if ($ref->isAnonymous()) {
                    $fname = $ref->getFileName();
                    $sline = $ref->getStartLine();
                    $eline = $ref->getEndLine();
                    $tokens = php_tokens('<?php ' . implode('', array_slice(file($fname), $sline - 1, $eline - $sline + 1)));

                    $block = [];
                    $starting = false;
                    $constructing = 0;
                    $nesting = 0;
                    foreach ($tokens as $token) {
                        $prev = $token->prev() ?? (object) ['id' => null, 'text' => null, 'line' => null];
                        $next = $token->next() ?? (object) ['id' => null, 'text' => null, 'line' => null];
                        assert([$prev, $next]); // あらかじめ取得しておかないとズレるかもしれない

                        // 無名クラスは new class か new #[Attribute] で始まるはず（new #[A] ClassName は許可されていない）
                        if (($token->id === T_NEW && $next->id === T_CLASS) || ($token->id === T_NEW && $next->id === T_ATTRIBUTE)) {
                            $starting = true;
                        }
                        if (!$starting) {
                            continue;
                        }

                        // コンストラクタの呼び出し引数はスキップする
                        if ($constructing !== null) {
                            if ($token->text === '(') {
                                $constructing++;
                            }
                            if ($token->text === ')') {
                                $constructing--;
                                if ($constructing === 0) {
                                    $constructing = null;          // null を終了済みマークとして変数を再利用している
                                    $block[] = [null, '()', null]; // for psr-12
                                    continue;
                                }
                            }
                            if ($constructing) {
                                continue;
                            }
                        }

                        // 引数ありコンストラクタは呼ばないのでリネームしておく
                        if ($token->text === '__construct' && $ref->getConstructor() && $ref->getConstructor()->getNumberOfRequiredParameters()) {
                            $token = clone $token;
                            $token->text = "replaced__construct";
                        }

                        $block[] = $token->clone(text: $token->resolve($ref));

                        if ($token->text === '{') {
                            $nesting++;
                        }
                        if ($token->text === '}') {
                            $nesting--;
                            if ($nesting === 0) {
                                break;
                            }
                        }
                    }

                    $code = php_indent(implode('', array_column($block, 'text')), [
                        'indent'   => $spacer1,
                        'baseline' => -1,
                    ]);
                    if ($raw) {
                        return $code;
                    }
                    $classname = "(function () {\n{$spacer1}return $code;\n{$spacer0}})";
                }
                else {
                    $classname = "\\" . get_class($value) . "::class";
                }

                $privates = [];

                // __serialize があるならそれに従う
                if (method_exists($value, '__serialize')) {
                    $fields = $value->__serialize();
                }
                // __sleep があるならそれをプロパティとする
                elseif (method_exists($value, '__sleep')) {
                    $fields = array_intersect_key(object_properties($value, $privates), array_flip($value->__sleep()));
                }
                // それ以外は適当に漁る
                else {
                    $fields = object_properties($value, $privates);
                }

                return "\$this->new(\$this->$vid, $classname, (function () {\n{$spacer1}return {$export([$fields, $privates], $nest + 1)};\n{$spacer0}}))";
            }
            if (is_resourcable($value)) {
                // スタンダードなリソースなら復元できないこともない
                $meta = stream_get_meta_data($value);
                $stream_type = strtolower($meta['stream_type']);
                if (!in_array($stream_type, ['stdio', 'output', 'temp', 'memory'], true)) {
                    throw new \DomainException('resource is supported stream resource only.');
                }
                $meta['position'] = @ftell($value);
                $meta['context'] = stream_context_get_options($value);
                $meta['buffer'] = null;
                if (in_array($stream_type, ['temp', 'memory'], true)) {
                    $meta['buffer'] = stream_get_contents($value, null, 0);
                }
                return "\$this->$vid = \$this->open({$export($meta, $nest + 1)})";
            }

            return is_null($value) ? 'null' : $var_export($value);
        };

        $exported = $export($value, 1);
        $others = [];
        $vars = [];
        foreach ($var_manager->orphan() as $rid => [$isref, $vid, $var]) {
            $declare = $isref ? "&\$this->$vid" : $export($var, 1);
            $others[] = "\$this->$rid = $declare;";
        }

        static $factory = null;
        if ($factory === null) {
            // @codeCoverageIgnoreStart
            $factory = $export(new #[\AllowDynamicProperties] class() {
                public function new(&$object, $class, $provider)
                {
                    if ($class instanceof \Closure) {
                        $object = $class();
                        $reflection = $this->reflect(get_class($object));
                    }
                    else {
                        $reflection = $this->reflect($class);
                        if ($reflection["constructor"] && $reflection["constructor"]->getNumberOfRequiredParameters() === 0) {
                            $object = $reflection["self"]->newInstance();
                        }
                        else {
                            $object = $reflection["self"]->newInstanceWithoutConstructor();
                        }
                    }
                    [$fields, $privates] = $provider();

                    if ($reflection["unserialize"]) {
                        $object->__unserialize($fields);
                        return $object;
                    }

                    foreach ($reflection["parents"] as $parent) {
                        foreach ($this->reflect($parent->name)["properties"] as $name => $property) {
                            if (isset($privates[$parent->name][$name]) && !$privates[$parent->name][$name] instanceof \__PHP_Incomplete_Class) {
                                $property->setValue($object, $privates[$parent->name][$name]);
                            }
                            if (array_key_exists($name, $fields)) {
                                if (!$fields[$name] instanceof \__PHP_Incomplete_Class) {
                                    $property->setValue($object, $fields[$name]);
                                }
                                unset($fields[$name]);
                            }
                        }
                    }
                    foreach ($fields as $name => $value) {
                        $object->$name = $value;
                    }

                    if ($reflection["wakeup"]) {
                        $object->__wakeup();
                    }

                    return $object;
                }

                public function open($metadata)
                {
                    $resource = fopen($metadata['uri'], $metadata['mode'], false, stream_context_create($metadata['context']));
                    if ($resource === false) {
                        return null;
                    }
                    if ($metadata['seekable'] && is_string($metadata['buffer'])) {
                        fwrite($resource, $metadata['buffer']);
                    }
                    if ($metadata['seekable'] && is_int($metadata['position'])) {
                        fseek($resource, $metadata['position']);
                    }
                    return $resource;
                }

                private function reflect($class)
                {
                    static $cache = [];
                    if (!isset($cache[$class])) {
                        $refclass = new \ReflectionClass($class);
                        $cache[$class] = [
                            "self"        => $refclass,
                            "constructor" => $refclass->getConstructor(),
                            "parents"     => [],
                            "properties"  => [],
                            "unserialize" => $refclass->hasMethod("__unserialize"),
                            "wakeup"      => $refclass->hasMethod("__wakeup"),
                        ];
                        for ($current = $refclass; $current; $current = $current->getParentClass()) {
                            $cache[$class]["parents"][$current->name] = $current;
                        }
                        foreach ($refclass->getProperties() as $property) {
                            if (!$property->isStatic()) {
                                $property->setAccessible(true);
                                $cache[$class]["properties"][$property->name] = $property;
                            }
                        }
                    }
                    return $cache[$class];
                }
            }, -1, true);
            // @codeCoverageIgnoreEnd
        }

        $E = fn($v) => $v;
        $function = <<<PHP
            function (\$args) {
                \$this->args = \$args;
                {$E(implode("\n    ", $others))}
                return $exported;
            }
            PHP;

        if ($options['args']) {
            $result = "fn(\$args) => ({$function})->call($factory, \$args)";
        }
        else {
            $result = "({$function})->call($factory, [])";
        }

        if ($options['format'] === 'minify') {
            $tmp = tempnam(sys_get_temp_dir(), 've3');
            file_put_contents($tmp, "<?php $result;");
            $result = substr(php_strip_whitespace($tmp), 6, -1);
        }

        if ($options['outmode'] === 'eval') {
            $result = "return $result;";
        }
        if ($options['outmode'] === 'file') {
            $result = "<?php return $result;\n";
        }

        if (!$options['return']) {
            echo $result;
        }
        return $result;
    }
}

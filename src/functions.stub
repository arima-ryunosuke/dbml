<?php

# Don't touch this code. This is auto generated.

namespace ryunosuke\dbml;

# constants
if (!defined("ryunosuke\\dbml\\JP_ERA")) {
    /** 和暦 */
    define("ryunosuke\\dbml\\JP_ERA", [
        [
            "name"  => "令和",
            "abbr"  => "R",
            "since" => 1556636400,
        ],
        [
            "name"  => "平成",
            "abbr"  => "H",
            "since" => 600188400,
        ],
        [
            "name"  => "昭和",
            "abbr"  => "S",
            "since" => -1357635600,
        ],
        [
            "name"  => "大正",
            "abbr"  => "T",
            "since" => -1812186000,
        ],
        [
            "name"  => "明治",
            "abbr"  => "M",
            "since" => -3216790800,
        ],
    ]);
}

if (!defined("ryunosuke\\dbml\\KEYWORDS")) {
    /** SQL キーワード（全 RDBMS ごちゃまぜ） */
    define("ryunosuke\\dbml\\KEYWORDS", [
        ""  => "",
        0   => "ACCESSIBLE",
        1   => "ACTION",
        2   => "ADD",
        3   => "AFTER",
        4   => "AGAINST",
        5   => "AGGREGATE",
        6   => "ALGORITHM",
        7   => "ALL",
        8   => "ALTER",
        9   => "ALTER TABLE",
        10  => "ANALYSE",
        11  => "ANALYZE",
        12  => "AND",
        13  => "AS",
        14  => "ASC",
        15  => "AUTOCOMMIT",
        16  => "AUTO_INCREMENT",
        17  => "BACKUP",
        18  => "BEGIN",
        19  => "BETWEEN",
        20  => "BINLOG",
        21  => "BOTH",
        22  => "CASCADE",
        23  => "CASE",
        24  => "CHANGE",
        25  => "CHANGED",
        26  => "CHARACTER SET",
        27  => "CHARSET",
        28  => "CHECK",
        29  => "CHECKSUM",
        30  => "COLLATE",
        31  => "COLLATION",
        32  => "COLUMN",
        33  => "COLUMNS",
        34  => "COMMENT",
        35  => "COMMIT",
        36  => "COMMITTED",
        37  => "COMPRESSED",
        38  => "CONCURRENT",
        39  => "CONSTRAINT",
        40  => "CONTAINS",
        41  => "CONVERT",
        42  => "CREATE",
        43  => "CROSS",
        44  => "CURRENT_TIMESTAMP",
        45  => "DATABASE",
        46  => "DATABASES",
        47  => "DAY",
        48  => "DAY_HOUR",
        49  => "DAY_MINUTE",
        50  => "DAY_SECOND",
        51  => "DEFAULT",
        52  => "DEFINER",
        53  => "DELAYED",
        54  => "DELETE",
        55  => "DELETE FROM",
        56  => "DESC",
        57  => "DESCRIBE",
        58  => "DETERMINISTIC",
        59  => "DISTINCT",
        60  => "DISTINCTROW",
        61  => "DIV",
        62  => "DO",
        63  => "DROP",
        64  => "DUMPFILE",
        65  => "DUPLICATE",
        66  => "DYNAMIC",
        67  => "ELSE",
        68  => "ENCLOSED",
        69  => "END",
        70  => "ENGINE",
        71  => "ENGINES",
        72  => "ENGINE_TYPE",
        73  => "ESCAPE",
        74  => "ESCAPED",
        75  => "EVENTS",
        76  => "EXCEPT",
        77  => "EXECUTE",
        78  => "EXISTS",
        79  => "EXPLAIN",
        80  => "EXTENDED",
        81  => "FAST",
        82  => "FIELDS",
        83  => "FILE",
        84  => "FIRST",
        85  => "FIXED",
        86  => "FLUSH",
        87  => "FOR",
        88  => "FORCE",
        89  => "FOREIGN",
        90  => "FROM",
        91  => "FULL",
        92  => "FULLTEXT",
        93  => "FUNCTION",
        94  => "GLOBAL",
        95  => "GRANT",
        96  => "GRANTS",
        97  => "GROUP",
        98  => "GROUP_CONCAT",
        99  => "HAVING",
        100 => "HEAP",
        101 => "HIGH_PRIORITY",
        102 => "HOSTS",
        103 => "HOUR",
        104 => "HOUR_MINUTE",
        105 => "HOUR_SECOND",
        106 => "IDENTIFIED",
        107 => "IF",
        108 => "IFNULL",
        109 => "IGNORE",
        110 => "IN",
        111 => "INDEX",
        112 => "INDEXES",
        113 => "INFILE",
        114 => "INNER",
        115 => "INSERT",
        116 => "INSERT_ID",
        117 => "INSERT_METHOD",
        118 => "INTERSECT",
        119 => "INTERVAL",
        120 => "INTO",
        121 => "INVOKER",
        122 => "IS",
        123 => "ISOLATION",
        124 => "JOIN",
        125 => "JSON_ARRAY",
        126 => "JSON_ARRAY_APPEND",
        127 => "JSON_ARRAY_INSERT",
        128 => "JSON_CONTAINS",
        129 => "JSON_CONTAINS_PATH",
        130 => "JSON_DEPTH",
        131 => "JSON_EXTRACT",
        132 => "JSON_INSERT",
        133 => "JSON_KEYS",
        134 => "JSON_LENGTH",
        135 => "JSON_MERGE_PATCH",
        136 => "JSON_MERGE_PRESERVE",
        137 => "JSON_OBJECT",
        138 => "JSON_PRETTY",
        139 => "JSON_QUOTE",
        140 => "JSON_REMOVE",
        141 => "JSON_REPLACE",
        142 => "JSON_SEARCH",
        143 => "JSON_SET",
        144 => "JSON_STORAGE_SIZE",
        145 => "JSON_TYPE",
        146 => "JSON_UNQUOTE",
        147 => "JSON_VALID",
        148 => "KEY",
        149 => "KEYS",
        150 => "KILL",
        151 => "LAST_INSERT_ID",
        152 => "LEADING",
        153 => "LEFT",
        154 => "LEVEL",
        155 => "LIKE",
        156 => "LIMIT",
        157 => "LINEAR",
        158 => "LINES",
        159 => "LOAD",
        160 => "LOCAL",
        161 => "LOCK",
        162 => "LOCKS",
        163 => "LOGS",
        164 => "LOW_PRIORITY",
        165 => "MARIA",
        166 => "MASTER",
        167 => "MASTER_CONNECT_RETRY",
        168 => "MASTER_HOST",
        169 => "MASTER_LOG_FILE",
        170 => "MATCH",
        171 => "MAX_CONNECTIONS_PER_HOUR",
        172 => "MAX_QUERIES_PER_HOUR",
        173 => "MAX_ROWS",
        174 => "MAX_UPDATES_PER_HOUR",
        175 => "MAX_USER_CONNECTIONS",
        176 => "MEDIUM",
        177 => "MERGE",
        178 => "MINUTE",
        179 => "MINUTE_SECOND",
        180 => "MIN_ROWS",
        181 => "MODE",
        182 => "MODIFY",
        183 => "MONTH",
        184 => "MRG_MYISAM",
        185 => "MYISAM",
        186 => "NAMES",
        187 => "NATURAL",
        188 => "NOT",
        189 => "NOW()",
        190 => "NULL",
        191 => "OFFSET",
        192 => "ON",
        193 => "ON DELETE",
        194 => "ON UPDATE",
        195 => "OPEN",
        196 => "OPTIMIZE",
        197 => "OPTION",
        198 => "OPTIONALLY",
        199 => "OR",
        200 => "ORDER",
        201 => "BY",
        202 => "OUTER",
        203 => "OUTFILE",
        204 => "PACK_KEYS",
        205 => "PAGE",
        206 => "PARTIAL",
        207 => "PARTITION",
        208 => "PARTITIONS",
        209 => "PASSWORD",
        210 => "PRIMARY",
        211 => "PRIVILEGES",
        212 => "PROCEDURE",
        213 => "PROCESS",
        214 => "PROCESSLIST",
        215 => "PURGE",
        216 => "QUICK",
        217 => "RAID0",
        218 => "RAID_CHUNKS",
        219 => "RAID_CHUNKSIZE",
        220 => "RAID_TYPE",
        221 => "RANGE",
        222 => "READ",
        223 => "READ_ONLY",
        224 => "READ_WRITE",
        225 => "REFERENCES",
        226 => "REGEXP",
        227 => "RELOAD",
        228 => "RENAME",
        229 => "REPAIR",
        230 => "REPEATABLE",
        231 => "REPLACE",
        232 => "REPLICATION",
        233 => "RESET",
        234 => "RESTORE",
        235 => "RESTRICT",
        236 => "RETURN",
        237 => "RETURNS",
        238 => "REVOKE",
        239 => "RIGHT",
        240 => "RLIKE",
        241 => "ROLLBACK",
        242 => "ROLLUP",
        243 => "ROW",
        244 => "ROWS",
        245 => "ROW_FORMAT",
        246 => "SECOND",
        247 => "SECURITY",
        248 => "SELECT",
        249 => "SEPARATOR",
        250 => "SERIALIZABLE",
        251 => "SESSION",
        252 => "SET",
        253 => "SHARE",
        254 => "SHOW",
        255 => "SHUTDOWN",
        256 => "SLAVE",
        257 => "SONAME",
        258 => "SOUNDS",
        259 => "SQL",
        260 => "SQL_AUTO_IS_NULL",
        261 => "SQL_BIG_RESULT",
        262 => "SQL_BIG_SELECTS",
        263 => "SQL_BIG_TABLES",
        264 => "SQL_BUFFER_RESULT",
        265 => "SQL_CACHE",
        266 => "SQL_CALC_FOUND_ROWS",
        267 => "SQL_LOG_BIN",
        268 => "SQL_LOG_OFF",
        269 => "SQL_LOG_UPDATE",
        270 => "SQL_LOW_PRIORITY_UPDATES",
        271 => "SQL_MAX_JOIN_SIZE",
        272 => "SQL_NO_CACHE",
        273 => "SQL_QUOTE_SHOW_CREATE",
        274 => "SQL_SAFE_UPDATES",
        275 => "SQL_SELECT_LIMIT",
        276 => "SQL_SLAVE_SKIP_COUNTER",
        277 => "SQL_SMALL_RESULT",
        278 => "SQL_WARNINGS",
        279 => "START",
        280 => "STARTING",
        281 => "STATUS",
        282 => "STOP",
        283 => "STORAGE",
        284 => "STRAIGHT_JOIN",
        285 => "STRING",
        286 => "STRIPED",
        287 => "SUPER",
        288 => "TABLE",
        289 => "TABLES",
        290 => "TEMPORARY",
        291 => "TERMINATED",
        292 => "THEN",
        293 => "TO",
        294 => "TRAILING",
        295 => "TRANSACTIONAL",
        296 => "TRUE",
        297 => "TRUNCATE",
        298 => "TYPE",
        299 => "TYPES",
        300 => "UNCOMMITTED",
        301 => "UNION",
        302 => "UNION ALL",
        303 => "UNIQUE",
        304 => "UNLOCK",
        305 => "UNSIGNED",
        306 => "UPDATE",
        307 => "USAGE",
        308 => "USE",
        309 => "USING",
        310 => "VALUES",
        311 => "VARIABLES",
        312 => "VIEW",
        313 => "WHEN",
        314 => "WHERE",
        315 => "WITH",
        316 => "WORK",
        317 => "WRITE",
        318 => "XOR",
        319 => "YEAR_MONTH",
        320 => "ABS",
        321 => "ACOS",
        322 => "ADDDATE",
        323 => "ADDTIME",
        324 => "AES_DECRYPT",
        325 => "AES_ENCRYPT",
        326 => "AREA",
        327 => "ASBINARY",
        328 => "ASCII",
        329 => "ASIN",
        330 => "ASTEXT",
        331 => "ATAN",
        332 => "ATAN2",
        333 => "AVG",
        334 => "BDMPOLYFROMTEXT",
        335 => "BDMPOLYFROMWKB",
        336 => "BDPOLYFROMTEXT",
        337 => "BDPOLYFROMWKB",
        338 => "BENCHMARK",
        339 => "BIN",
        340 => "BIT_AND",
        341 => "BIT_COUNT",
        342 => "BIT_LENGTH",
        343 => "BIT_OR",
        344 => "BIT_XOR",
        345 => "BOUNDARY",
        346 => "BUFFER",
        347 => "CAST",
        348 => "CEIL",
        349 => "CEILING",
        350 => "CENTROID",
        351 => "CHAR",
        352 => "CHARACTER_LENGTH",
        353 => "CHARSET",
        354 => "CHAR_LENGTH",
        355 => "COALESCE",
        356 => "COERCIBILITY",
        357 => "COLLATION",
        358 => "COMPRESS",
        359 => "CONCAT",
        360 => "CONCAT_WS",
        361 => "CONNECTION_ID",
        362 => "CONTAINS",
        363 => "CONV",
        364 => "CONVERT",
        365 => "CONVERT_TZ",
        366 => "CONVEXHULL",
        367 => "COS",
        368 => "COT",
        369 => "COUNT",
        370 => "CRC32",
        371 => "CROSSES",
        372 => "CURDATE",
        373 => "CURRENT_DATE",
        374 => "CURRENT_TIME",
        375 => "CURRENT_TIMESTAMP",
        376 => "CURRENT_USER",
        377 => "CURTIME",
        378 => "DATABASE",
        379 => "DATE",
        380 => "DATEDIFF",
        381 => "DATE_ADD",
        382 => "DATE_DIFF",
        383 => "DATE_FORMAT",
        384 => "DATE_SUB",
        385 => "DAY",
        386 => "DAYNAME",
        387 => "DAYOFMONTH",
        388 => "DAYOFWEEK",
        389 => "DAYOFYEAR",
        390 => "DECODE",
        391 => "DEFAULT",
        392 => "DEGREES",
        393 => "DES_DECRYPT",
        394 => "DES_ENCRYPT",
        395 => "DIFFERENCE",
        396 => "DIMENSION",
        397 => "DISJOINT",
        398 => "DISTANCE",
        399 => "ELT",
        400 => "ENCODE",
        401 => "ENCRYPT",
        402 => "ENDPOINT",
        403 => "ENVELOPE",
        404 => "EQUALS",
        405 => "EXP",
        406 => "EXPORT_SET",
        407 => "EXTERIORRING",
        408 => "EXTRACT",
        409 => "EXTRACTVALUE",
        410 => "FIELD",
        411 => "FIND_IN_SET",
        412 => "FLOOR",
        413 => "FORMAT",
        414 => "FOUND_ROWS",
        415 => "FROM_DAYS",
        416 => "FROM_UNIXTIME",
        417 => "GEOMCOLLFROMTEXT",
        418 => "GEOMCOLLFROMWKB",
        419 => "GEOMETRYCOLLECTION",
        420 => "GEOMETRYCOLLECTIONFROMTEXT",
        421 => "GEOMETRYCOLLECTIONFROMWKB",
        422 => "GEOMETRYFROMTEXT",
        423 => "GEOMETRYFROMWKB",
        424 => "GEOMETRYN",
        425 => "GEOMETRYTYPE",
        426 => "GEOMFROMTEXT",
        427 => "GEOMFROMWKB",
        428 => "GET_FORMAT",
        429 => "GET_LOCK",
        430 => "GLENGTH",
        431 => "GREATEST",
        432 => "GROUP_CONCAT",
        433 => "GROUP_UNIQUE_USERS",
        434 => "HEX",
        435 => "HOUR",
        436 => "IF",
        437 => "IFNULL",
        438 => "INET_ATON",
        439 => "INET_NTOA",
        440 => "INSERT",
        441 => "INSTR",
        442 => "INTERIORRINGN",
        443 => "INTERSECTION",
        444 => "INTERSECTS",
        445 => "INTERVAL",
        446 => "ISCLOSED",
        447 => "ISEMPTY",
        448 => "ISNULL",
        449 => "ISRING",
        450 => "ISSIMPLE",
        451 => "IS_FREE_LOCK",
        452 => "IS_USED_LOCK",
        453 => "LAST_DAY",
        454 => "LAST_INSERT_ID",
        455 => "LCASE",
        456 => "LEAST",
        457 => "LEFT",
        458 => "LENGTH",
        459 => "LINEFROMTEXT",
        460 => "LINEFROMWKB",
        461 => "LINESTRING",
        462 => "LINESTRINGFROMTEXT",
        463 => "LINESTRINGFROMWKB",
        464 => "LN",
        465 => "LOAD_FILE",
        466 => "LOCALTIME",
        467 => "LOCALTIMESTAMP",
        468 => "LOCATE",
        469 => "LOG",
        470 => "LOG10",
        471 => "LOG2",
        472 => "LOWER",
        473 => "LPAD",
        474 => "LTRIM",
        475 => "MAKEDATE",
        476 => "MAKETIME",
        477 => "MAKE_SET",
        478 => "MASTER_POS_WAIT",
        479 => "MAX",
        480 => "MBRCONTAINS",
        481 => "MBRDISJOINT",
        482 => "MBREQUAL",
        483 => "MBRINTERSECTS",
        484 => "MBROVERLAPS",
        485 => "MBRTOUCHES",
        486 => "MBRWITHIN",
        487 => "MD5",
        488 => "MICROSECOND",
        489 => "MID",
        490 => "MIN",
        491 => "MINUTE",
        492 => "MLINEFROMTEXT",
        493 => "MLINEFROMWKB",
        494 => "MOD",
        495 => "MONTH",
        496 => "MONTHNAME",
        497 => "MPOINTFROMTEXT",
        498 => "MPOINTFROMWKB",
        499 => "MPOLYFROMTEXT",
        500 => "MPOLYFROMWKB",
        501 => "MULTILINESTRING",
        502 => "MULTILINESTRINGFROMTEXT",
        503 => "MULTILINESTRINGFROMWKB",
        504 => "MULTIPOINT",
        505 => "MULTIPOINTFROMTEXT",
        506 => "MULTIPOINTFROMWKB",
        507 => "MULTIPOLYGON",
        508 => "MULTIPOLYGONFROMTEXT",
        509 => "MULTIPOLYGONFROMWKB",
        510 => "NAME_CONST",
        511 => "NULLIF",
        512 => "NUMGEOMETRIES",
        513 => "NUMINTERIORRINGS",
        514 => "NUMPOINTS",
        515 => "OCT",
        516 => "OCTET_LENGTH",
        517 => "OLD_PASSWORD",
        518 => "ORD",
        519 => "OVERLAPS",
        520 => "PASSWORD",
        521 => "PERIOD_ADD",
        522 => "PERIOD_DIFF",
        523 => "PI",
        524 => "POINT",
        525 => "POINTFROMTEXT",
        526 => "POINTFROMWKB",
        527 => "POINTN",
        528 => "POINTONSURFACE",
        529 => "POLYFROMTEXT",
        530 => "POLYFROMWKB",
        531 => "POLYGON",
        532 => "POLYGONFROMTEXT",
        533 => "POLYGONFROMWKB",
        534 => "POSITION",
        535 => "POW",
        536 => "POWER",
        537 => "QUARTER",
        538 => "QUOTE",
        539 => "RADIANS",
        540 => "RAND",
        541 => "RELATED",
        542 => "RELEASE_LOCK",
        543 => "REPEAT",
        544 => "REPLACE",
        545 => "REVERSE",
        546 => "RIGHT",
        547 => "ROUND",
        548 => "ROW_COUNT",
        549 => "RPAD",
        550 => "RTRIM",
        551 => "SCHEMA",
        552 => "SECOND",
        553 => "SEC_TO_TIME",
        554 => "SESSION_USER",
        555 => "SHA",
        556 => "SHA1",
        557 => "SIGN",
        558 => "SIN",
        559 => "SLEEP",
        560 => "SOUNDEX",
        561 => "SPACE",
        562 => "SQRT",
        563 => "SRID",
        564 => "STARTPOINT",
        565 => "STD",
        566 => "STDDEV",
        567 => "STDDEV_POP",
        568 => "STDDEV_SAMP",
        569 => "STRCMP",
        570 => "STR_TO_DATE",
        571 => "SUBDATE",
        572 => "SUBSTR",
        573 => "SUBSTRING",
        574 => "SUBSTRING_INDEX",
        575 => "SUBTIME",
        576 => "SUM",
        577 => "SYMDIFFERENCE",
        578 => "SYSDATE",
        579 => "SYSTEM_USER",
        580 => "TAN",
        581 => "TIME",
        582 => "TIMEDIFF",
        583 => "TIMESTAMP",
        584 => "TIMESTAMPADD",
        585 => "TIMESTAMPDIFF",
        586 => "TIME_FORMAT",
        587 => "TIME_TO_SEC",
        588 => "TOUCHES",
        589 => "TO_DAYS",
        590 => "TRIM",
        591 => "TRUNCATE",
        592 => "UCASE",
        593 => "UNCOMPRESS",
        594 => "UNCOMPRESSED_LENGTH",
        595 => "UNHEX",
        596 => "UNIQUE_USERS",
        597 => "UNIX_TIMESTAMP",
        598 => "UPDATEXML",
        599 => "UPPER",
        600 => "USER",
        601 => "UTC_DATE",
        602 => "UTC_TIME",
        603 => "UTC_TIMESTAMP",
        604 => "UUID",
        605 => "VARIANCE",
        606 => "VAR_POP",
        607 => "VAR_SAMP",
        608 => "VERSION",
        609 => "WEEK",
        610 => "WEEKDAY",
        611 => "WEEKOFYEAR",
        612 => "WITHIN",
        613 => "X",
        614 => "Y",
        615 => "YEAR",
        616 => "YEARWEEK",
    ]);
}

if (!defined("ryunosuke\\dbml\\JSON_MAX_DEPTH")) {
    /** json_*** 関数で $depth 引数を表す定数 */
    define("ryunosuke\\dbml\\JSON_MAX_DEPTH", -1);
}

if (!defined("ryunosuke\\dbml\\JSON_ES5")) {
    /** json_*** 関数で json5 を取り扱うかの定数 */
    define("ryunosuke\\dbml\\JSON_ES5", -100);
}

if (!defined("ryunosuke\\dbml\\JSON_INT_AS_STRING")) {
    /** json_*** 関数で整数を常に文字列で返すかの定数 */
    define("ryunosuke\\dbml\\JSON_INT_AS_STRING", -101);
}

if (!defined("ryunosuke\\dbml\\JSON_FLOAT_AS_STRING")) {
    /** json_*** 関数で小数を常に文字列で返すかの定数 */
    define("ryunosuke\\dbml\\JSON_FLOAT_AS_STRING", -102);
}

if (!defined("ryunosuke\\dbml\\TOKEN_NAME")) {
    /** parse_php 関数でトークン名変換をするか */
    define("ryunosuke\\dbml\\TOKEN_NAME", 2);
}


# functions
if (!isset($excluded_functions["arrayize"]) && (!function_exists("ryunosuke\\dbml\\arrayize") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\arrayize"))->isInternal()))) {
    /**
     * 引数の配列を生成する。
     *
     * 配列以外を渡すと配列化されて追加される。
     * 連想配列は未対応。あくまで普通の配列化のみ。
     * iterable や Traversable は考慮せずあくまで「配列」としてチェックする。
     *
     * Example:
     * ```php
     * that(arrayize(1, 2, 3))->isSame([1, 2, 3]);
     * that(arrayize([1], [2], [3]))->isSame([1, 2, 3]);
     * $object = new \stdClass();
     * that(arrayize($object, false, [1, 2, 3]))->isSame([$object, false, 1, 2, 3]);
     * ```
     *
     * @param mixed ...$variadic 生成する要素（可変引数）
     * @return array 引数を配列化したもの
     */
    function arrayize(...$variadic)
    {
        $result = [];
        foreach ($variadic as $arg) {
            if (!is_array($arg)) {
                $result[] = $arg;
            }
            elseif (!is_hasharray($arg)) {
                $result = array_merge($result, $arg);
            }
            else {
                $result += $arg;
            }
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\arrayize") && !defined("ryunosuke\\dbml\\arrayize")) {
    define("ryunosuke\\dbml\\arrayize", "ryunosuke\\dbml\\arrayize");
}

if (!isset($excluded_functions["is_indexarray"]) && (!function_exists("ryunosuke\\dbml\\is_indexarray") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\is_indexarray"))->isInternal()))) {
    /**
     * 配列が数値配列か調べる
     *
     * 空の配列も数値配列とみなす。
     * さらにいわゆる「連番配列」ではなく「キーが数値のみか？」で判定する。
     *
     * つまり、 is_hasharray とは排他的ではない。
     *
     * Example:
     * ```php
     * that(is_indexarray([]))->isTrue();
     * that(is_indexarray([1, 2, 3]))->isTrue();
     * that(is_indexarray(['x' => 'X']))->isFalse();
     * // 抜け番があっても true になる（これは is_hasharray も true になる）
     * that(is_indexarray([1 => 1, 2 => 2, 3 => 3]))->isTrue();
     * ```
     *
     * @param array $array 調べる配列
     * @return bool 数値配列なら true
     */
    function is_indexarray($array)
    {
        foreach ($array as $k => $dummy) {
            if (!is_int($k)) {
                return false;
            }
        }
        return true;
    }
}
if (function_exists("ryunosuke\\dbml\\is_indexarray") && !defined("ryunosuke\\dbml\\is_indexarray")) {
    define("ryunosuke\\dbml\\is_indexarray", "ryunosuke\\dbml\\is_indexarray");
}

if (!isset($excluded_functions["is_hasharray"]) && (!function_exists("ryunosuke\\dbml\\is_hasharray") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\is_hasharray"))->isInternal()))) {
    /**
     * 配列が連想配列か調べる
     *
     * 空の配列は普通の配列とみなす。
     *
     * Example:
     * ```php
     * that(is_hasharray([]))->isFalse();
     * that(is_hasharray([1, 2, 3]))->isFalse();
     * that(is_hasharray(['x' => 'X']))->isTrue();
     * ```
     *
     * @param array $array 調べる配列
     * @return bool 連想配列なら true
     */
    function is_hasharray(array $array)
    {
        $i = 0;
        foreach ($array as $k => $dummy) {
            if ($k !== $i++) {
                return true;
            }
        }
        return false;
    }
}
if (function_exists("ryunosuke\\dbml\\is_hasharray") && !defined("ryunosuke\\dbml\\is_hasharray")) {
    define("ryunosuke\\dbml\\is_hasharray", "ryunosuke\\dbml\\is_hasharray");
}

if (!isset($excluded_functions["first_key"]) && (!function_exists("ryunosuke\\dbml\\first_key") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\first_key"))->isInternal()))) {
    /**
     * 配列の最初のキーを返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(first_key(['a', 'b', 'c']))->isSame(0);
     * that(first_key([], 999))->isSame(999);
     * ```
     *
     * @param iterable $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 最初のキー
     */
    function first_key($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        /** @noinspection PhpUnusedLocalVariableInspection */
        [$k, $v] = first_keyvalue($array);
        return $k;
    }
}
if (function_exists("ryunosuke\\dbml\\first_key") && !defined("ryunosuke\\dbml\\first_key")) {
    define("ryunosuke\\dbml\\first_key", "ryunosuke\\dbml\\first_key");
}

if (!isset($excluded_functions["first_value"]) && (!function_exists("ryunosuke\\dbml\\first_value") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\first_value"))->isInternal()))) {
    /**
     * 配列の最初の値を返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(first_value(['a', 'b', 'c']))->isSame('a');
     * that(first_value([], 999))->isSame(999);
     * ```
     *
     * @param iterable $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 最初の値
     */
    function first_value($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        /** @noinspection PhpUnusedLocalVariableInspection */
        [$k, $v] = first_keyvalue($array);
        return $v;
    }
}
if (function_exists("ryunosuke\\dbml\\first_value") && !defined("ryunosuke\\dbml\\first_value")) {
    define("ryunosuke\\dbml\\first_value", "ryunosuke\\dbml\\first_value");
}

if (!isset($excluded_functions["first_keyvalue"]) && (!function_exists("ryunosuke\\dbml\\first_keyvalue") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\first_keyvalue"))->isInternal()))) {
    /**
     * 配列の最初のキー/値ペアをタプルで返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(first_keyvalue(['a', 'b', 'c']))->isSame([0, 'a']);
     * that(first_keyvalue([], 999))->isSame(999);
     * ```
     *
     * @param iterable $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return array [最初のキー, 最初の値]
     */
    function first_keyvalue($array, $default = null)
    {
        foreach ($array as $k => $v) {
            return [$k, $v];
        }
        return $default;
    }
}
if (function_exists("ryunosuke\\dbml\\first_keyvalue") && !defined("ryunosuke\\dbml\\first_keyvalue")) {
    define("ryunosuke\\dbml\\first_keyvalue", "ryunosuke\\dbml\\first_keyvalue");
}

if (!isset($excluded_functions["last_key"]) && (!function_exists("ryunosuke\\dbml\\last_key") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\last_key"))->isInternal()))) {
    /**
     * 配列の最後のキーを返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(last_key(['a', 'b', 'c']))->isSame(2);
     * that(last_key([], 999))->isSame(999);
     * ```
     *
     * @param iterable $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 最後のキー
     */
    function last_key($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        /** @noinspection PhpUnusedLocalVariableInspection */
        [$k, $v] = last_keyvalue($array);
        return $k;
    }
}
if (function_exists("ryunosuke\\dbml\\last_key") && !defined("ryunosuke\\dbml\\last_key")) {
    define("ryunosuke\\dbml\\last_key", "ryunosuke\\dbml\\last_key");
}

if (!isset($excluded_functions["last_value"]) && (!function_exists("ryunosuke\\dbml\\last_value") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\last_value"))->isInternal()))) {
    /**
     * 配列の最後の値を返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(last_value(['a', 'b', 'c']))->isSame('c');
     * that(last_value([], 999))->isSame(999);
     * ```
     *
     * @param iterable $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 最後の値
     */
    function last_value($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        /** @noinspection PhpUnusedLocalVariableInspection */
        [$k, $v] = last_keyvalue($array);
        return $v;
    }
}
if (function_exists("ryunosuke\\dbml\\last_value") && !defined("ryunosuke\\dbml\\last_value")) {
    define("ryunosuke\\dbml\\last_value", "ryunosuke\\dbml\\last_value");
}

if (!isset($excluded_functions["last_keyvalue"]) && (!function_exists("ryunosuke\\dbml\\last_keyvalue") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\last_keyvalue"))->isInternal()))) {
    /**
     * 配列の最後のキー/値ペアをタプルで返す
     *
     * 空の場合は $default を返す。
     *
     * Example:
     * ```php
     * that(last_keyvalue(['a', 'b', 'c']))->isSame([2, 'c']);
     * that(last_keyvalue([], 999))->isSame(999);
     * ```
     *
     * @param iterable $array 対象配列
     * @param mixed $default 無かった場合のデフォルト値
     * @return array [最後のキー, 最後の値]
     */
    function last_keyvalue($array, $default = null)
    {
        if (is_empty($array)) {
            return $default;
        }
        if (is_array($array)) {
            if (function_exists('array_key_last')) {
                $k = array_key_last($array);
                return [$k, $array[$k]];
            }
            // @codeCoverageIgnoreStart
            $v = end($array);
            $k = key($array);
            return [$k, $v];
            // @codeCoverageIgnoreEnd
        }
        /** @noinspection PhpStatementHasEmptyBodyInspection */
        foreach ($array as $k => $v) {
            // dummy
        }
        // $k がセットされてるなら「ループが最低でも1度回った（≠空）」とみなせる
        if (isset($k)) {
            /** @noinspection PhpUndefinedVariableInspection */
            return [$k, $v];
        }
        return $default;
    }
}
if (function_exists("ryunosuke\\dbml\\last_keyvalue") && !defined("ryunosuke\\dbml\\last_keyvalue")) {
    define("ryunosuke\\dbml\\last_keyvalue", "ryunosuke\\dbml\\last_keyvalue");
}

if (!isset($excluded_functions["array_add"]) && (!function_exists("ryunosuke\\dbml\\array_add") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_add"))->isInternal()))) {
    /**
     * 配列の+演算子の関数版
     *
     * Example:
     * ```php
     * // ただの加算の関数版なので同じキーは上書きされない
     * that(array_add(['a', 'b', 'c'], ['X']))->isSame(['a', 'b', 'c']);
     * // 異なるキーは生える
     * that(array_add(['a', 'b', 'c'], ['x' => 'X']))->isSame(['a', 'b', 'c', 'x' => 'X']);
     * ```
     *
     * @param array ...$variadic 足す配列（可変引数）
     * @return array 足された配列
     */
    function array_add(...$variadic)
    {
        $array = [];
        foreach ($variadic as $arg) {
            $array += $arg;
        }
        return $array;
    }
}
if (function_exists("ryunosuke\\dbml\\array_add") && !defined("ryunosuke\\dbml\\array_add")) {
    define("ryunosuke\\dbml\\array_add", "ryunosuke\\dbml\\array_add");
}

if (!isset($excluded_functions["array_implode"]) && (!function_exists("ryunosuke\\dbml\\array_implode") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_implode"))->isInternal()))) {
    /**
     * 配列の各要素の間に要素を差し込む
     *
     * 歴史的な理由はないが、引数をどちらの順番でも受けつけることが可能。
     * ただし、$glue を先に渡すパターンの場合は配列指定が可変引数渡しになる。
     *
     * 文字キーは保存されるが数値キーは再割り振りされる。
     *
     * Example:
     * ```php
     * // (配列, 要素) の呼び出し
     * that(array_implode(['a', 'b', 'c'], 'X'))->isSame(['a', 'X', 'b', 'X', 'c']);
     * // (要素, ...配列) の呼び出し
     * that(array_implode('X', 'a', 'b', 'c'))->isSame(['a', 'X', 'b', 'X', 'c']);
     * ```
     *
     * @param iterable|string $array 対象配列
     * @param string $glue 差し込む要素
     * @return array 差し込まれた配列
     */
    function array_implode($array, $glue)
    {
        // 第1引数が回せない場合は引数を入れ替えて可変引数パターン
        if (!is_array($array) && !$array instanceof \Traversable) {
            return array_implode(array_slice(func_get_args(), 1), $array);
        }

        $result = [];
        foreach ($array as $k => $v) {
            if (is_int($k)) {
                $result[] = $v;
            }
            else {
                $result[$k] = $v;
            }
            $result[] = $glue;
        }
        array_pop($result);
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\array_implode") && !defined("ryunosuke\\dbml\\array_implode")) {
    define("ryunosuke\\dbml\\array_implode", "ryunosuke\\dbml\\array_implode");
}

if (!isset($excluded_functions["array_explode"]) && (!function_exists("ryunosuke\\dbml\\array_explode") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_explode"))->isInternal()))) {
    /**
     * 配列を指定条件で分割する
     *
     * 文字列の explode を更に一階層掘り下げたイメージ。
     * $condition で指定された要素は結果配列に含まれない。
     *
     * $condition にはクロージャが指定できる。クロージャの場合は true 相当を返した場合に分割要素とみなされる。
     * 引数は (値, キー)の順番。
     *
     * $limit に負数を与えると「その絶対値-1までを結合したものと残り」を返す。
     * 端的に言えば「正数を与えると後詰めでその個数で返す」「負数を与えると前詰めでその（絶対値）個数で返す」という動作になる。
     *
     * Example:
     * ```php
     * // null 要素で分割
     * that(array_explode(['a', null, 'b', 'c'], null))->isSame([['a'], [2 => 'b', 3 => 'c']]);
     * // クロージャで分割（大文字で分割）
     * that(array_explode(['a', 'B', 'c', 'D', 'e'], function($v){return ctype_upper($v);}))->isSame([['a'], [2 => 'c'], [4 => 'e']]);
     * // 負数指定
     * that(array_explode(['a', null, 'b', null, 'c'], null, -2))->isSame([[0 => 'a', 1 => null, 2 => 'b'], [4 => 'c']]);
     * ```
     *
     * @param iterable $array 対象配列
     * @param mixed $condition 分割条件
     * @param int $limit 最大分割数
     * @return array 分割された配列
     */
    function array_explode($array, $condition, $limit = \PHP_INT_MAX)
    {
        $array = arrayval($array, false);

        $limit = (int) $limit;
        if ($limit < 0) {
            // キーまで考慮するとかなりややこしくなるので富豪的にやる
            $reverse = array_explode(array_reverse($array, true), $condition, -$limit);
            $reverse = array_map(function ($v) { return array_reverse($v, true); }, $reverse);
            return array_reverse($reverse);
        }
        // explode において 0 は 1 と等しい
        if ($limit === 0) {
            $limit = 1;
        }

        $result = [];
        $chunk = [];
        $n = -1;
        foreach ($array as $k => $v) {
            $n++;

            if ($limit === 1) {
                $chunk = array_slice($array, $n, null, true);
                break;
            }

            if ($condition instanceof \Closure) {
                $match = $condition($v, $k, $n);
            }
            else {
                $match = $condition === $v;
            }

            if ($match) {
                $limit--;
                $result[] = $chunk;
                $chunk = [];
            }
            else {
                $chunk[$k] = $v;
            }
        }
        $result[] = $chunk;
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\array_explode") && !defined("ryunosuke\\dbml\\array_explode")) {
    define("ryunosuke\\dbml\\array_explode", "ryunosuke\\dbml\\array_explode");
}

if (!isset($excluded_functions["array_sprintf"]) && (!function_exists("ryunosuke\\dbml\\array_sprintf") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_sprintf"))->isInternal()))) {
    /**
     * キーと値で sprintf する
     *
     * 配列の各要素を文字列化して返すイメージ。
     * $glue を与えるとさらに implode して返す（返り値が文字列になる）。
     *
     * $format は書式文字列（$v, $k）。
     * callable を与えると sprintf ではなくコールバック処理になる（$v, $k）。
     * 省略（null）するとキーを format 文字列、値を引数として **vsprintf** する。
     *
     * Example:
     * ```php
     * $array = ['key1' => 'val1', 'key2' => 'val2'];
     * // key, value を利用した sprintf
     * that(array_sprintf($array, '%2$s=%1$s'))->isSame(['key1=val1', 'key2=val2']);
     * // 第3引数を与えるとさらに implode される
     * that(array_sprintf($array, '%2$s=%1$s', ' '))->isSame('key1=val1 key2=val2');
     * // クロージャを与えるとコールバック動作になる
     * $closure = function($v, $k){return "$k=" . strtoupper($v);};
     * that(array_sprintf($array, $closure, ' '))->isSame('key1=VAL1 key2=VAL2');
     * // 省略すると vsprintf になる
     * that(array_sprintf([
     *     'str:%s,int:%d' => ['sss', '3.14'],
     *     'single:%s'     => 'str',
     * ], null, '|'))->isSame('str:sss,int:3|single:str');
     * ```
     *
     * @param iterable $array 対象配列
     * @param string|callable|null $format 書式文字列あるいはクロージャ
     * @param ?string $glue 結合文字列。未指定時は implode しない
     * @return array|string sprintf された配列
     */
    function array_sprintf($array, $format = null, $glue = null)
    {
        if (is_callable($format)) {
            $callback = func_user_func_array($format);
        }
        elseif ($format === null) {
            $callback = function ($v, $k, $n) { return vsprintf($k, is_array($v) ? $v : [$v]); };
        }
        else {
            $callback = function ($v, $k, $n) use ($format) { return sprintf($format, $v, $k); };
        }

        $result = [];
        $n = 0;
        foreach ($array as $k => $v) {
            $result[] = $callback($v, $k, $n++);
        }

        if ($glue !== null) {
            return implode($glue, $result);
        }

        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\array_sprintf") && !defined("ryunosuke\\dbml\\array_sprintf")) {
    define("ryunosuke\\dbml\\array_sprintf", "ryunosuke\\dbml\\array_sprintf");
}

if (!isset($excluded_functions["array_strpad"]) && (!function_exists("ryunosuke\\dbml\\array_strpad") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_strpad"))->isInternal()))) {
    /**
     * 配列のキー・要素に文字列を付加する
     *
     * $key_prefix, $val_prefix でそれぞれ「キーに付与する文字列」「値に付与する文字列」が指定できる。
     * 配列を与えると [サフィックス, プレフィックス] という意味になる。
     * デフォルト（ただの文字列）はプレフィックス（値だけに付与したいなら array_map で十分なので）。
     *
     * Example:
     * ```php
     * $array = ['key1' => 'val1', 'key2' => 'val2'];
     * // キーにプレフィックス付与
     * that(array_strpad($array, 'prefix-'))->isSame(['prefix-key1' => 'val1', 'prefix-key2' => 'val2']);
     * // 値にサフィックス付与
     * that(array_strpad($array, '', ['-suffix']))->isSame(['key1' => 'val1-suffix', 'key2' => 'val2-suffix']);
     * ```
     *
     * @param iterable $array 対象配列
     * @param string|array $key_prefix キー側の付加文字列
     * @param string|array $val_prefix 値側の付加文字列
     * @return array 文字列付与された配列
     */
    function array_strpad($array, $key_prefix, $val_prefix = '')
    {
        $key_suffix = '';
        if (is_array($key_prefix)) {
            [$key_suffix, $key_prefix] = $key_prefix + [1 => ''];
        }
        $val_suffix = '';
        if (is_array($val_prefix)) {
            [$val_suffix, $val_prefix] = $val_prefix + [1 => ''];
        }

        $enable_key = strlen($key_prefix) || strlen($key_suffix);
        $enable_val = strlen($val_prefix) || strlen($val_suffix);

        $result = [];
        foreach ($array as $key => $val) {
            if ($enable_key) {
                $key = $key_prefix . $key . $key_suffix;
            }
            if ($enable_val) {
                $val = $val_prefix . $val . $val_suffix;
            }
            $result[$key] = $val;
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\array_strpad") && !defined("ryunosuke\\dbml\\array_strpad")) {
    define("ryunosuke\\dbml\\array_strpad", "ryunosuke\\dbml\\array_strpad");
}

if (!isset($excluded_functions["array_get"]) && (!function_exists("ryunosuke\\dbml\\array_get") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_get"))->isInternal()))) {
    /**
     * デフォルト値付きの配列値取得
     *
     * 存在しない場合は $default を返す。
     *
     * $key に配列を与えるとそれらの値の配列を返す（lookup 的な動作）。
     * その場合、$default が活きるのは「全て無かった場合」となる。
     *
     * さらに $key が配列の場合に限り、 $default を省略すると空配列として動作する。
     *
     * 同様に、$key にクロージャを与えると、その返り値が true 相当のものを返す。
     * その際、 $default が配列なら一致するものを配列で返し、配列でないなら単値で返す。
     *
     * Example:
     * ```php
     * // 単純取得
     * that(array_get(['a', 'b', 'c'], 1))->isSame('b');
     * // 単純デフォルト
     * that(array_get(['a', 'b', 'c'], 9, 999))->isSame(999);
     * // 配列取得
     * that(array_get(['a', 'b', 'c'], [0, 2]))->isSame([0 => 'a', 2 => 'c']);
     * // 配列部分取得
     * that(array_get(['a', 'b', 'c'], [0, 9]))->isSame([0 => 'a']);
     * // 配列デフォルト（null ではなく [] を返す）
     * that(array_get(['a', 'b', 'c'], [9]))->isSame([]);
     * // クロージャ指定＆単値（コールバックが true を返す最初の要素）
     * that(array_get(['a', 'b', 'c'], function($v){return in_array($v, ['b', 'c']);}))->isSame('b');
     * // クロージャ指定＆配列（コールバックが true を返すもの）
     * that(array_get(['a', 'b', 'c'], function($v){return in_array($v, ['b', 'c']);}, []))->isSame([1 => 'b', 2 => 'c']);
     * ```
     *
     * @param array $array 配列
     * @param string|int|array|\Closure $key 取得したいキー。配列を与えると全て返す。クロージャの場合は true 相当を返す
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 指定したキーの値
     */
    function array_get($array, $key, $default = null)
    {
        if (is_array($key)) {
            $result = [];
            foreach ($key as $k) {
                // 深遠な事情で少しでも高速化したかったので isset || array_keys_exist にしてある
                if (isset($array[$k]) || array_keys_exist($k, $array)) {
                    $result[$k] = $array[$k];
                }
            }
            if (!$result) {
                // 明示的に与えられていないなら [] を使用する
                if (func_num_args() === 2) {
                    $default = [];
                }
                return $default;
            }
            return $result;
        }

        if ($key instanceof \Closure) {
            $result = [];
            $n = 0;
            foreach ($array as $k => $v) {
                if ($key($v, $k, $n++)) {
                    if (func_num_args() === 2) {
                        return $v;
                    }
                    $result[$k] = $v;
                }
            }
            if (!$result) {
                return $default;
            }
            return $result;
        }

        if (array_keys_exist($key, $array)) {
            return $array[$key];
        }
        return $default;
    }
}
if (function_exists("ryunosuke\\dbml\\array_get") && !defined("ryunosuke\\dbml\\array_get")) {
    define("ryunosuke\\dbml\\array_get", "ryunosuke\\dbml\\array_get");
}

if (!isset($excluded_functions["array_set"]) && (!function_exists("ryunosuke\\dbml\\array_set") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_set"))->isInternal()))) {
    /**
     * キー指定の配列値設定
     *
     * 第3引数を省略すると（null を与えると）言語機構を使用して配列の最後に設定する（$array[] = $value）。
     * 第3引数に配列を指定すると潜って設定する。
     *
     * Example:
     * ```php
     * $array = ['a' => 'A', 'B'];
     * // 第3引数省略（最後に連番キーで設定）
     * that(array_set($array, 'Z'))->isSame(1);
     * that($array)->isSame(['a' => 'A', 'B', 'Z']);
     * // 第3引数でキーを指定
     * that(array_set($array, 'Z', 'z'))->isSame('z');
     * that($array)->isSame(['a' => 'A', 'B', 'Z', 'z' => 'Z']);
     * that(array_set($array, 'Z', 'z'))->isSame('z');
     * // 第3引数で配列を指定
     * that(array_set($array, 'Z', ['x', 'y', 'z']))->isSame('z');
     * that($array)->isSame(['a' => 'A', 'B', 'Z', 'z' => 'Z', 'x' => ['y' => ['z' => 'Z']]]);
     * ```
     *
     * @param array $array 配列
     * @param mixed $value 設定する値
     * @param array|string|int|null $key 設定するキー
     * @param bool $require_return 返り値が不要なら false を渡す
     * @return string|int 設定したキー
     */
    function array_set(&$array, $value, $key = null, $require_return = true)
    {
        if (is_array($key)) {
            $k = array_shift($key);
            if ($key) {
                if (is_array($array) && array_key_exists($k, $array) && !is_array($array[$k])) {
                    throw new \InvalidArgumentException('$array[$k] is not array.');
                }
                return array_set(...[&$array[$k], $value, $key, $require_return]);
            }
            else {
                return array_set(...[&$array, $value, $k, $require_return]);
            }
        }

        if ($key === null) {
            $array[] = $value;
            if ($require_return === true) {
                $key = last_key($array);
            }
        }
        else {
            $array[$key] = $value;
        }
        return $key;
    }
}
if (function_exists("ryunosuke\\dbml\\array_set") && !defined("ryunosuke\\dbml\\array_set")) {
    define("ryunosuke\\dbml\\array_set", "ryunosuke\\dbml\\array_set");
}

if (!isset($excluded_functions["array_put"]) && (!function_exists("ryunosuke\\dbml\\array_put") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_put"))->isInternal()))) {
    /**
     * キー指定の配列値設定
     *
     * array_set とほとんど同じ。
     * 第3引数を省略すると（null を与えると）言語機構を使用して配列の最後に設定する（$array[] = $value）。
     * また、**int を与えても同様の動作**となる。
     * 第3引数に配列を指定すると潜って設定する。
     *
     * 第4引数で追加する条件クロージャを指定できる。
     * クロージャには `(追加する要素, 追加するキー, 追加される元配列)` が渡ってくる。
     * このクロージャが false 相当を返した時は追加されないようになる。
     *
     * array_set における $require_return は廃止している。
     * これはもともと end や last_key が遅かったのでオプショナルにしていたが、もう改善しているし、7.3 から array_key_last があるので、呼び元で適宜使えば良い。
     *
     * Example:
     * ```php
     * $array = ['a' => 'A', 'B'];
     * // 第3引数 int
     * that(array_put($array, 'Z', 999))->isSame(1);
     * that($array)->isSame(['a' => 'A', 'B', 'Z']);
     * // 第3引数省略（最後に連番キーで設定）
     * that(array_put($array, 'Z'))->isSame(2);
     * that($array)->isSame(['a' => 'A', 'B', 'Z', 'Z']);
     * // 第3引数でキーを指定
     * that(array_put($array, 'Z', 'z'))->isSame('z');
     * that($array)->isSame(['a' => 'A', 'B', 'Z', 'Z', 'z' => 'Z']);
     * that(array_put($array, 'Z', 'z'))->isSame('z');
     * // 第3引数で配列を指定
     * that(array_put($array, 'Z', ['x', 'y', 'z']))->isSame('z');
     * that($array)->isSame(['a' => 'A', 'B', 'Z', 'Z', 'z' => 'Z', 'x' => ['y' => ['z' => 'Z']]]);
     * // 第4引数で条件を指定（キーが存在するなら追加しない）
     * that(array_put($array, 'Z', 'z', function ($v, $k, $array){return !isset($array[$k]);}))->isSame(false);
     * // 第4引数で条件を指定（値が存在するなら追加しない）
     * that(array_put($array, 'Z', null, function ($v, $k, $array){return !in_array($v, $array);}))->isSame(false);
     * ```
     *
     * @param array $array 配列
     * @param mixed $value 設定する値
     * @param array|string|int|null $key 設定するキー
     * @param callable|null $condition 追加する条件
     * @return string|int|false 設定したキー
     */
    function array_put(&$array, $value, $key = null, $condition = null)
    {
        if (is_array($key)) {
            $k = array_shift($key);
            if ($key) {
                if (is_array($array) && array_key_exists($k, $array) && !is_array($array[$k])) {
                    throw new \InvalidArgumentException('$array[$k] is not array.');
                }
                return array_put(...[&$array[$k], $value, $key, $condition]);
            }
            else {
                return array_put(...[&$array, $value, $k, $condition]);
            }
        }

        if ($condition !== null) {
            if (!$condition($value, $key, $array)) {
                return false;
            }
        }

        if ($key === null || is_int($key)) {
            $array[] = $value;
            // compatible array_key_last under 7.3
            end($array);
            $key = key($array);
        }
        else {
            $array[$key] = $value;
        }
        return $key;
    }
}
if (function_exists("ryunosuke\\dbml\\array_put") && !defined("ryunosuke\\dbml\\array_put")) {
    define("ryunosuke\\dbml\\array_put", "ryunosuke\\dbml\\array_put");
}

if (!isset($excluded_functions["array_unset"]) && (!function_exists("ryunosuke\\dbml\\array_unset") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_unset"))->isInternal()))) {
    /**
     * 伏せると同時にその値を返す
     *
     * $key に配列を与えると全て伏せて配列で返す。
     * その場合、$default が活きるのは「全て無かった場合」となる。
     *
     * さらに $key が配列の場合に限り、 $default を省略すると空配列として動作する。
     *
     * 配列を与えた場合の返り値は与えた配列の順番・キーが活きる。
     * これを利用すると list の展開の利便性が上がったり、連想配列で返すことができる。
     *
     * 同様に、$key にクロージャを与えると、その返り値が true 相当のものを伏せて配列で返す。
     * callable ではなくクロージャのみ対応する。
     *
     * Example:
     * ```php
     * $array = ['a' => 'A', 'b' => 'B'];
     * // ない場合は $default を返す
     * that(array_unset($array, 'x', 'X'))->isSame('X');
     * // 指定したキーを返す。そのキーは伏せられている
     * that(array_unset($array, 'a'))->isSame('A');
     * that($array)->isSame(['b' => 'B']);
     *
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // 配列を与えるとそれらを返す。そのキーは全て伏せられている
     * that(array_unset($array, ['a', 'b', 'x']))->isSame(['A', 'B']);
     * that($array)->isSame(['c' => 'C']);
     *
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // 配列のキーは返されるキーを表す。順番も維持される
     * that(array_unset($array, ['x2' => 'b', 'x1' => 'a']))->isSame(['x2' => 'B', 'x1' => 'A']);
     *
     * $array = ['hoge' => 'HOGE', 'fuga' => 'FUGA', 'piyo' => 'PIYO'];
     * // 値に "G" を含むものを返す。その要素は伏せられている
     * that(array_unset($array, function($v){return strpos($v, 'G') !== false;}))->isSame(['hoge' => 'HOGE', 'fuga' => 'FUGA']);
     * that($array)->isSame(['piyo' => 'PIYO']);
     * ```
     *
     * @param array $array 配列
     * @param string|int|array|callable $key 伏せたいキー。配列を与えると全て伏せる。クロージャの場合は true 相当を伏せる
     * @param mixed $default 無かった場合のデフォルト値
     * @return mixed 指定したキーの値
     */
    function array_unset(&$array, $key, $default = null)
    {
        if (is_array($key)) {
            $result = [];
            foreach ($key as $rk => $ak) {
                if (array_keys_exist($ak, $array)) {
                    $result[$rk] = $array[$ak];
                    unset($array[$ak]);
                }
            }
            if (!$result) {
                // 明示的に与えられていないなら [] を使用する
                if (func_num_args() === 2) {
                    $default = [];
                }
                return $default;
            }
            return $result;
        }

        if ($key instanceof \Closure) {
            $result = [];
            $n = 0;
            foreach ($array as $k => $v) {
                if ($key($v, $k, $n++)) {
                    $result[$k] = $v;
                    unset($array[$k]);
                }
            }
            if (!$result) {
                return $default;
            }
            return $result;
        }

        if (array_keys_exist($key, $array)) {
            $result = $array[$key];
            unset($array[$key]);
            return $result;
        }
        return $default;
    }
}
if (function_exists("ryunosuke\\dbml\\array_unset") && !defined("ryunosuke\\dbml\\array_unset")) {
    define("ryunosuke\\dbml\\array_unset", "ryunosuke\\dbml\\array_unset");
}

if (!isset($excluded_functions["array_keys_exist"]) && (!function_exists("ryunosuke\\dbml\\array_keys_exist") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_keys_exist"))->isInternal()))) {
    /**
     * array_key_exists の複数版
     *
     * 指定キーが全て存在するなら true を返す。
     * 配列ではなく単一文字列を与えても動作する（array_key_exists と全く同じ動作になる）。
     *
     * $keys に空を与えると例外を投げる。
     * $keys に配列を与えるとキーで潜ってチェックする（Example 参照）。
     *
     * Example:
     * ```php
     * // すべて含むので true
     * that(array_keys_exist(['a', 'b', 'c'], ['a' => 'A', 'b' => 'B', 'c' => 'C']))->isTrue();
     * // N は含まないので false
     * that(array_keys_exist(['a', 'b', 'N'], ['a' => 'A', 'b' => 'B', 'c' => 'C']))->isFalse();
     * // 配列を与えると潜る（日本語で言えば「a というキーと、x というキーとその中に x1, x2 というキーがあるか？」）
     * that(array_keys_exist(['a', 'x' => ['x1', 'x2']], ['a' => 'A', 'x' => ['x1' => 'X1', 'x2' => 'X2']]))->isTrue();
     * ```
     *
     * @param array|string $keys 調べるキー
     * @param array|\ArrayAccess $array 調べる配列
     * @return bool 指定キーが全て存在するなら true
     */
    function array_keys_exist($keys, $array)
    {
        $keys = is_iterable($keys) ? $keys : [$keys];
        if (is_empty($keys)) {
            throw new \InvalidArgumentException('$keys is empty.');
        }

        $is_arrayaccess = $array instanceof \ArrayAccess;

        foreach ($keys as $k => $key) {
            if (is_array($key)) {
                // まずそのキーをチェックして
                if (!array_keys_exist($k, $array)) {
                    return false;
                }
                // あるなら再帰する
                if (!array_keys_exist($key, $array[$k])) {
                    return false;
                }
            }
            elseif ($is_arrayaccess) {
                if (!$array->offsetExists($key)) {
                    return false;
                }
            }
            elseif (!array_key_exists($key, $array)) {
                return false;
            }
        }
        return true;
    }
}
if (function_exists("ryunosuke\\dbml\\array_keys_exist") && !defined("ryunosuke\\dbml\\array_keys_exist")) {
    define("ryunosuke\\dbml\\array_keys_exist", "ryunosuke\\dbml\\array_keys_exist");
}

if (!isset($excluded_functions["array_find"]) && (!function_exists("ryunosuke\\dbml\\array_find") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_find"))->isInternal()))) {
    /**
     * array_search のクロージャ版のようなもの
     *
     * コールバックの返り値が true 相当のものを返す。
     * $is_key に true を与えるとそのキーを返す（デフォルトの動作）。
     * $is_key に false を与えるとコールバックの結果を返す。
     *
     * この関数は論理値 FALSE を返す可能性がありますが、FALSE として評価される値を返す可能性もあります。
     *
     * Example:
     * ```php
     * // 最初に見つかったキーを返す
     * that(array_find(['a', 'b', '9'], 'ctype_digit'))->isSame(2);
     * that(array_find(['a', 'b', '9'], function($v){return $v === 'b';}))->isSame(1);
     * // 最初に見つかったコールバック結果を返す（最初の数字の2乗を返す）
     * $ifnumeric2power = function($v){return ctype_digit($v) ? $v * $v : false;};
     * that(array_find(['a', 'b', '9'], $ifnumeric2power, false))->isSame(81);
     * ```
     *
     * @param iterable $array 調べる配列
     * @param callable $callback 評価コールバック
     * @param bool $is_key キーを返すか否か
     * @return mixed コールバックが true を返した最初のキー。存在しなかったら false
     */
    function array_find($array, $callback, $is_key = true)
    {
        $callback = func_user_func_array($callback);

        $n = 0;
        foreach ($array as $k => $v) {
            $result = $callback($v, $k, $n++);
            if ($result) {
                if ($is_key) {
                    return $k;
                }
                return $result;
            }
        }
        return false;
    }
}
if (function_exists("ryunosuke\\dbml\\array_find") && !defined("ryunosuke\\dbml\\array_find")) {
    define("ryunosuke\\dbml\\array_find", "ryunosuke\\dbml\\array_find");
}

if (!isset($excluded_functions["array_rekey"]) && (!function_exists("ryunosuke\\dbml\\array_rekey") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_rekey"))->isInternal()))) {
    /**
     * キーをマップ配列・callable で置換する
     *
     * 変換先・返り値が null だとその要素は取り除かれる。
     * callable 指定時の引数は `(キー, 値, 連番インデックス, 対象配列そのもの)` が渡ってくる。
     *
     * Example:
     * ```php
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // a は x に c は z に置換される
     * that(array_rekey($array, ['a' => 'x', 'c' => 'z']))->isSame(['x' => 'A', 'b' => 'B', 'z' => 'C']);
     * // b は削除され c は z に置換される
     * that(array_rekey($array, ['b' => null, 'c' => 'z']))->isSame(['a' => 'A', 'z' => 'C']);
     * // キーの交換にも使える（a ⇔ c）
     * that(array_rekey($array, ['a' => 'c', 'c' => 'a']))->isSame(['c' => 'A', 'b' => 'B', 'a' => 'C']);
     * // callable
     * that(array_rekey($array, 'strtoupper'))->isSame(['A' => 'A', 'B' => 'B', 'C' => 'C']);
     * ```
     *
     * @param iterable $array 対象配列
     * @param array|callable $keymap マップ配列かキーを返すクロージャ
     * @return array キーが置換された配列
     */
    function array_rekey($array, $keymap)
    {
        // 互換性のため callable は配列以外に限定する
        $callable = ($keymap instanceof \Closure) || (!is_array($keymap) && is_callable($keymap));
        if ($callable) {
            $keymap = func_user_func_array($keymap);
        }

        $result = [];
        $n = 0;
        foreach ($array as $k => $v) {
            if ($callable) {
                $k = $keymap($k, $v, $n, $array);
                // null は突っ込まない（除去）
                if ($k !== null) {
                    $result[$k] = $v;
                }
            }
            elseif (array_key_exists($k, $keymap)) {
                // null は突っ込まない（除去）
                if ($keymap[$k] !== null) {
                    $result[$keymap[$k]] = $v;
                }
            }
            else {
                $result[$k] = $v;
            }
            $n++;
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\array_rekey") && !defined("ryunosuke\\dbml\\array_rekey")) {
    define("ryunosuke\\dbml\\array_rekey", "ryunosuke\\dbml\\array_rekey");
}

if (!isset($excluded_functions["array_map_recursive"]) && (!function_exists("ryunosuke\\dbml\\array_map_recursive") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_map_recursive"))->isInternal()))) {
    /**
     * array_map の再帰版
     *
     * 下記の点で少し array_map とは挙動が異なる。
     *
     * - 配列だけでなく iterable も対象になる（引数で指定可能。デフォルト true）
     *     - つまりオブジェクト構造は維持されず、結果はすべて配列になる
     * - 値だけでなくキーも渡ってくる
     *
     * Example:
     * ```php
     * // デフォルトでは array_walk 等と同様に葉のみが渡ってくる（iterable も対象になる）
     * that(array_map_recursive([
     *     'k' => 'v',
     *     'c' => new \ArrayObject([
     *         'k1' => 'v1',
     *         'k2' => 'v2',
     *     ]),
     * ], 'strtoupper'))->isSame([
     *     'k' => 'V',
     *     'c' => [
     *         'k1' => 'V1',
     *         'k2' => 'V2',
     *     ],
     * ]);
     *
     * // ただし、その挙動は引数で変更可能
     * that(array_map_recursive([
     *     'k' => 'v',
     *     'c' => new \ArrayObject([
     *         'k1' => 'v1',
     *         'k2' => 'v2',
     *     ]),
     * ], 'gettype', false))->isSame([
     *     'k' => 'string',
     *     'c' => 'object',
     * ]);
     *
     * // さらに、自身にも適用できる（呼び出しは子が先で、本当の意味で「すべての要素」で呼び出される）
     * that((array_map_recursive)([
     *     'k' => 'v',
     *     'c' => [
     *         'k1' => 'v1',
     *         'k2' => 'v2',
     *     ],
     * ], function ($v) {
     *     // 配列は stdclass 化、それ以外は大文字化
     *     return is_array($v) ? (object) $v : strtoupper($v);
     * }, true, true))->is((object) [
     *     'k' => 'V',
     *     'c' => (object) [
     *         'k1' => 'V1',
     *         'k2' => 'V2',
     *     ],
     * ]);
     * ```
     *
     * @param iterable $array 対象配列
     * @param callable $callback 評価クロージャ
     * @param bool $iterable is_iterable で判定するか
     * @param bool $apply_array 配列要素にもコールバックを適用するか
     * @return array map された新しい配列
     */
    function array_map_recursive($array, $callback, $iterable = true, $apply_array = false)
    {
        $callback = func_user_func_array($callback);

        // ↑の変換を再帰ごとにやるのは現実的ではないのでクロージャに閉じ込めて再帰する
        $main = static function ($array, $parent) use (&$main, $callback, $iterable, $apply_array) {
            $result = [];
            $n = 0;
            foreach ($array as $k => $v) {
                if (($iterable && is_iterable($v)) || (!$iterable && is_array($v))) {
                    $result[$k] = $main($v, $k);
                }
                else {
                    $result[$k] = $callback($v, $k, $n++);
                }
            }
            if ($apply_array) {
                return $callback($result, $parent, null);
            }
            return $result;
        };

        return $main($array, null);
    }
}
if (function_exists("ryunosuke\\dbml\\array_map_recursive") && !defined("ryunosuke\\dbml\\array_map_recursive")) {
    define("ryunosuke\\dbml\\array_map_recursive", "ryunosuke\\dbml\\array_map_recursive");
}

if (!isset($excluded_functions["array_map_key"]) && (!function_exists("ryunosuke\\dbml\\array_map_key") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_map_key"))->isInternal()))) {
    /**
     * キーをマップして変換する
     *
     * $callback が null を返すとその要素は取り除かれる。
     *
     * Example:
     * ```php
     * that(array_map_key(['a' => 'A', 'b' => 'B'], 'strtoupper'))->isSame(['A' => 'A', 'B' => 'B']);
     * that(array_map_key(['a' => 'A', 'b' => 'B'], function(){}))->isSame([]);
     * ```
     *
     * @param iterable $array 対象配列
     * @param callable $callback 評価クロージャ
     * @return array キーが変換された新しい配列
     */
    function array_map_key($array, $callback)
    {
        $callback = func_user_func_array($callback);
        $result = [];
        $n = 0;
        foreach ($array as $k => $v) {
            $k2 = $callback($k, $v, $n++);
            if ($k2 !== null) {
                $result[$k2] = $v;
            }
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\array_map_key") && !defined("ryunosuke\\dbml\\array_map_key")) {
    define("ryunosuke\\dbml\\array_map_key", "ryunosuke\\dbml\\array_map_key");
}

if (!isset($excluded_functions["array_maps"]) && (!function_exists("ryunosuke\\dbml\\array_maps") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_maps"))->isInternal()))) {
    /**
     * 複数コールバックを指定できる array_map
     *
     * 指定したコールバックで複数回回してマップする。
     * `array_maps($array, $f, $g)` は `array_map($g, array_map($f, $array))` とほぼ等しい。
     * ただし、引数は順番が違う（可変引数のため）し、コールバックが要求するならキーも渡ってくる。
     * さらに文字列関数で "..." から始まっているなら可変引数としてコールする。
     *
     * 少し変わった仕様として、コールバックに [$method => $args] を付けるとそれはメソッド呼び出しになる。
     * つまり各要素 $v に対して `$v->$method(...$args)` がマップ結果になる。
     * さらに引数が不要なら `@method` とするだけで良い。
     *
     * Example:
     * ```php
     * // 値を3乗したあと16進表記にして大文字化する
     * that(array_maps([1, 2, 3, 4, 5], rbind('pow', 3), 'dechex', 'strtoupper'))->isSame(['1', '8', '1B', '40', '7D']);
     * // キーも渡ってくる
     * that(array_maps(['a' => 'A', 'b' => 'B'], function($v, $k){return "$k:$v";}))->isSame(['a' => 'a:A', 'b' => 'b:B']);
     * // ... で可変引数コール
     * that(array_maps([[1, 3], [1, 5, 2]], '...range'))->isSame([[1, 2, 3], [1, 3, 5]]);
     * // メソッドコールもできる（引数不要なら `@method` でも同じ）
     * that(array_maps([new \Exception('a'), new \Exception('b')], ['getMessage' => []]))->isSame(['a', 'b']);
     * that(array_maps([new \Exception('a'), new \Exception('b')], '@getMessage'))->isSame(['a', 'b']);
     * ```
     *
     * @param iterable $array 対象配列
     * @param callable ...$callbacks 評価クロージャ配列
     * @return array 評価クロージャを通した新しい配列
     */
    function array_maps($array, ...$callbacks)
    {
        $result = arrayval($array, false);
        foreach ($callbacks as $callback) {
            if (is_string($callback) && $callback[0] === '@') {
                $margs = [];
                $vargs = false;
                $callback = substr($callback, 1);
            }
            elseif (is_array($callback) && count($callback) === 1) {
                $margs = reset($callback);
                $vargs = false;
                $callback = key($callback);
            }
            elseif (is_string($callback) && substr($callback, 0, 3) === '...') {
                $margs = null;
                $vargs = true;
                $callback = substr($callback, 3);
            }
            else {
                $margs = null;
                $vargs = false;
                $callback = func_user_func_array($callback);
            }
            $n = 0;
            foreach ($result as $k => $v) {
                if (isset($margs)) {
                    $result[$k] = ([$v, $callback])(...$margs);
                }
                elseif ($vargs) {
                    $result[$k] = $callback(...$v);
                }
                else {
                    $result[$k] = $callback($v, $k, $n++);
                }
            }
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\array_maps") && !defined("ryunosuke\\dbml\\array_maps")) {
    define("ryunosuke\\dbml\\array_maps", "ryunosuke\\dbml\\array_maps");
}

if (!isset($excluded_functions["array_kvmap"]) && (!function_exists("ryunosuke\\dbml\\array_kvmap") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_kvmap"))->isInternal()))) {
    /**
     * 配列の各キー・値にコールバックを適用する
     *
     * $callback は (キー, 値, $callback) が渡ってくるので 「その位置に配置したい配列」を返せばそこに置換される。
     * つまり、空配列を返せばそのキー・値は消えることになるし、複数の配列を返せば要素が増えることになる。
     * ただし、数値キーは新しく採番される。
     * null を返すと特別扱いで、そのキー・値をそのまま維持する。
     * iterable を返す必要があるが、もし iterable でない場合は配列キャストされる。
     *
     * 「map も filter も可能でキー変更可能」というとてもマッチョな関数。
     * 実質的には「数値キーが再採番される再帰的でない array_convert」のように振る舞う。
     * ただし、再帰処理はないので自前で管理する必要がある。
     *
     * Example:
     * ```php
     * $array = [
     *    'a' => 'A',
     *    'b' => 'B',
     *    'c' => 'C',
     *    'd' => 'D',
     * ];
     * // キーに '_' 、値に 'prefix-' を付与。'b' は一切何もしない。'c' は値のみ。'd' はそれ自体伏せる
     * that(array_kvmap($array, function($k, $v){
     *     if ($k === 'b') return null;
     *     if ($k === 'd') return [];
     *     if ($k !== 'c') $k = "_$k";
     *     return [$k => "prefix-$v"];
     * }))->isSame([
     *     '_a' => 'prefix-A',
     *     'b'  => 'B',
     *     'c'  => 'prefix-C',
     * ]);
     *
     * // 複数返せばその分増える（要素の水増し）
     * that(array_kvmap($array, function($k, $v){
     *     return [
     *         "{$k}1" => "{$v}1",
     *         "{$k}2" => "{$v}2",
     *     ];
     * }))->isSame([
     *    'a1' => 'A1',
     *    'a2' => 'A2',
     *    'b1' => 'B1',
     *    'b2' => 'B2',
     *    'c1' => 'C1',
     *    'c2' => 'C2',
     *    'd1' => 'D1',
     *    'd2' => 'D2',
     * ]);
     *
     * // $callback には $callback 自体も渡ってくるので再帰も比較的楽に書ける
     * that(array_kvmap([
     *     'x' => [
     *         'X',
     *         'y' => [
     *             'Y',
     *             'z' => ['Z'],
     *         ],
     *     ],
     * ], function($k, $v, $callback){
     *     // 配列だったら再帰する
     *     return ["_$k" => is_array($v) ? array_kvmap($v, $callback) : "prefix-$v"];
     * }))->isSame([
     *     "_x" => [
     *         "_0" => "prefix-X",
     *         "_y" => [
     *             "_0" => "prefix-Y",
     *             "_z" => [
     *                 "_0" => "prefix-Z",
     *             ],
     *         ],
     *     ],
     * ]);
     * ```
     *
     * @param iterable $array 対象配列
     * @param callable $callback 適用するコールバック
     * @return array 変換された配列
     */
    function array_kvmap($array, $callback)
    {
        $result = [];
        foreach ($array as $k => $v) {
            $kv = $callback($k, $v, $callback) ?? [$k => $v];
            if (!is_iterable($kv)) {
                $kv = [$kv];
            }
            // $result = array_merge($result, $kv); // 遅すぎる
            foreach ($kv as $k2 => $v2) {
                if (is_int($k2)) {
                    $result[] = $v2;
                }
                else {
                    $result[$k2] = $v2;
                }
            }
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\array_kvmap") && !defined("ryunosuke\\dbml\\array_kvmap")) {
    define("ryunosuke\\dbml\\array_kvmap", "ryunosuke\\dbml\\array_kvmap");
}

if (!isset($excluded_functions["array_kmap"]) && (!function_exists("ryunosuke\\dbml\\array_kmap") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_kmap"))->isInternal()))) {
    /**
     * キーも渡ってくる array_map
     *
     * `array_map($callback, $array, array_keys($array))` とほとんど変わりはない。
     * 違いは下記。
     *
     * - 引数の順番が異なる（$array が先）
     * - キーが死なない（array_map は複数配列を与えるとキーが死ぬ）
     * - 配列だけでなく Traversable も受け入れる
     * - callback の第3引数に 0 からの連番が渡ってくる
     *
     * Example:
     * ```php
     * // キー・値をくっつけるシンプルな例
     * that(array_kmap([
     *     'k1' => 'v1',
     *     'k2' => 'v2',
     *     'k3' => 'v3',
     * ], function($v, $k){return "$k:$v";}))->isSame([
     *     'k1' => 'k1:v1',
     *     'k2' => 'k2:v2',
     *     'k3' => 'k3:v3',
     * ]);
     * ```
     *
     * @param iterable $array 対象配列
     * @param callable $callback 評価クロージャ
     * @return array $callback を通した新しい配列
     */
    function array_kmap($array, $callback)
    {
        $callback = func_user_func_array($callback);

        $n = 0;
        $result = [];
        foreach ($array as $k => $v) {
            $result[$k] = $callback($v, $k, $n++);
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\array_kmap") && !defined("ryunosuke\\dbml\\array_kmap")) {
    define("ryunosuke\\dbml\\array_kmap", "ryunosuke\\dbml\\array_kmap");
}

if (!isset($excluded_functions["array_nmap"]) && (!function_exists("ryunosuke\\dbml\\array_nmap") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_nmap"))->isInternal()))) {
    /**
     * 要素値を $callback の n 番目(0ベース)に適用して array_map する
     *
     * 引数 $n に配列を与えると [キー番目 => 値番目] とみなしてキー・値も渡される（Example 参照）。
     * その際、「挿入後の番目」ではなく、単純に「元の引数の番目」であることに留意。キー・値が同じ位置を指定している場合はキーが先にくる。
     *
     * Example:
     * ```php
     * // 1番目に値を渡して map
     * $sprintf = function(){return vsprintf('%s%s%s', func_get_args());};
     * that(array_nmap(['a', 'b'], $sprintf, 1, 'prefix-', '-suffix'))->isSame(['prefix-a-suffix', 'prefix-b-suffix']);
     * // 1番目にキー、2番目に値を渡して map
     * $sprintf = function(){return vsprintf('%s %s %s %s %s', func_get_args());};
     * that(array_nmap(['k' => 'v'], $sprintf, [1 => 2], 'a', 'b', 'c'))->isSame(['k' => 'a k b v c']);
     * ```
     *
     * @param iterable $array 対象配列
     * @param callable $callback 評価クロージャ
     * @param int|array $n 要素値を入れる引数番目。配列を渡すとキー・値の両方を指定でき、両方が渡ってくる
     * @param mixed ...$variadic $callback に渡され、改変される引数（可変引数）
     * @return array 評価クロージャを通した新しい配列
     */
    function array_nmap($array, $callback, $n, ...$variadic)
    {
        /** @var $kn */
        /** @var $vn */

        $is_array = is_array($n);
        $args = $variadic;

        // 配列が来たら [キー番目 => 値番目] とみなす
        if ($is_array) {
            if (empty($n)) {
                throw new \InvalidArgumentException('array $n is empty.');
            }
            [$kn, $vn] = first_keyvalue($n);

            // array_insert は負数も受け入れられるが、それを考慮しだすともう収拾がつかない
            if ($kn < 0 || $vn < 0) {
                throw new \InvalidArgumentException('$kn, $vn must be positive.');
            }

            // どちらが大きいかで順番がズレるので分岐しなければならない
            if ($kn <= $vn) {
                $args = array_insert($args, null, $kn);
                $args = array_insert($args, null, ++$vn);// ↑で挿入してるので+1
            }
            else {
                $args = array_insert($args, null, $vn);
                $args = array_insert($args, null, ++$kn);// ↑で挿入してるので+1
            }
        }
        else {
            $args = array_insert($args, null, $n);
        }

        $result = [];
        foreach ($array as $k => $v) {
            // キー値モードなら両方埋める
            if ($is_array) {
                $args[$kn] = $k;
                $args[$vn] = $v;
            }
            // 値のみなら値だけ
            else {
                $args[$n] = $v;
            }
            $result[$k] = $callback(...$args);
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\array_nmap") && !defined("ryunosuke\\dbml\\array_nmap")) {
    define("ryunosuke\\dbml\\array_nmap", "ryunosuke\\dbml\\array_nmap");
}

if (!isset($excluded_functions["array_rmap"]) && (!function_exists("ryunosuke\\dbml\\array_rmap") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_rmap"))->isInternal()))) {
    /**
     * 要素値を $callback の最右に適用して array_map する
     *
     * Example:
     * ```php
     * $sprintf = function(){return vsprintf('%s%s', func_get_args());};
     * that(array_rmap(['a', 'b'], $sprintf, 'prefix-'))->isSame(['prefix-a', 'prefix-b']);
     * ```
     *
     * @param iterable $array 対象配列
     * @param callable $callback 評価クロージャ
     * @param mixed ...$variadic $callback に渡され、改変される引数（可変引数）
     * @return array 評価クロージャを通した新しい配列
     */
    function array_rmap($array, $callback, ...$variadic)
    {
        return array_nmap(...array_insert(func_get_args(), func_num_args() - 2, 2));
    }
}
if (function_exists("ryunosuke\\dbml\\array_rmap") && !defined("ryunosuke\\dbml\\array_rmap")) {
    define("ryunosuke\\dbml\\array_rmap", "ryunosuke\\dbml\\array_rmap");
}

if (!isset($excluded_functions["array_each"]) && (!function_exists("ryunosuke\\dbml\\array_each") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_each"))->isInternal()))) {
    /**
     * array_reduce の参照版（のようなもの）
     *
     * 配列をループで回し、その途中経過、値、キー、連番をコールバック引数で渡して最終的な結果を返り値として返す。
     * array_reduce と少し似てるが、下記の点が異なる。
     *
     * - いわゆる $carry は返り値で表すのではなく、参照引数で表す
     * - 値だけでなくキー、連番も渡ってくる
     * - 巨大配列の場合でも速度劣化が少ない（array_reduce に巨大配列を渡すと実用にならないレベルで遅くなる）
     *
     * $callback の引数は `($value, $key, $n)` （$n はキーとは関係がない 0 ～ 要素数-1 の通し連番）。
     *
     * 返り値ではなく参照引数なので return する必要はない（ワンライナーが書きやすくなる）。
     * 返り値が空くのでループ制御に用いる。
     * 今のところ $callback が false を返すとそこで break するのみ。
     *
     * 第3引数を省略した場合、**クロージャの第1引数のデフォルト値が使われる**。
     * これは特筆すべき動作で、不格好な第3引数を完全に省略することができる（サンプルコードを参照）。
     * ただし「php の文法違反（今のところエラーにはならないし、全てにデフォルト値をつければ一応回避可能）」「リフレクションを使う（ほんの少し遅くなる）」などの弊害が有るので推奨はしない。
     * （ただ、「意図していることをコードで表す」といった観点ではこの記法の方が正しいとも思う）。
     *
     * Example:
     * ```php
     * // 全要素を文字列的に足し合わせる
     * that(array_each([1, 2, 3, 4, 5], function(&$carry, $v){$carry .= $v;}, ''))->isSame('12345');
     * // 値をキーにして要素を2乗値にする
     * that(array_each([1, 2, 3, 4, 5], function(&$carry, $v){$carry[$v] = $v * $v;}, []))->isSame([
     *     1 => 1,
     *     2 => 4,
     *     3 => 9,
     *     4 => 16,
     *     5 => 25,
     * ]);
     * // 上記と同じ。ただし、3 で break する
     * that(array_each([1, 2, 3, 4, 5], function(&$carry, $v, $k){
     *     if ($k === 3) return false;
     *     $carry[$v] = $v * $v;
     * }, []))->isSame([
     *     1 => 1,
     *     2 => 4,
     *     3 => 9,
     * ]);
     *
     * // 下記は完全に同じ（第3引数の代わりにデフォルト引数を使っている）
     * that(array_each([1, 2, 3], function(&$carry = [], $v = null) {
     *         $carry[$v] = $v * $v;
     *     }))->isSame(array_each([1, 2, 3], function(&$carry, $v) {
     *         $carry[$v] = $v * $v;
     *     }, [])
     *     // 個人的に↑のようなぶら下がり引数があまり好きではない（クロージャを最後の引数にしたい）
     * );
     * ```
     *
     * @param iterable $array 対象配列
     * @param callable $callback 評価クロージャ。(&$carry, $key, $value) を受ける
     * @param mixed $default ループの最初や空の場合に適用される値
     * @return mixed each した結果
     */
    function array_each($array, $callback, $default = null)
    {
        if (func_num_args() === 2) {
            /** @var \ReflectionFunction $ref */
            $ref = reflect_callable($callback);
            $params = $ref->getParameters();
            if ($params[0]->isDefaultValueAvailable()) {
                $default = $params[0]->getDefaultValue();
            }
        }

        $n = 0;
        foreach ($array as $k => $v) {
            $return = $callback($default, $v, $k, $n++);
            if ($return === false) {
                break;
            }
        }
        return $default;
    }
}
if (function_exists("ryunosuke\\dbml\\array_each") && !defined("ryunosuke\\dbml\\array_each")) {
    define("ryunosuke\\dbml\\array_each", "ryunosuke\\dbml\\array_each");
}

if (!isset($excluded_functions["array_depth"]) && (!function_exists("ryunosuke\\dbml\\array_depth") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_depth"))->isInternal()))) {
    /**
     * 配列の次元数を返す
     *
     * フラット配列は 1 と定義する。
     * つまり、配列を与える限りは 0 以下を返すことはない。
     *
     * 第2引数 $max_depth を与えるとその階層になった時点で走査を打ち切る。
     * 「1階層のみか？」などを調べるときは指定したほうが高速に動作する。
     *
     * Example:
     * ```php
     * that(array_depth([]))->isSame(1);
     * that(array_depth(['hoge']))->isSame(1);
     * that(array_depth([['nest1' => ['nest2']]]))->isSame(3);
     * ```
     *
     * @param array $array 調べる配列
     * @param int|null $max_depth 最大階層数
     * @return int 次元数。素のフラット配列は 1
     */
    function array_depth($array, $max_depth = null)
    {
        assert((is_null($max_depth)) || $max_depth > 0);

        $main = function ($array, $depth) use (&$main, $max_depth) {
            // $max_depth を超えているなら打ち切る
            if ($max_depth !== null && $depth >= $max_depth) {
                return 1;
            }

            // 配列以外に興味はない
            $arrays = array_filter($array, 'is_array');

            // ネストしない配列は 1 と定義
            if (!$arrays) {
                return 1;
            }

            // 配下の内で最大を返す
            return 1 + max(array_map(function ($v) use ($main, $depth) { return $main($v, $depth + 1); }, $arrays));
        };

        return $main($array, 1);
    }
}
if (function_exists("ryunosuke\\dbml\\array_depth") && !defined("ryunosuke\\dbml\\array_depth")) {
    define("ryunosuke\\dbml\\array_depth", "ryunosuke\\dbml\\array_depth");
}

if (!isset($excluded_functions["array_insert"]) && (!function_exists("ryunosuke\\dbml\\array_insert") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_insert"))->isInternal()))) {
    /**
     * 配列・連想配列を問わず任意の位置に値を挿入する
     *
     * $position を省略すると最後に挿入される（≒ array_push）。
     * $position に負数を与えると後ろから数えられる。
     * $value には配列も与えられるが、その場合数値キーは振り直される
     *
     * Example:
     * ```php
     * that(array_insert([1, 2, 3], 'x'))->isSame([1, 2, 3, 'x']);
     * that(array_insert([1, 2, 3], 'x', 1))->isSame([1, 'x', 2, 3]);
     * that(array_insert([1, 2, 3], 'x', -1))->isSame([1, 2, 'x', 3]);
     * that(array_insert([1, 2, 3], ['a' => 'A', 'b' => 'B'], 1))->isSame([1, 'a' => 'A', 'b' => 'B', 2, 3]);
     * ```
     *
     * @param array $array 対象配列
     * @param mixed $value 挿入値
     * @param int|null $position 挿入位置
     * @return array 挿入された新しい配列
     */
    function array_insert($array, $value, $position = null)
    {
        if (!is_array($value)) {
            $value = [$value];
        }

        $position = is_null($position) ? count($array) : intval($position);

        $sarray = array_splice($array, 0, $position);
        return array_merge($sarray, $value, $array);
    }
}
if (function_exists("ryunosuke\\dbml\\array_insert") && !defined("ryunosuke\\dbml\\array_insert")) {
    define("ryunosuke\\dbml\\array_insert", "ryunosuke\\dbml\\array_insert");
}

if (!isset($excluded_functions["array_count"]) && (!function_exists("ryunosuke\\dbml\\array_count") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_count"))->isInternal()))) {
    /**
     * 配列をコールバックに従ってカウントする
     *
     * コールバックが true 相当を返した要素をカウントして返す。
     * 普通に使う分には `count(array_filter($array, $callback))` とほとんど同じだが、下記の点が微妙に異なる。
     *
     * - $callback が要求するならキーも渡ってくる
     * - $callback には配列が渡せる。配列を渡した場合は件数を配列で返す（Example 参照）
     *
     * $recursive に true を渡すと再帰的に動作する。
     * 末端・配列を問わずに呼び出されるので場合によっては is_array などの判定が必要になる。
     *
     * Example:
     * ```php
     * $array = ['hoge', 'fuga', 'piyo'];
     * // 'o' を含むものの数（2個）
     * that(array_count($array, function($s){return strpos($s, 'o') !== false;}))->isSame(2);
     * // 'a' と 'o' を含むものをそれぞれ（1個と2個）
     * that(array_count($array, [
     *     'a' => function($s){return strpos($s, 'a') !== false;},
     *     'o' => function($s){return strpos($s, 'o') !== false;},
     * ]))->isSame([
     *     'a' => 1,
     *     'o' => 2,
     * ]);
     *
     * // 再帰版
     * $array = [
     *     ['1', '2', '3'],
     *     ['a', 'b', 'c'],
     *     ['X', 'Y', 'Z'],
     *     [[[['a', 'M', 'Z']]]],
     * ];
     * that((array_count)($array, [
     *     'lower' => function ($v) { return !is_array($v) && ctype_lower($v);},
     *     'upper' => function ($v) { return !is_array($v) && ctype_upper($v);},
     *     'array' => function ($v) { return is_array($v);},
     * ], true))->is([
     *     'lower' => 4, // 小文字の数
     *     'upper' => 5, // 大文字の数
     *     'array' => 7, // 配列の数
     * ]);
     * ```
     *
     * @param iterable $array 対象配列
     * @param callable $callback カウントルール。配列も渡せる
     * @param bool $recursive 再帰フラグ
     * @return int|array 条件一致した件数
     */
    function array_count($array, $callback, $recursive = false)
    {
        // 配列が来た場合はまるで動作が異なる（再帰でもいいがそれだと旨味がない。複数欲しいなら呼び出し元で複数回呼べば良い。ワンループに閉じ込めるからこそメリットがある））
        if (is_array($callback) && !is_callable($callback)) {
            $result = array_fill_keys(array_keys($callback), 0);
            foreach ($callback as $name => $rule) {
                $rule = func_user_func_array($rule);
                $n = 0;
                foreach ($array as $k => $v) {
                    if ($rule($v, $k, $n++)) {
                        $result[$name]++;
                    }
                    if ($recursive && is_iterable($v)) {
                        $result[$name] += array_count($v, $rule, $recursive);
                    }
                }
            }
            return $result;
        }

        $callback = func_user_func_array($callback);
        $result = 0;
        $n = 0;
        foreach ($array as $k => $v) {
            if ($callback($v, $k, $n++)) {
                $result++;
            }
            if ($recursive && is_iterable($v)) {
                $result += array_count($v, $callback, $recursive);
            }
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\array_count") && !defined("ryunosuke\\dbml\\array_count")) {
    define("ryunosuke\\dbml\\array_count", "ryunosuke\\dbml\\array_count");
}

if (!isset($excluded_functions["array_all"]) && (!function_exists("ryunosuke\\dbml\\array_all") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_all"))->isInternal()))) {
    /**
     * 全要素が true になるなら true を返す（1つでも false なら false を返す）
     *
     * $callback が要求するならキーも渡ってくる。
     *
     * Example:
     * ```php
     * that(array_all([true, true]))->isTrue();
     * that(array_all([true, false]))->isFalse();
     * that(array_all([false, false]))->isFalse();
     * ```
     *
     * @param iterable $array 対象配列
     * @param ?callable $callback 評価クロージャ。 null なら値そのもので評価
     * @param bool|mixed $default 空配列の場合のデフォルト値
     * @return bool 全要素が true なら true
     */
    function array_all($array, $callback = null, $default = true)
    {
        if (is_empty($array)) {
            return $default;
        }

        $callback = func_user_func_array($callback);

        $n = 0;
        foreach ($array as $k => $v) {
            if (!$callback($v, $k, $n++)) {
                return false;
            }
        }
        return true;
    }
}
if (function_exists("ryunosuke\\dbml\\array_all") && !defined("ryunosuke\\dbml\\array_all")) {
    define("ryunosuke\\dbml\\array_all", "ryunosuke\\dbml\\array_all");
}

if (!isset($excluded_functions["array_order"]) && (!function_exists("ryunosuke\\dbml\\array_order") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_order"))->isInternal()))) {
    /**
     * 配列を $orders に従って並べ替える
     *
     * データベースからフェッチしたような連想配列の配列を想定しているが、スカラー配列(['key' => 'value'])にも対応している。
     * その場合 $orders に配列ではなく直値を渡せば良い。
     *
     * $orders には下記のような配列を渡す。
     * キーに空文字を渡すとそれは「キー自体」を意味する。
     *
     * ```php
     * $orders = [
     *     'col1' => true,                               // true: 昇順, false: 降順。照合は型に依存
     *     'col2' => SORT_NATURAL,                       // SORT_NATURAL, SORT_REGULAR などで照合。正数で昇順、負数で降順
     *     'col3' => ['sort', 'this', 'order'],          // 指定した配列順で昇順
     *     'col4' => function($v) {return $v;},          // クロージャを通した値で昇順。照合は返り値の型に依存
     *     'col5' => function($a, $b) {return $a - $b;}, // クロージャで比較して昇順（いわゆる比較関数を渡す）
     * ];
     * ```
     *
     * Example:
     * ```php
     * $v1 = ['id' => '1', 'no' => 'a03', 'name' => 'yyy'];
     * $v2 = ['id' => '2', 'no' => 'a4',  'name' => 'yyy'];
     * $v3 = ['id' => '3', 'no' => 'a12', 'name' => 'xxx'];
     * // name 昇順, no 自然降順
     * that(array_order([$v1, $v2, $v3], ['name' => true, 'no' => -SORT_NATURAL]))->isSame([$v3, $v2, $v1]);
     * ```
     *
     * @param array $array 対象配列
     * @param mixed $orders ソート順
     * @param bool $preserve_keys キーを保存するか。 false の場合数値キーは振り直される
     * @return array 並び替えられた配列
     */
    function array_order(array $array, $orders, $preserve_keys = false)
    {
        if (count($array) <= 1) {
            return $array;
        }

        if (!is_array($orders) || !is_hasharray($orders)) {
            $orders = [$orders];
        }

        // 配列内の位置をマップして返すクロージャ
        $position = function ($columns, $order) {
            return array_map(function ($v) use ($order) {
                $ndx = array_search($v, $order, true);
                return $ndx === false ? count($order) : $ndx;
            }, $columns);
        };

        // 全要素は舐めてられないので最初の要素を代表選手としてピックアップ
        $first = reset($array);
        $is_scalar = is_scalar($first) || is_null($first);

        // array_multisort 用の配列を生成
        $args = [];
        foreach ($orders as $key => $order) {
            if ($is_scalar) {
                $firstval = reset($array);
                $columns = $array;
            }
            else {
                if ($key !== '' && !array_key_exists($key, $first)) {
                    throw new \InvalidArgumentException("$key is undefined.");
                }
                if ($key === '') {
                    $columns = array_keys($array);
                    $firstval = reset($columns);
                }
                else {
                    $firstval = $first[$key];
                    $columns = array_column($array, $key);
                }
            }

            // bool は ASC, DESC
            if (is_bool($order)) {
                $args[] = $columns;
                $args[] = $order ? SORT_ASC : SORT_DESC;
                $args[] = is_string($firstval) ? SORT_STRING : SORT_NUMERIC;
            }
            // int は SORT_*****
            elseif (is_int($order)) {
                $args[] = $columns;
                $args[] = $order > 0 ? SORT_ASC : SORT_DESC;
                $args[] = abs($order);
            }
            // 配列はその並び
            elseif (is_array($order)) {
                $args[] = $position($columns, $order);
                $args[] = SORT_ASC;
                $args[] = SORT_NUMERIC;
            }
            // クロージャは色々
            elseif ($order instanceof \Closure) {
                $ref = new \ReflectionFunction($order);
                // 引数2個なら比較関数
                if ($ref->getNumberOfRequiredParameters() === 2) {
                    $map = $columns;
                    usort($map, $order);
                    $args[] = $position($columns, $map);
                    $args[] = SORT_ASC;
                    $args[] = SORT_NUMERIC;
                }
                // でないなら通した値で比較
                else {
                    $arg = array_map($order, $columns);
                    $type = reflect_types($ref->getReturnType())->allows('string') ? 'string' : gettype(reset($arg));
                    $args[] = $arg;
                    $args[] = SORT_ASC;
                    $args[] = $type === 'string' ? SORT_STRING : SORT_NUMERIC;
                }
            }
            else {
                throw new \DomainException('$order is invalid.');
            }
        }

        // array_multisort はキーを保持しないので、ソートされる配列にキー配列を加えて後で combine する
        if ($preserve_keys) {
            $keys = array_keys($array);
            $args[] = &$array;
            $args[] = &$keys;
            array_multisort(...$args);
            return array_combine($keys, $array);
        }
        // キーを保持しないなら単純呼び出しで OK
        else {
            $args[] = &$array;
            array_multisort(...$args);
            return $array;
        }
    }
}
if (function_exists("ryunosuke\\dbml\\array_order") && !defined("ryunosuke\\dbml\\array_order")) {
    define("ryunosuke\\dbml\\array_order", "ryunosuke\\dbml\\array_order");
}

if (!isset($excluded_functions["array_pickup"]) && (!function_exists("ryunosuke\\dbml\\array_pickup") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_pickup"))->isInternal()))) {
    /**
     * キーを指定してそれだけの配列にする
     *
     * `array_intersect_key($array, array_flip($keys))` とほぼ同義。
     * 違いは Traversable を渡せることと、結果配列の順番が $keys に従うこと。
     *
     * $keys に連想配列を渡すとキーを読み替えて動作する（Example を参照）。
     *
     * Example:
     * ```php
     * $array = ['a' => 'A', 'b' => 'B', 'c' => 'C'];
     * // a と c を取り出す
     * that(array_pickup($array, ['a', 'c']))->isSame(['a' => 'A', 'c' => 'C']);
     * // 順番は $keys 基準になる
     * that(array_pickup($array, ['c', 'a']))->isSame(['c' => 'C', 'a' => 'A']);
     * // 連想配列を渡すと読み替えて返す
     * that(array_pickup($array, ['c' => 'cX', 'a' => 'aX']))->isSame(['cX' => 'C', 'aX' => 'A']);
     * ```
     *
     * @param iterable $array 対象配列
     * @param array $keys 取り出すキー
     * @return array 新しい配列
     */
    function array_pickup($array, $keys)
    {
        $array = arrayval($array, false);

        $result = [];
        foreach (arrayval($keys, false) as $k => $key) {
            if (is_int($k)) {
                if (array_key_exists($key, $array)) {
                    $result[$key] = $array[$key];
                }
            }
            else {
                if (array_key_exists($k, $array)) {
                    $result[$key] = $array[$k];
                }
            }
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\array_pickup") && !defined("ryunosuke\\dbml\\array_pickup")) {
    define("ryunosuke\\dbml\\array_pickup", "ryunosuke\\dbml\\array_pickup");
}

if (!isset($excluded_functions["array_lookup"]) && (!function_exists("ryunosuke\\dbml\\array_lookup") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_lookup"))->isInternal()))) {
    /**
     * キー保存可能な array_column
     *
     * array_column は キーを保存することが出来ないが、この関数は引数を2つだけ与えるとキーはそのままで array_column 相当の配列を返す。
     * 逆に第3引数にクロージャを与えるとその結果をキーにすることが出来る。
     *
     * Example:
     * ```php
     * $array = [
     *     11 => ['id' => 1, 'name' => 'name1'],
     *     12 => ['id' => 2, 'name' => 'name2'],
     *     13 => ['id' => 3, 'name' => 'name3'],
     * ];
     * // 第3引数を渡せば array_column と全く同じ
     * that(array_lookup($array, 'name', 'id'))->isSame(array_column($array, 'name', 'id'));
     * that(array_lookup($array, 'name', null))->isSame(array_column($array, 'name', null));
     * // 省略すればキーが保存される
     * that(array_lookup($array, 'name'))->isSame([
     *     11 => 'name1',
     *     12 => 'name2',
     *     13 => 'name3',
     * ]);
     * // クロージャを指定すればキーが生成される
     * that(array_lookup($array, 'name', function ($v, $k) {return $k * 2;}))->isSame([
     *     22 => 'name1',
     *     24 => 'name2',
     *     26 => 'name3',
     * ]);
     * ```
     *
     * @param iterable $array 対象配列
     * @param string|null $column_key 値となるキー
     * @param string|\Closure|null $index_key キーとなるキー
     * @return array 新しい配列
     */
    function array_lookup($array, $column_key = null, $index_key = null)
    {
        $array = arrayval($array, false);

        if ($index_key instanceof \Closure) {
            return array_combine(array_kmap($array, $index_key), array_column($array, $column_key));
        }
        if (func_num_args() === 3) {
            return array_column($array, $column_key, $index_key);
        }
        return array_combine(array_keys($array), array_column($array, $column_key));
    }
}
if (function_exists("ryunosuke\\dbml\\array_lookup") && !defined("ryunosuke\\dbml\\array_lookup")) {
    define("ryunosuke\\dbml\\array_lookup", "ryunosuke\\dbml\\array_lookup");
}

if (!isset($excluded_functions["array_uncolumns"]) && (!function_exists("ryunosuke\\dbml\\array_uncolumns") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_uncolumns"))->isInternal()))) {
    /**
     * array_columns のほぼ逆で [キー => [要素]] 配列から連想配列の配列を生成する
     *
     * $template を指定すると「それに含まれる配列かつ値がデフォルト」になる（要するに $default みたいなもの）。
     * キーがバラバラな配列を指定する場合は指定したほうが良い。が、null を指定すると最初の要素が使われるので大抵の場合は null で良い。
     *
     * Example:
     * ```php
     * that(array_uncolumns([
     *     'id'   => [1, 2],
     *     'name' => ['A', 'B'],
     * ]))->isSame([
     *     ['id' => 1, 'name' => 'A'],
     *     ['id' => 2, 'name' => 'B'],
     * ]);
     * ```
     *
     * @param array $array 対象配列
     * @param ?array $template 抽出要素とそのデフォルト値
     * @return array 新しい配列
     */
    function array_uncolumns($array, $template = null)
    {
        // 指定されていないなら生のまま
        if (func_num_args() === 1) {
            $template = false;
        }
        // null なら最初の要素のキー・null
        if ($template === null) {
            $template = array_fill_keys(array_keys(first_value($array)), null);
        }

        $result = [];
        foreach ($array as $key => $vals) {
            if ($template !== false) {
                $vals = array_intersect_key($vals + $template, $template);
            }
            foreach ($vals as $n => $val) {
                $result[$n][$key] = $val;
            }
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\array_uncolumns") && !defined("ryunosuke\\dbml\\array_uncolumns")) {
    define("ryunosuke\\dbml\\array_uncolumns", "ryunosuke\\dbml\\array_uncolumns");
}

if (!isset($excluded_functions["array_convert"]) && (!function_exists("ryunosuke\\dbml\\array_convert") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_convert"))->isInternal()))) {
    /**
     * 配列の各要素に再帰的にコールバックを適用して変換する
     *
     * $callback は下記の仕様。
     *
     * 引数は (キー, 値, 今まで処理したキー配列) で渡ってくる。
     * 返り値は新しいキーを返す。
     *
     * - 文字列や数値を返すとそれがキーとして使われる
     * - null を返すと元のキーがそのまま使われる
     * - true を返すと数値連番が振られる
     * - false を返すとその要素は無かったことになる
     * - 配列を返すとその配列で完全に置換される
     *
     * $apply_array=false で要素が配列の場合は再帰され、コールバックが適用されない（array_walk_recursive と同じ仕様）。
     *
     * $apply_array=true だと配列かは問わず全ての要素にコールバックが適用される。
     * 配列も渡ってきてしまうのでコールバック内部で is_array 判定が必要になる場合がある。
     *
     * 「map も filter も可能でキー変更可能かつ再帰的」というとてもマッチョな関数。
     * 複雑だが実質的には「キーも設定できる array_walk_recursive」のように振る舞う（そしてそのような使い方を想定している）。
     *
     * Example:
     * ```php
     * $array = [
     *    'k1' => 'v1',
     *    'k2' => [
     *        'k21' => 'v21',
     *        'k22' => [
     *            'k221' => 'v221',
     *            'k222' => 'v222',
     *        ],
     *        'k23' => 'v23',
     *    ],
     * ];
     * // 全要素に 'prefix-' を付与する。キーには '_' をつける。ただし 'k21' はそのままとする。さらに 'k22' はまるごと伏せる。 'k23' は数値キーになる
     * $callback = function($k, &$v){
     *     if ($k === 'k21') return null;
     *     if ($k === 'k22') return false;
     *     if ($k === 'k23') return true;
     *     if (!is_array($v)) $v = "prefix-$v";
     *     return "_$k";
     * };
     * that(array_convert($array, $callback, true))->isSame([
     *     '_k1' => 'prefix-v1',
     *     '_k2' => [
     *         'k21' => 'v21',
     *         0     => 'v23',
     *     ],
     * ]);
     * ```
     *
     * @param array $array 対象配列
     * @param callable $callback 適用するコールバック
     * @param bool $apply_array 配列要素にもコールバックを適用するか
     * @return array 変換された配列
     */
    function array_convert($array, $callback, $apply_array = false)
    {
        $recursive = function (&$result, $array, $history, $callback) use (&$recursive, $apply_array) {
            $sequences = [];
            foreach ($array as $key => $value) {
                $is_array = is_array($value);
                $newkey = $key;
                // 配列で $apply_array あるいは非配列の場合にコールバック適用
                if (($is_array && $apply_array) || !$is_array) {
                    $newkey = $callback($key, $value, $history);
                }
                // 配列は置換
                if (is_array($newkey)) {
                    foreach ($newkey as $k => $v) {
                        $result[$k] = $v;
                    }
                    continue;
                }
                // false はスルー
                if ($newkey === false) {
                    continue;
                }
                // true は数値連番
                if ($newkey === true) {
                    if ($is_array) {
                        $sequences["_$key"] = $value;
                    }
                    else {
                        $sequences[] = $value;
                    }
                    continue;
                }
                // null は元のキー
                if ($newkey === null) {
                    $newkey = $key;
                }
                // 配列と非配列で代入の仕方が異なる
                if ($is_array) {
                    $history[] = $key;
                    $result[$newkey] = [];
                    $recursive($result[$newkey], $value, $history, $callback);
                    array_pop($history);
                }
                else {
                    $result[$newkey] = $value;
                }
            }
            // 数値連番は上書きを防ぐためにあとでやる
            foreach ($sequences as $key => $value) {
                if (is_string($key)) {
                    $history[] = substr($key, 1);
                    $v = [];
                    $result[] = &$v;
                    $recursive($v, $value, $history, $callback);
                    array_pop($history);
                    unset($v);
                }
                else {
                    $result[] = $value;
                }
            }
        };

        $result = [];
        $recursive($result, $array, [], $callback);
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\array_convert") && !defined("ryunosuke\\dbml\\array_convert")) {
    define("ryunosuke\\dbml\\array_convert", "ryunosuke\\dbml\\array_convert");
}

if (!isset($excluded_functions["array_flatten"]) && (!function_exists("ryunosuke\\dbml\\array_flatten") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_flatten"))->isInternal()))) {
    /**
     * 多階層配列をフラットに展開する
     *
     * 巷にあふれている実装と違って、 ["$pkey.$ckey" => $value] 形式の配列でも返せる。
     * $delimiter で区切り文字を指定した場合にそのようになる。
     * $delimiter = null の場合に本当の配列で返す（巷の実装と同じ）。
     *
     * Example:
     * ```php
     * $array = [
     *    'k1' => 'v1',
     *    'k2' => [
     *        'k21' => 'v21',
     *        'k22' => [
     *            'k221' => 'v221',
     *            'k222' => 'v222',
     *            'k223' => [1, 2, 3],
     *        ],
     *    ],
     * ];
     * // 区切り文字指定なし
     * that(array_flatten($array))->isSame([
     *    0 => 'v1',
     *    1 => 'v21',
     *    2 => 'v221',
     *    3 => 'v222',
     *    4 => 1,
     *    5 => 2,
     *    6 => 3,
     * ]);
     * // 区切り文字指定
     * that(array_flatten($array, '.'))->isSame([
     *    'k1'            => 'v1',
     *    'k2.k21'        => 'v21',
     *    'k2.k22.k221'   => 'v221',
     *    'k2.k22.k222'   => 'v222',
     *    'k2.k22.k223.0' => 1,
     *    'k2.k22.k223.1' => 2,
     *    'k2.k22.k223.2' => 3,
     * ]);
     * ```
     *
     * @param iterable $array 対象配列
     * @param string|\Closure|null $delimiter キーの区切り文字。 null を与えると連番になる
     * @return array フラット化された配列
     */
    function array_flatten($array, $delimiter = null)
    {
        $result = [];
        $core = function ($array, $delimiter, $parents) use (&$core, &$result) {
            foreach ($array as $k => $v) {
                $keys = $parents;
                $keys[] = $k;
                if (is_iterable($v)) {
                    $core($v, $delimiter, $keys);
                }
                else {
                    if ($delimiter === null) {
                        $result[] = $v;
                    }
                    elseif ($delimiter instanceof \Closure) {
                        $result[$delimiter($keys)] = $v;
                    }
                    else {
                        $result[implode($delimiter, $keys)] = $v;
                    }
                }
            }
        };

        $core($array, $delimiter, []);
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\array_flatten") && !defined("ryunosuke\\dbml\\array_flatten")) {
    define("ryunosuke\\dbml\\array_flatten", "ryunosuke\\dbml\\array_flatten");
}

if (!isset($excluded_functions["array_nest"]) && (!function_exists("ryunosuke\\dbml\\array_nest") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\array_nest"))->isInternal()))) {
    /**
     * シンプルな [キー => 値] な配列から階層配列を生成する
     *
     * 定義的に array_flatten の逆関数のような扱いになる。
     * $delimiter で階層を表現する。
     *
     * 同名とみなされるキーは上書きされるか例外が飛ぶ。具体的には Example を参照。
     *
     * Example:
     * ```php
     * // 単純な階層展開
     * $array = [
     *    'k1'            => 'v1',
     *    'k2.k21'        => 'v21',
     *    'k2.k22.k221'   => 'v221',
     *    'k2.k22.k222'   => 'v222',
     *    'k2.k22.k223.0' => 1,
     *    'k2.k22.k223.1' => 2,
     *    'k2.k22.k223.2' => 3,
     * ];
     * that(array_nest($array))->isSame([
     *    'k1' => 'v1',
     *    'k2' => [
     *        'k21' => 'v21',
     *        'k22' => [
     *            'k221' => 'v221',
     *            'k222' => 'v222',
     *            'k223' => [1, 2, 3],
     *        ],
     *    ],
     * ]);
     * // 同名になるようなキーは上書きされる
     * $array = [
     *    'k1.k2' => 'v1', // この時点で 'k1' は配列になるが・・・
     *    'k1'    => 'v2', // この時点で 'k1' は文字列として上書きされる
     * ];
     * that(array_nest($array))->isSame([
     *    'k1' => 'v2',
     * ]);
     * // 上書きすら出来ない場合は例外が飛ぶ
     * $array = [
     *    'k1'    => 'v1', // この時点で 'k1' は文字列になるが・・・
     *    'k1.k2' => 'v2', // この時点で 'k1' にインデックスアクセスすることになるので例外が飛ぶ
     * ];
     * try {
     *     array_nest($array);
     * }
     * catch (\Exception $e) {
     *     that($e)->isInstanceOf(\InvalidArgumentException::class);
     * }
     * ```
     *
     * @param iterable $array 対象配列
     * @param string $delimiter キーの区切り文字
     * @return array 階層化された配列
     */
    function array_nest($array, $delimiter = '.')
    {
        $result = [];
        foreach ($array as $k => $v) {
            $keys = explode($delimiter, $k);
            $rkeys = [];
            $tmp = &$result;
            foreach ($keys as $key) {
                $rkeys[] = $key;
                if (isset($tmp[$key]) && !is_array($tmp[$key])) {
                    throw new \InvalidArgumentException("'" . implode($delimiter, $rkeys) . "' of '$k' is already exists.");
                }
                $tmp = &$tmp[$key];
            }
            $tmp = $v;
            unset($tmp);
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\array_nest") && !defined("ryunosuke\\dbml\\array_nest")) {
    define("ryunosuke\\dbml\\array_nest", "ryunosuke\\dbml\\array_nest");
}

if (!isset($excluded_functions["class_shorten"]) && (!function_exists("ryunosuke\\dbml\\class_shorten") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\class_shorten"))->isInternal()))) {
    /**
     * クラスの名前空間部分を除いた短い名前を取得する
     *
     * Example:
     * ```php
     * that(class_shorten('vendor\\namespace\\ClassName'))->isSame('ClassName');
     * ```
     *
     * @param string|object $class 対象クラス・オブジェクト
     * @return string クラスの短い名前
     */
    function class_shorten($class)
    {
        if (is_object($class)) {
            $class = get_class($class);
        }

        $parts = explode('\\', $class);
        return array_pop($parts);
    }
}
if (function_exists("ryunosuke\\dbml\\class_shorten") && !defined("ryunosuke\\dbml\\class_shorten")) {
    define("ryunosuke\\dbml\\class_shorten", "ryunosuke\\dbml\\class_shorten");
}

if (!isset($excluded_functions["reflect_types"]) && (!function_exists("ryunosuke\\dbml\\reflect_types") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\reflect_types"))->isInternal()))) {
    /**
     * ReflectionType の型配列を返す
     *
     * ReflectionType のインターフェース・仕様がコロコロ変わってついていけないので関数化した。
     *
     * ReflectionType に準ずるインスタンスを渡すと取り得る候補を配列ライクなオブジェクトで返す。
     * 引数は配列で複数与えても良い。よしなに扱って複数型として返す。
     * また「Type が一意に導出できる Reflection」を渡しても良い（ReflectionProperty など）。
     * null を与えた場合はエラーにはならず、スルーされる（getType は null を返し得るので利便性のため）。
     *
     * 単純に ReflectionType の配列ライクなオブジェクトを返すが、そのオブジェクトは `__toString` が実装されており、文字列化するとパイプ区切りの型文字列を返す。
     * これは 8.0 における ReflectionUnionType の `__toString` を模倣したものである。
     * 互換性のある型があった場合、上位の型に内包されて型文字列としては出現しない。
     *
     * Countable も実装されているが、その結果は「内部 Type の数」ではなく、論理的に「取り得る型の数」を返す。
     * 例えば `?int` は型としては1つだが、実際は int, null の2つを取り得るため、 count は 2 を返す。
     * 端的に言えば「`__toString` のパイプ区切りの型の数」を返す。
     *
     * あとは便利メソッドとして下記が生えている。
     *
     * - jsonSerialize: JsonSerializable 実装
     * - getTypes: 取り得る型をすべて返す（ReflectionUnionType 互換）
     * - getName: ReflectionUnionType 非互換 toString な型宣言文字列を返す
     * - allows: その値を取りうるか判定して返す
     *
     * ReflectionUnionType とは完全互換ではないので、php8.0が完全に使える環境であれば素直に ReflectionUnionType を使ったほうが良い。
     * （「常に（型分岐せずに）複数形で扱える」程度のメリットしかない。allows は惜しいが）。
     *
     * ちなみに型の変遷は下記の通り。
     *
     * - php7.1: ReflectionType::__toString が非推奨になった
     * - php7.1: ReflectionNamedType が追加され、各種 getType でそれを返すようになった
     * - php8.0: ReflectionType::__toString が非推奨ではなくなった
     * - php8.0: ReflectionUnionType が追加され、複合の場合は getType でそれを返すようになった
     *
     * Example:
     * ```php
     * $object = new class {
     *     function method(object $o):?string {}
     * };
     * $method = new \ReflectionMethod($object, 'method');
     * $types = reflect_types($method->getParameters()[0]->getType());
     * // 文字列化すると型宣言文字列を返すし、配列アクセスや count, iterable でそれぞれの型が得られる
     * that((string) $types)->is('object');
     * that($types[0])->isInstanceOf(\ReflectionType::class);
     * that(iterator_to_array($types))->eachIsInstanceOf(\ReflectionType::class);
     * that(count($types))->is(1);
     * // 返り値でも同じ（null 許容なので null が付くし count も 2 になる）
     * $types = reflect_types($method->getReturnType());
     * that((string) $types)->is('string|null');
     * that(count($types))->is(2);
     * ```
     *
     * @param \ReflectionFunctionAbstract|\ReflectionType|\ReflectionType[]|null $reflection_type getType 等で得られるインスタンス
     * @return \Traversable|\ArrayAccess|\Countable|\ReflectionNamedType|\ReflectionUnionType
     */
    function reflect_types($reflection_type = null)
    {
        if (!is_array($reflection_type)) {
            $reflection_type = [$reflection_type];
        }

        foreach ($reflection_type as $n => $rtype) {
            if ($rtype instanceof \ReflectionProperty) {
                $reflection_type[$n] = $rtype->getType();
            }
            if ($rtype instanceof \ReflectionFunctionAbstract) {
                $reflection_type[$n] = $rtype->getReturnType();
            }
            if ($rtype instanceof \ReflectionParameter) {
                $reflection_type[$n] = $rtype->getType();
            }
        }

        return new class(...$reflection_type)
            extends \stdClass
            implements \IteratorAggregate, \ArrayAccess, \Countable, \JsonSerializable {

            private const PSEUDO = [
                'mixed'    => [],
                'static'   => ['object', 'mixed'],
                'self'     => ['static', 'object', 'mixed'],
                'parent'   => ['static', 'object', 'mixed'],
                'callable' => ['mixed'],
                'iterable' => ['mixed'],
                'object'   => ['mixed'],
                'array'    => ['iterable', 'mixed'],
                'string'   => ['mixed'],
                'int'      => ['mixed'],
                'float'    => ['mixed'],
                'bool'     => ['mixed'],
                'false'    => ['bool', 'mixed'],
                'null'     => ['mixed'],
                'void'     => [],
            ];

            public function __construct(?\ReflectionType ...$reflection_types)
            {
                $types = [];
                foreach ($reflection_types as $type) {
                    if ($type === null) {
                        continue;
                    }

                    /** @noinspection PhpElementIsNotAvailableInCurrentPhpVersionInspection */
                    $types = array_merge($types, $type instanceof \ReflectionUnionType ? $type->getTypes() : [$type]);
                }

                // 配列キャストで配列を得たいので下手にフィールドを宣言せず直に生やす
                foreach ($types as $n => $type) {
                    $this->$n = $type;
                }
            }

            public function __toString()
            {
                return implode('|', $this->toStrings(true, true));
            }

            public function getIterator()
            {
                // yield from $this->getTypes();
                return new \ArrayIterator($this->getTypes());
            }

            public function offsetExists($offset)
            {
                return isset($this->$offset);
            }

            public function offsetGet($offset)
            {
                return $this->$offset;
            }

            public function offsetSet($offset, $value)
            {
                // for debug
                if (is_string($value)) {
                    $value = new class ($value, self::PSEUDO) extends \ReflectionNamedType {
                        private $typename;
                        private $nullable;
                        private $builtins;

                        public function __construct($typename, $builtins)
                        {
                            $this->typename = ltrim($typename, '?');
                            $this->nullable = $typename[0] === '?';
                            $this->builtins = $builtins;
                        }

                        public function getName() { return $this->typename; }

                        public function allowsNull() { return $this->nullable; }

                        public function isBuiltin() { return isset($this->builtins[$this->typename]); }

                        public function __toString() { return $this->getName(); }
                    };
                }

                assert($value instanceof \ReflectionType);
                if ($offset === null) {
                    $offset = max(array_keys($this->getTypes()) ?: [-1]) + 1;
                }
                $this->$offset = $value;
            }

            public function offsetUnset($offset)
            {
                unset($this->$offset);
            }

            public function count()
            {
                return count($this->toStrings(true, false));
            }

            public function jsonSerialize()
            {
                return $this->toStrings(true, true);
            }

            public function getName()
            {
                $types = array_flip($this->toStrings(true, true));
                $nullable = false;
                if (isset($types['null']) && count($types) === 2) {
                    unset($types['null']);
                    $nullable = true;
                }

                $result = [];
                foreach ($types as $type => $dummy) {
                    $result[] = (isset(self::PSEUDO[$type]) ? '' : '\\') . $type;
                }
                return ($nullable ? '?' : '') . implode('|', $result);
            }

            public function getTypes()
            {
                return (array) $this;
            }

            public function allows($type, $strict = false)
            {
                $types = array_flip($this->toStrings(false, false));

                if (isset($types['mixed'])) {
                    return true;
                }

                foreach ($types as $allow => $dummy) {
                    if (function_exists($f = "is_$allow") && $f($type)) {
                        return true;
                    }
                    if (is_a($type, $allow, true)) {
                        return true;
                    }
                }

                if (!$strict) {
                    if (is_int($type) || is_float($type) || is_bool($type)) {
                        if (isset($types['int']) || isset($types['float']) || isset($types['bool']) || isset($types['string'])) {
                            return true;
                        }
                    }
                    if (is_string($type) || (is_object($type) && method_exists($type, '__toString'))) {
                        if (isset($types['string'])) {
                            return true;
                        }
                        if ((isset($types['int']) || isset($types['float'])) && is_numeric("$type")) {
                            return true;
                        }
                    }
                }
                return false;
            }

            private function toStrings($ignore_compatible = true, $sort = true)
            {
                $types = [];
                foreach ($this->getTypes() as $type) {
                    // ドキュメント上は「ReflectionNamedType を返す可能性があります」とのことなので getName 前提はダメ
                    // かといって文字列化前提だと 7.1 以降で deprecated が出てしまう
                    // つまり愚直に分岐するか @ で抑制するくらいしか多バージョン対応する術がない（7.1 の deprecated を解除して欲しい…）
                    $types[$type instanceof \ReflectionNamedType ? $type->getName() : (string) $type] = true;

                    if ($type->allowsNull()) {
                        $types['null'] = true;
                    }
                }

                if ($ignore_compatible) {
                    $types = array_filter($types, function ($type) use ($types) {
                        // いくつか互換のある内包疑似型が存在する（iterable は array を内包するし、 bool は false を内包する）
                        foreach (self::PSEUDO[$type] ?? [] as $parent) {
                            if (isset($types[$parent])) {
                                return false;
                            }
                        }
                        // さらに object 疑似型は全てのクラス名を内包する
                        if (isset($types['object']) && !isset(self::PSEUDO[$type])) {
                            return false;
                        }
                        return true;
                    }, ARRAY_FILTER_USE_KEY);
                }

                if ($sort) {
                    static $orders = null;
                    $orders = $orders ?? array_flip(array_keys(self::PSEUDO));
                    uksort($types, function ($a, $b) use ($orders) {
                        $issetA = isset($orders[$a]);
                        $issetB = isset($orders[$b]);
                        switch (true) {
                            case $issetA && $issetB:   // 共に疑似型
                                return $orders[$a] - $orders[$b];
                            case !$issetA && !$issetB: // 共にクラス名
                                return strcasecmp($a, $b);
                            case !$issetA && $issetB:  // A だけがクラス名
                                return -1;
                            case $issetA && !$issetB:  // B だけがクラス名
                                return +1;
                        }
                    });
                }
                return array_keys($types);
            }
        };
    }
}
if (function_exists("ryunosuke\\dbml\\reflect_types") && !defined("ryunosuke\\dbml\\reflect_types")) {
    define("ryunosuke\\dbml\\reflect_types", "ryunosuke\\dbml\\reflect_types");
}

if (!isset($excluded_functions["get_object_properties"]) && (!function_exists("ryunosuke\\dbml\\get_object_properties") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\get_object_properties"))->isInternal()))) {
    /**
     * オブジェクトのプロパティを可視・不可視を問わず取得する
     *
     * get_object_vars + no public プロパティを返すイメージ。
     *
     * Example:
     * ```php
     * $object = new \Exception('something', 42);
     * $object->oreore = 'oreore';
     *
     * // get_object_vars はそのスコープから見えないプロパティを取得できない
     * // var_dump(get_object_vars($object));
     *
     * // array キャストは全て得られるが null 文字を含むので扱いにくい
     * // var_dump((array) $object);
     *
     * // この関数を使えば不可視プロパティも取得できる
     * that(get_object_properties($object))->arraySubset([
     *     'message' => 'something',
     *     'code'    => 42,
     *     'oreore'  => 'oreore',
     * ]);
     * ```
     *
     * @param object $object オブジェクト
     * @param array $privates 継承ツリー上の private が格納される
     * @return array 全プロパティの配列
     */
    function get_object_properties($object, &$privates = [])
    {
        $fields = [];
        foreach ((array) $object as $name => $field) {
            $names = explode("\0", $name);
            if (count($names) > 1) {
                $name = array_pop($names);
                $cname = $names[1];
                if ($cname !== '*' && $cname !== get_class($object)) {
                    $privates[$cname][$name] = $field;
                }
            }
            if (!array_key_exists($name, $fields)) {
                $fields[$name] = $field;
            }
        }
        return $fields;
    }
}
if (function_exists("ryunosuke\\dbml\\get_object_properties") && !defined("ryunosuke\\dbml\\get_object_properties")) {
    define("ryunosuke\\dbml\\get_object_properties", "ryunosuke\\dbml\\get_object_properties");
}

if (!isset($excluded_functions["date_timestamp"]) && (!function_exists("ryunosuke\\dbml\\date_timestamp") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\date_timestamp"))->isInternal()))) {
    /**
     * 日時文字列をよしなにタイムスタンプに変換する
     *
     * マイクロ秒にも対応している。つまり返り値は int か float になる。
     * また、相対指定の +1 month の月末問題は起きないようにしてある。
     *
     * かなり適当に和暦にも対応している。
     *
     * Example:
     * ```php
     * // 普通の日時文字列
     * that(date_timestamp('2014/12/24 12:34:56'))->isSame(strtotime('2014/12/24 12:34:56'));
     * // 和暦
     * that(date_timestamp('昭和31年12月24日 12時34分56秒'))->isSame(strtotime('1956/12/24 12:34:56'));
     * // 相対指定
     * that(date_timestamp('2012/01/31 +1 month'))->isSame(strtotime('2012/02/29'));
     * that(date_timestamp('2012/03/31 -1 month'))->isSame(strtotime('2012/02/29'));
     * // マイクロ秒
     * that(date_timestamp('2014/12/24 12:34:56.789'))->isSame(1419392096.789);
     * ```
     *
     * @param string|int|float $datetimedata 日時データ
     * @param int|null $baseTimestamp 日時データ
     * @return int|float|null タイムスタンプ。パース失敗時は null
     */
    function date_timestamp($datetimedata, $baseTimestamp = null)
    {
        // 全角を含めた trim
        $chars = "[\\x0-\x20\x7f\xc2\xa0\xe3\x80\x80]";
        $datetimedata = preg_replace("/\A{$chars}++|{$chars}++\z/u", '', $datetimedata);

        // 和暦を西暦に置換
        $jpnames = array_merge(array_column(JP_ERA, 'name'), array_column(JP_ERA, 'abbr'));
        $datetimedata = preg_replace_callback('/^(' . implode('|', $jpnames) . ')(\d{1,2}|元)/u', function ($matches) {
            [, $era, $year] = $matches;
            $eratime = array_find(JP_ERA, function ($v) use ($era) {
                if (in_array($era, [$v['name'], $v['abbr']], true)) {
                    return $v['since'];
                }
            }, false);
            return idate('Y', $eratime) + ($year === '元' ? 1 : $year) - 1;
        }, $datetimedata);

        // 単位文字列を置換
        $datetimedata = strtr($datetimedata, [
            '　'  => ' ',
            '西暦' => '',
            '年'  => '/',
            '月'  => '/',
            '日'  => ' ',
            '時'  => ':',
            '分'  => ':',
            '秒'  => '',
        ]);
        $datetimedata = trim($datetimedata, " \t\n\r\0\x0B:/");

        // 数値4桁は年と解釈されるように
        if (preg_match('/^[0-9]{4}$/', $datetimedata)) {
            $datetimedata .= '-01-01';
        }

        // 数値系はタイムスタンプとみなす
        if (ctype_digit("$datetimedata")) {
            return (int) $datetimedata;
        }
        if (is_numeric($datetimedata)) {
            return (float) $datetimedata;
        }

        // date_parse してみる
        $parts = date_parse($datetimedata);
        if (!$parts) {
            // ドキュメントに「成功した場合に日付情報を含む配列、失敗した場合に FALSE を返します」とあるが、失敗する気配がない
            return null; // @codeCoverageIgnore
        }
        if ($parts['error_count']) {
            return null;
        }

        if (!checkdate($parts['month'], $parts['day'], $parts['year'])) {
            if (!isset($parts['relative'])) {
                return null;
            }
            $baseTimestamp = $baseTimestamp ?? time();
            $parts['year'] = idate('Y', $baseTimestamp);
            $parts['month'] = idate('m', $baseTimestamp);
            $parts['day'] = idate('d', $baseTimestamp);
        }

        if (isset($parts['relative'])) {
            $relative = $parts['relative'];
            $parts['year'] += $relative['year'];
            $parts['month'] += $relative['month'];
            // php の相対指定は割と腐っているので補正する（末日を超えても月は変わらないようにする）
            if ($parts['month'] > 12) {
                $parts['year'] += intdiv($parts['month'], 12);
                $parts['month'] = $parts['month'] % 12;
            }
            if ($parts['month'] < 1) {
                $parts['year'] += intdiv(-12 + $parts['month'], 12);
                $parts['month'] = 12 + $parts['month'] % 12;
            }
            if (!checkdate($parts['month'], $parts['day'], $parts['year'])) {
                $parts['day'] = idate('t', mktime(12, 12, 12, $parts['month'], 1, $parts['year']));
            }
            $parts['day'] += $relative['day'];
            $parts['hour'] += $relative['hour'];
            $parts['minute'] += $relative['minute'];
            $parts['second'] += $relative['second'];
        }

        // ドキュメントに「引数が不正な場合、 この関数は FALSE を返します」とあるが、 date_parse の結果を与える分には失敗しないはず
        $time = mktime($parts['hour'], $parts['minute'], $parts['second'], $parts['month'], $parts['day'], $parts['year']);
        if ($parts['fraction']) {
            // 1970 以前なら減算、以降なら加算じゃないと帳尻が合わなくなる
            $time += $time >= 0 ? $parts['fraction'] : -$parts['fraction'];
        }

        return $time;
    }
}
if (function_exists("ryunosuke\\dbml\\date_timestamp") && !defined("ryunosuke\\dbml\\date_timestamp")) {
    define("ryunosuke\\dbml\\date_timestamp", "ryunosuke\\dbml\\date_timestamp");
}

if (!isset($excluded_functions["date_convert"]) && (!function_exists("ryunosuke\\dbml\\date_convert") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\date_convert"))->isInternal()))) {
    /**
     * 日時文字列をよしなに別のフォーマットに変換する
     *
     * マイクロ秒にも対応している。
     * かなり適当に和暦にも対応している。
     *
     * Example:
     * ```php
     * // 和暦を Y/m/d H:i:s に変換
     * that(date_convert('Y/m/d H:i:s', '昭和31年12月24日 12時34分56秒'))->isSame('1956/12/24 12:34:56');
     * // 単純に「マイクロ秒が使える date」としても使える
     * $now = 1234567890.123; // テストがしづらいので固定時刻にする
     * that(date_convert('Y/m/d H:i:s.u', $now))->isSame('2009/02/14 08:31:30.123000');
     * ```
     *
     * @param string $format フォーマット
     * @param string|int|float|\DateTime|null $datetimedata 日時データ。省略時は microtime
     * @return string 日時文字列
     */
    function date_convert($format, $datetimedata = null)
    {
        // 省略時は microtime
        if ($datetimedata === null) {
            $timestamp = microtime(true);
        }
        elseif ($datetimedata instanceof \DateTimeInterface) {
            // @fixme DateTime オブジェクトって timestamp を float で得られないの？
            $timestamp = (float) $datetimedata->format('U.u');
        }
        else {
            $timestamp = date_timestamp($datetimedata);
            if ($timestamp === null) {
                throw new \InvalidArgumentException("parse failed '$datetimedata'");
            }
        }

        $replace = function ($string, $char, $replace) {
            $string = preg_replace('/(?<!\\\)' . $char . '/', '${1}' . $replace, $string);
            return preg_replace('/\\\\' . $char . '/', $char, $string);
        };

        if (preg_match('/[JbKk]/', $format)) {
            $era = array_find(JP_ERA, function ($v) use ($timestamp) {
                if ($v['since'] <= $timestamp) {
                    return $v;
                }
            }, false);
            if ($era === false) {
                throw new \InvalidArgumentException("notfound JP_ERA '$datetimedata'");
            }

            $y = idate('Y', $timestamp) - idate('Y', $era['since']) + 1;
            $format = $replace($format, 'J', $era['name']);
            $format = $replace($format, 'b', $era['abbr']);
            $format = $replace($format, 'K', $y === 1 ? '元' : $y);
            $format = $replace($format, 'k', $y);
        }

        $format = $replace($format, 'x', ['日', '月', '火', '水', '木', '金', '土'][idate('w', $timestamp)]);

        if (is_float($timestamp)) {
            // datetime パラメータが UNIX タイムスタンプ (例: 946684800) だったり、タイムゾーンを含んでいたり (例: 2010-01-28T15:00:00+02:00) する場合は、 timezone パラメータや現在のタイムゾーンは無視します
            static $dtz = null;
            $dtz = $dtz ?? new \DateTimeZone(date_default_timezone_get());
            return \DateTime::createFromFormat('U.u', sprintf('%f', $timestamp))->setTimezone($dtz)->format($format);
        }
        return date($format, $timestamp);
    }
}
if (function_exists("ryunosuke\\dbml\\date_convert") && !defined("ryunosuke\\dbml\\date_convert")) {
    define("ryunosuke\\dbml\\date_convert", "ryunosuke\\dbml\\date_convert");
}

if (!isset($excluded_functions["date_fromto"]) && (!function_exists("ryunosuke\\dbml\\date_fromto") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\date_fromto"))->isInternal()))) {
    /**
     * 日時っぽい文字列とフォーマットを与えると取りうる範囲を返す
     *
     * 与えられた日時の最大の切り捨て日時と最小の切り上げ日時の配列を返す。
     * 日付文字列はある程度よしなに補完される（例えば "2014/12" は"2014年12月01日" と解釈されるし "12/24" は "今年12月24日" と解釈される）。
     *
     * Example:
     * ```php
     * that(date_fromto('Y/m/d H:i:s', '2010/11'))->isSame(["2010/11/01 00:00:00", "2010/12/01 00:00:00"]);
     * that(date_fromto('Y/m/d H:i:s', '2010/11/24'))->isSame(["2010/11/24 00:00:00", "2010/11/25 00:00:00"]);
     * that(date_fromto('Y/m/d H:i:s', '2010/11/24 13'))->isSame(["2010/11/24 13:00:00", "2010/11/24 14:00:00"]);
     * that(date_fromto('Y/m/d H:i:s', '2010/11/24 13:24'))->isSame(["2010/11/24 13:24:00", "2010/11/24 13:25:00"]);
     * ```
     *
     * @param string $format フォーマット。 null を与えるとタイムスタンプで返す
     * @param string $datetimestring 日時データ
     * @return array|null [from ～ to] な配列。解釈できない場合は null
     */
    function date_fromto($format, $datetimestring)
    {
        $parsed = date_parse($datetimestring);
        if (true
            && $parsed['year'] === false
            && $parsed['month'] === false
            && $parsed['day'] === false
            && $parsed['hour'] === false
            && $parsed['minute'] === false
            && $parsed['second'] === false) {
            return null;
        }

        [$date, $time] = preg_split('#[T\s　]#u', $datetimestring, -1, PREG_SPLIT_NO_EMPTY) + [0 => '', 1 => ''];
        [$y, $m, $d] = preg_split('#[^\d]+#u', $date, -1, PREG_SPLIT_NO_EMPTY) + [0 => null, 1 => null, 2 => null];
        [$h, $i, $s] = preg_split('#[^\d]+#u', $time, -1, PREG_SPLIT_NO_EMPTY) + [0 => null, 1 => null, 2 => null];

        // "2014/12" と "12/24" の区別はつかないので字数で判断
        if (strlen($y) <= 2) {
            [$y, $m, $d] = [null, $y, $m];
        }
        // 時刻区切りなし
        if (strlen($h) > 2) {
            [$h, $i, $s] = str_split($h, 2) + [0 => null, 1 => null, 2 => null];
        }

        // 文字列表現で妥当性を検証
        $strtime = sprintf('%04d-%02d-%02d %02d:%02d:%02d', $y ?? 1000, $m ?? 1, $d ?? 1, $h ?? 1, $i ?? 1, $s ?? 1);
        $datetime = date_create_from_format('Y-m-d H:i:s', $strtime);
        if (!$datetime || $datetime->format('Y-m-d H:i:s') !== $strtime) {
            return null;
        }

        $y = $y ?? idate('Y');
        $ld = $d ?? idate('t', mktime(0, 0, 0, $m ?? 12, 1, $y));

        $min = mktime($h ?? 0, $i ?? 0, $s ?? 0, $m ?? 1, $d ?? 1, $y);
        $max = mktime($h ?? 23, $i ?? 59, $s ?? 59, $m ?? 12, $d ?? $ld, $y) + 1;
        if ($format === null) {
            return [$min, $max];
        }
        return [date($format, $min), date($format, $max)];
    }
}
if (function_exists("ryunosuke\\dbml\\date_fromto") && !defined("ryunosuke\\dbml\\date_fromto")) {
    define("ryunosuke\\dbml\\date_fromto", "ryunosuke\\dbml\\date_fromto");
}

if (!isset($excluded_functions["file_get_arrays"]) && (!function_exists("ryunosuke\\dbml\\file_get_arrays") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\file_get_arrays"))->isInternal()))) {
    /**
     * 指定ファイルを拡張子別に php の配列として読み込む
     *
     * 形式は拡張子で自動判別する。
     * その際、2重拡張子で hoge.sjis.csv のように指定するとそのファイルのエンコーディングを指定したことになる。
     *
     * Example:
     * ```php
     * // csv ファイルを読み込んで配列で返す
     * file_put_contents($csvfile = sys_get_temp_dir() . '/hoge.csv', 'a,b,c
     * 1,2,3
     * 4,5,6
     * 7,8,9
     * ');
     * that(file_get_arrays($csvfile))->isSame([
     *     ['a' => '1', 'b' => '2', 'c' => '3'],
     *     ['a' => '4', 'b' => '5', 'c' => '6'],
     *     ['a' => '7', 'b' => '8', 'c' => '9'],
     * ]);
     *
     * // sjis の json ファイルを読み込んで配列で返す
     * file_put_contents($jsonfile = sys_get_temp_dir() . '/hoge.sjis.json', '[
     * {"a": 1, "b": 2, "c": 3},
     * {"a": 4, "b": 5, "c": 6},
     * {"a": 7, "b": 8, "c": 9}
     * ]');
     * that(file_get_arrays($jsonfile))->isSame([
     *     ['a' => 1, 'b' => 2, 'c' => 3],
     *     ['a' => 4, 'b' => 5, 'c' => 6],
     *     ['a' => 7, 'b' => 8, 'c' => 9],
     * ]);
     * ```
     *
     * @param string $filename 読み込むファイル名
     * @param array $options 各種オプション
     * @return array レコード配列
     */
    function file_get_arrays($filename, $options = [])
    {
        if (!file_exists($filename)) {
            throw new \InvalidArgumentException("$filename is not exists");
        }

        $internal_encoding = mb_internal_encoding();
        $mb_convert_encoding = function ($encoding, $contents) use ($internal_encoding) {
            if ($encoding !== $internal_encoding) {
                $contents = mb_convert_encoding($contents, $internal_encoding, $encoding);
            }
            return $contents;
        };

        $pathinfo = pathinfo($filename);
        $encoding = pathinfo($pathinfo['filename'], PATHINFO_EXTENSION) ?: $internal_encoding;
        $extension = $pathinfo['extension'] ?? '';

        switch (strtolower($extension)) {
            default:
                throw new \InvalidArgumentException("ext '$extension' is not supported.");
            case 'php':
                return (array) require $filename;
            case 'csv':
                return (array) csv_import($mb_convert_encoding($encoding, file_get_contents($filename)), $options + ['structure' => true]);
            case 'json':
            case 'json5':
                return (array) json_import($mb_convert_encoding($encoding, file_get_contents($filename)), $options);
            case 'jsonl':
            case 'jsonl5':
                return (array) array_map(function ($json) use ($options) { return json_import($json, $options); }, $mb_convert_encoding($encoding, array_filter(file($filename, FILE_IGNORE_NEW_LINES), 'strlen')));
            case 'yml':
            case 'yaml':
                return (array) yaml_parse($mb_convert_encoding($encoding, file_get_contents($filename)), 0, $ndocs, $options);
            case 'xml':
                throw new \DomainException("ext '$extension' is supported in the future.");
            case 'ltsv':
                return (array) array_map(function ($ltsv) use ($options) { return ltsv_import($ltsv, $options); }, $mb_convert_encoding($encoding, array_filter(file($filename, FILE_IGNORE_NEW_LINES), 'strlen')));
        }
    }
}
if (function_exists("ryunosuke\\dbml\\file_get_arrays") && !defined("ryunosuke\\dbml\\file_get_arrays")) {
    define("ryunosuke\\dbml\\file_get_arrays", "ryunosuke\\dbml\\file_get_arrays");
}

if (!isset($excluded_functions["file_set_contents"]) && (!function_exists("ryunosuke\\dbml\\file_set_contents") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\file_set_contents"))->isInternal()))) {
    /**
     * ディレクトリも掘る file_put_contents
     *
     * 書き込みは一時ファイルと rename を使用してアトミックに行われる。
     *
     * Example:
     * ```php
     * file_set_contents(sys_get_temp_dir() . '/not/filename.ext', 'hoge');
     * that(file_get_contents(sys_get_temp_dir() . '/not/filename.ext'))->isSame('hoge');
     * ```
     *
     * @param string $filename 書き込むファイル名
     * @param string $data 書き込む内容
     * @param int $umask ディレクトリを掘る際の umask
     * @return int 書き込まれたバイト数
     */
    function file_set_contents($filename, $data, $umask = 0002)
    {
        if (func_num_args() === 2) {
            $umask = umask();
        }

        $filename = path_normalize($filename);

        if (!is_dir($dirname = dirname($filename))) {
            if (!@mkdir_p($dirname, $umask)) {
                throw new \RuntimeException("failed to mkdir($dirname)");
            }
        }

        $tempnam = tempnam($dirname, 'tmp');
        if (($result = file_put_contents($tempnam, $data)) !== false) {
            if (rename($tempnam, $filename)) {
                @chmod($filename, 0666 & ~$umask);
                return $result;
            }
            unlink($tempnam);
        }
        return false;
    }
}
if (function_exists("ryunosuke\\dbml\\file_set_contents") && !defined("ryunosuke\\dbml\\file_set_contents")) {
    define("ryunosuke\\dbml\\file_set_contents", "ryunosuke\\dbml\\file_set_contents");
}

if (!isset($excluded_functions["mkdir_p"]) && (!function_exists("ryunosuke\\dbml\\mkdir_p") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\mkdir_p"))->isInternal()))) {
    /**
     * ディレクトリを再帰的に掘る
     *
     * 既に存在する場合は何もしない（エラーも出さない）。
     *
     * @param string $dirname ディレクトリ名
     * @param int $umask ディレクトリを掘る際の umask
     * @return bool 作成したら true
     */
    function mkdir_p($dirname, $umask = 0002)
    {
        if (func_num_args() === 1) {
            $umask = umask();
        }

        if (file_exists($dirname)) {
            return false;
        }

        return mkdir($dirname, 0777 & (~$umask), true);
    }
}
if (function_exists("ryunosuke\\dbml\\mkdir_p") && !defined("ryunosuke\\dbml\\mkdir_p")) {
    define("ryunosuke\\dbml\\mkdir_p", "ryunosuke\\dbml\\mkdir_p");
}

if (!isset($excluded_functions["fnmatch_or"]) && (!function_exists("ryunosuke\\dbml\\fnmatch_or") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\fnmatch_or"))->isInternal()))) {
    /**
     * fnmatch の OR 版
     *
     * $patterns のうちどれか一つでもマッチしたら true を返す。
     * $patterns が空だと例外を投げる。
     *
     * Example:
     * ```php
     * // aaa にマッチするので true
     * that(fnmatch_or(['*aaa*', '*bbb*'], 'aaaX'))->isTrue();
     * // どれともマッチしないので false
     * that(fnmatch_or(['*aaa*', '*bbb*'], 'cccX'))->isFalse();
     * ```
     *
     * @param array|string $patterns パターン配列（単一文字列可）
     * @param string $string 調べる文字列
     * @param int $flags FNM_***
     * @return bool どれかにマッチしたら true
     */
    function fnmatch_or($patterns, $string, $flags = 0)
    {
        $patterns = is_iterable($patterns) ? $patterns : [$patterns];
        if (is_empty($patterns)) {
            throw new \InvalidArgumentException('$patterns must be not empty.');
        }

        foreach ($patterns as $pattern) {
            if (fnmatch($pattern, $string, $flags)) {
                return true;
            }
        }
        return false;
    }
}
if (function_exists("ryunosuke\\dbml\\fnmatch_or") && !defined("ryunosuke\\dbml\\fnmatch_or")) {
    define("ryunosuke\\dbml\\fnmatch_or", "ryunosuke\\dbml\\fnmatch_or");
}

if (!isset($excluded_functions["path_normalize"]) && (!function_exists("ryunosuke\\dbml\\path_normalize") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\path_normalize"))->isInternal()))) {
    /**
     * パスを正規化する
     *
     * 具体的には ./ や ../ を取り除いたり連続したディレクトリ区切りをまとめたりする。
     * realpath ではない。のでシンボリックリンクの解決などはしない。その代わりファイルが存在しなくても使用することができる。
     *
     * Example:
     * ```php
     * $DS = DIRECTORY_SEPARATOR;
     * that(path_normalize('/path/to/something'))->isSame("{$DS}path{$DS}to{$DS}something");
     * that(path_normalize('/path/through/../something'))->isSame("{$DS}path{$DS}something");
     * that(path_normalize('./path/current/./through/../something'))->isSame("path{$DS}current{$DS}something");
     * ```
     *
     * @param string $path パス文字列
     * @return string 正規化されたパス
     */
    function path_normalize($path)
    {
        $ds = '/';
        if (DIRECTORY_SEPARATOR === '\\') {
            $ds .= '\\\\';
        }

        $result = [];
        foreach (preg_split("#[$ds]+#u", $path) as $part) {
            if ($part === '.') {
                continue;
            }
            if ($part === '..') {
                if (empty($result)) {
                    throw new \InvalidArgumentException("'$path' is invalid as path string.");
                }
                array_pop($result);
                continue;
            }
            $result[] = $part;
        }
        if (count($result) > 2 && $result[count($result) - 1] === '') {
            array_pop($result);
        }
        return implode(DIRECTORY_SEPARATOR, $result);
    }
}
if (function_exists("ryunosuke\\dbml\\path_normalize") && !defined("ryunosuke\\dbml\\path_normalize")) {
    define("ryunosuke\\dbml\\path_normalize", "ryunosuke\\dbml\\path_normalize");
}

if (!isset($excluded_functions["rm_rf"]) && (!function_exists("ryunosuke\\dbml\\rm_rf") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\rm_rf"))->isInternal()))) {
    /**
     * 中身があっても消せる rmdir
     *
     * Example:
     * ```php
     * mkdir(sys_get_temp_dir() . '/new/make/dir', 0777, true);
     * rm_rf(sys_get_temp_dir() . '/new');
     * that(file_exists(sys_get_temp_dir() . '/new'))->isSame(false);
     * ```
     *
     * @param string $dirname 削除するディレクトリ名。glob パターンが使える
     * @param bool $self 自分自身も含めるか。false を与えると中身だけを消す
     * @return bool 成功した場合に TRUE を、失敗した場合に FALSE を返します
     */
    function rm_rf($dirname, $self = true)
    {
        $main = static function ($dirname, $self) {
            if (!file_exists($dirname)) {
                return false;
            }

            $rdi = new \RecursiveDirectoryIterator($dirname, \FilesystemIterator::SKIP_DOTS);
            $rii = new \RecursiveIteratorIterator($rdi, \RecursiveIteratorIterator::CHILD_FIRST);

            foreach ($rii as $it) {
                if ($it->isDir()) {
                    rmdir($it->getPathname());
                }
                else {
                    unlink($it->getPathname());
                }
            }

            return !$self || rmdir($dirname);
        };

        $result = true;
        $targets = glob($dirname, GLOB_BRACE | GLOB_NOCHECK | ($self ? 0 : GLOB_ONLYDIR));
        foreach ($targets as $target) {
            $result = $main($target, $self) && $result;
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\rm_rf") && !defined("ryunosuke\\dbml\\rm_rf")) {
    define("ryunosuke\\dbml\\rm_rf", "ryunosuke\\dbml\\rm_rf");
}

if (!isset($excluded_functions["memory_path"]) && (!function_exists("ryunosuke\\dbml\\memory_path") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\memory_path"))->isInternal()))) {
    /**
     * ファイルのように扱えるメモリ上のパスを返す
     *
     * 劣化 vfsStream のようなもの。
     * stream wrapper を用いて実装しており、そのプロトコルは初回呼び出し時に1度だけ登録される。
     * プロトコル名は決め打ちだが、 php.ini に "rfunc.memory_stream" というキーで文字列を指定するとそれが使用される。
     *
     * ファイル操作はある程度できるが、ディレクトリ操作は未対応（そこまでしたいなら vfsStream とか /dev/shm とかを使えば良い）。
     *
     * Example:
     * ```php
     * // ファイル名のように読み書きができるパスを返す（一時ファイルを使用するよりかなり高速に動作する）
     * $memory_path = memory_path('filename.txt');
     * // 呼んだだけでは何もしないので存在しない
     * that(file_exists($memory_path))->isSame(false);
     * // file_put_contents が使える
     * that(file_put_contents($memory_path, 'Hello, World'))->isSame(12);
     * // file_get_contents が使える
     * that(file_get_contents($memory_path))->isSame('Hello, World');
     * // 上記の操作で実体が存在している
     * that(file_exists($memory_path))->isSame(true);
     * // unlink が使える
     * that(unlink($memory_path))->isSame(true);
     * // unlink したので存在しない
     * that(file_exists($memory_path))->isSame(false);
     * ```
     *
     * @param string $path パス名（実質的に一意なファイル名）
     * @return string メモリ上のパス
     */
    function memory_path($path)
    {
        static $STREAM_NAME, $registered = false;
        if (!$registered) {
            $STREAM_NAME = $STREAM_NAME ?: get_cfg_var('rfunc.memory_stream') ?: 'MemoryStreamV010000';
            if (in_array($STREAM_NAME, stream_get_wrappers())) {
                throw new \DomainException("$STREAM_NAME is registered already.");
            }

            $registered = true;
            stream_wrapper_register($STREAM_NAME, get_class(new class() {
                private static $entries = [];

                private $entry;
                private $id;
                private $position;
                // compatible: 下記は php7.4 以降では標準でエラーになるようにあったため基本的に不要
                private $readable;
                private $writable;
                private $appendable;

                public $context;

                private static function create()
                {
                    // @todo time 系は一応用意しているだけでほとんど未実装（read/write のたびに更新する？）
                    $now = time();
                    return (object) [
                        'permission' => 0777 & ~umask(),
                        'owner'      => function_exists('posix_getuid') ? posix_getuid() : 0,
                        'group'      => function_exists('posix_getgid') ? posix_getgid() : 0,
                        'atime'      => $now,
                        'mtime'      => $now,
                        'ctime'      => $now,
                        'content'    => '',
                    ];
                }

                private static function stat($id)
                {
                    $that = self::$entries[$id];
                    return [
                        'dev'     => 0,
                        'ino'     => 0,
                        'mode'    => $that->permission,
                        'nlink'   => 0,
                        'uid'     => $that->owner,
                        'gid'     => $that->group,
                        'rdev'    => 0,
                        'size'    => strlen($that->content),
                        'atime'   => $that->atime,
                        'mtime'   => $that->mtime,
                        'ctime'   => $that->ctime,
                        'blksize' => -1,
                        'blocks'  => -1,
                    ];
                }

                public function __call($name, $arguments)
                {
                    // 対応して無くても標準では警告止まりなので例外に変える
                    throw new \DomainException("$name is not supported.");
                }

                /** @noinspection PhpUnusedParameterInspection */
                public function stream_set_option(int $option, int $arg1, int $arg2)
                {
                    return false;
                }

                public function stream_open(string $path, string $mode, int $options, &$opened_path): bool
                {
                    assert(is_int($options));
                    assert(!strlen($opened_path));
                    $this->id = parse_url($path, PHP_URL_HOST);

                    // t フラグはクソなので実装しない（デフォルトで b フラグとする）
                    if (strpos($mode, 'r') !== false) {
                        // 普通の fopen でファイルが存在しないとエラーになるので模倣する
                        if (!isset(self::$entries[$this->id])) {
                            throw new \InvalidArgumentException("'$path' is not exist.");
                        }
                        $this->position = 0;
                        $this->readable = true;
                        $this->writable = strpos($mode, '+') !== false;
                        $this->appendable = false;
                    }
                    elseif (strpos($mode, 'w') !== false) {
                        // ファイルポインタをファイルの先頭に置き、ファイルサイズをゼロにします。
                        // ファイルが存在しない場合には、作成を試みます。
                        self::$entries[$this->id] = self::create();
                        $this->position = 0;
                        $this->readable = strpos($mode, '+') !== false;
                        $this->writable = true;
                        $this->appendable = false;
                    }
                    elseif (strpos($mode, 'a') !== false) {
                        // ファイルポインタをファイルの終端に置きます。
                        // ファイルが存在しない場合には、作成を試みます。
                        if (!isset(self::$entries[$this->id])) {
                            self::$entries[$this->id] = self::create();
                        }
                        $this->position = 0;
                        $this->readable = strpos($mode, '+') !== false;
                        $this->writable = true;
                        $this->appendable = true;
                    }
                    elseif (strpos($mode, 'x') !== false) {
                        // ファイルポインタをファイルの先頭に置きます。
                        // ファイルが既に存在する場合には fopen() は失敗し、 E_WARNING レベルのエラーを発行します。
                        // ファイルが存在しない場合には新規作成を試みます。
                        if (isset(self::$entries[$this->id])) {
                            throw new \InvalidArgumentException("'$path' is exist already.");
                        }
                        self::$entries[$this->id] = self::create();
                        $this->position = 0;
                        $this->readable = strpos($mode, '+') !== false;
                        $this->writable = true;
                        $this->appendable = false;
                    }
                    elseif (strpos($mode, 'c') !== false) {
                        // ファイルが存在しない場合には新規作成を試みます。
                        // ファイルが既に存在する場合でもそれを ('w' のように) 切り詰めたりせず、 また ('x' のように) 関数のコールが失敗することもありません。
                        // ファイルポインタをファイルの先頭に置きます。
                        if (!isset(self::$entries[$this->id])) {
                            self::$entries[$this->id] = self::create();
                        }
                        $this->position = 0;
                        $this->readable = strpos($mode, '+') !== false;
                        $this->writable = true;
                        $this->appendable = false;
                    }

                    $this->entry = self::$entries[$this->id];

                    return true;
                }

                public function stream_close()
                {
                }

                public function stream_lock(int $operation): bool
                {
                    assert(is_int($operation));
                    // メモリアクセスは競合しないので常に true を返す
                    return true;
                }

                public function stream_flush(): bool
                {
                    // バッファしないので常に true を返す
                    return true;
                }

                public function stream_eof(): bool
                {
                    return $this->position >= strlen($this->entry->content);
                }

                public function stream_read(int $count): string
                {
                    assert($this->readable);
                    $result = substr($this->entry->content, $this->position, $count);
                    $this->position += strlen($result);
                    return $result;
                }

                public function stream_write(string $data): int
                {
                    assert($this->writable);
                    $datalen = strlen($data);
                    $posision = $this->position;
                    // このモードは、fseek() では何の効果もありません。書き込みは、常に追記となります。
                    if ($this->appendable) {
                        $posision = strlen($this->entry->content);
                    }
                    // 一般的に、ファイルの終端より先の位置に移動することも許されています。
                    // そこにデータを書き込んだ場合、ファイルの終端からシーク位置までの範囲を読み込むと 値 0 が埋められたバイトを返します。
                    $current = str_pad($this->entry->content, $posision, "\0", STR_PAD_RIGHT);
                    $this->entry->content = substr_replace($current, $data, $posision, $datalen);
                    $this->position += $datalen;
                    return $datalen;
                }

                public function stream_truncate(int $new_size): bool
                {
                    assert($this->writable);
                    $current = substr($this->entry->content, 0, $new_size);
                    $this->entry->content = str_pad($current, $new_size, "\0", STR_PAD_RIGHT);
                    return true;
                }

                public function stream_tell(): int
                {
                    return $this->position;
                }

                public function stream_seek(int $offset, int $whence = SEEK_SET): bool
                {
                    $strlen = strlen($this->entry->content);
                    switch ($whence) {
                        case SEEK_SET:
                            if ($offset < 0) {
                                return false;
                            }
                            $this->position = $offset;
                            break;

                        // stream_tell を定義していると SEEK_CUR が呼ばれない？（計算されて SEEK_SET に移譲されているような気がする）
                        // @codeCoverageIgnoreStart
                        case SEEK_CUR:
                            $this->position += $offset;
                            break;
                        // @codeCoverageIgnoreEnd

                        case SEEK_END:
                            $this->position = $strlen + $offset;
                            break;
                    }
                    // ファイルの終端から数えた位置に移動するには、負の値を offset に渡して whence を SEEK_END に設定しなければなりません。
                    if ($this->position < 0) {
                        $this->position = $strlen + $this->position;
                        if ($this->position < 0) {
                            $this->position = 0;
                            return false;
                        }
                    }
                    return true;
                }

                public function stream_stat()
                {
                    return self::stat($this->id);
                }

                public function stream_metadata($path, $option, $var)
                {
                    $id = parse_url($path, PHP_URL_HOST);
                    switch ($option) {
                        case STREAM_META_TOUCH:
                            if (!isset(self::$entries[$id])) {
                                self::$entries[$id] = self::create();
                            }
                            $mtime = $var[0] ?? time();
                            $atime = $var[1] ?? $mtime;
                            self::$entries[$id]->mtime = $mtime;
                            self::$entries[$id]->atime = $atime;
                            break;

                        case STREAM_META_ACCESS:
                            if (!isset(self::$entries[$id])) {
                                return false;
                            }
                            self::$entries[$id]->permission = $var;
                            self::$entries[$id]->ctime = time();
                            break;

                        /** @noinspection PhpMissingBreakStatementInspection */
                        case STREAM_META_OWNER_NAME:
                            $nam = function_exists('posix_getpwnam') ? posix_getpwnam($var) : [];
                            $var = $nam['uid'] ?? 0;
                        case STREAM_META_OWNER:
                            if (!isset(self::$entries[$id])) {
                                return false;
                            }
                            self::$entries[$id]->owner = $var;
                            self::$entries[$id]->ctime = time();
                            break;

                        /** @noinspection PhpMissingBreakStatementInspection */
                        case STREAM_META_GROUP_NAME:
                            $var = function_exists('posix_getgrnam') ? posix_getgrnam($var)['gid'] : 0;
                        case STREAM_META_GROUP:
                            if (!isset(self::$entries[$id])) {
                                return false;
                            }
                            self::$entries[$id]->group = $var;
                            self::$entries[$id]->ctime = time();
                            break;
                    }
                    // https://qiita.com/hnw/items/3af76d3d7ec2cf52fff8
                    clearstatcache(true, $path);
                    return true;
                }

                public function url_stat(string $path, int $flags)
                {
                    assert(is_int($flags));
                    $id = parse_url($path, PHP_URL_HOST);
                    if (!isset(self::$entries[$id])) {
                        return false;
                    }
                    return self::stat($id);
                }

                public function rename(string $path_from, string $path_to): bool
                {
                    // rename は同じプロトコルじゃないと使えない制約があるのでプロトコルは見ないで OK
                    $id_from = parse_url($path_from, PHP_URL_HOST);
                    if (!isset(self::$entries[$id_from])) {
                        return false;
                    }
                    $id_to = parse_url($path_to, PHP_URL_HOST);
                    self::$entries[$id_to] = self::$entries[$id_from];
                    unset(self::$entries[$id_from]);
                    // https://qiita.com/hnw/items/3af76d3d7ec2cf52fff8
                    clearstatcache(true, $path_from);
                    return true;
                }

                public function unlink(string $path): bool
                {
                    $id = parse_url($path, PHP_URL_HOST);
                    if (!isset(self::$entries[$id])) {
                        return false;
                    }
                    unset(self::$entries[$id]);
                    // もしファイルを作成した場合、 たとえファイルを削除したとしても TRUE を返します。しかし、unlink() はキャッシュを自動的にクリアします。
                    clearstatcache(true, $path);
                    return true;
                }
            }));
        }

        return "$STREAM_NAME://$path";
    }
}
if (function_exists("ryunosuke\\dbml\\memory_path") && !defined("ryunosuke\\dbml\\memory_path")) {
    define("ryunosuke\\dbml\\memory_path", "ryunosuke\\dbml\\memory_path");
}

if (!isset($excluded_functions["delegate"]) && (!function_exists("ryunosuke\\dbml\\delegate") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\delegate"))->isInternal()))) {
    /**
     * 指定 callable を指定クロージャで実行するクロージャを返す
     *
     * ほぼ内部向けで外から呼ぶことはあまり想定していない。
     *
     * @param \Closure $invoker クロージャを実行するためのクロージャ（実処理）
     * @param callable $callable 最終的に実行したいクロージャ
     * @param ?int $arity 引数の数
     * @return callable $callable を実行するクロージャ
     */
    function delegate($invoker, $callable, $arity = null)
    {
        $arity = $arity ?? parameter_length($callable, true, true);

        if (reflect_callable($callable)->isInternal()) {
            static $cache = [];
            $cache[$arity] = $cache[$arity] ?? evaluate('return new class()
            {
                private $invoker, $callable;

                public function spawn($invoker, $callable)
                {
                    $that = clone($this);
                    $that->invoker = $invoker;
                    $that->callable = $callable;
                    return $that;
                }

                public function __invoke(' . implode(',', is_infinite($arity)
                        ? ['...$_']
                        : array_map(function ($v) { return '$_' . $v; }, array_keys(array_fill(1, $arity, null)))
                    ) . ')
                {
                    return ($this->invoker)($this->callable, func_get_args());
                }
            };');
            return $cache[$arity]->spawn($invoker, $callable);
        }

        switch (true) {
            case $arity === 0:
                return function () use ($invoker, $callable) { return $invoker($callable, func_get_args()); };
            case $arity === 1:
                return function ($_1) use ($invoker, $callable) { return $invoker($callable, func_get_args()); };
            case $arity === 2:
                return function ($_1, $_2) use ($invoker, $callable) { return $invoker($callable, func_get_args()); };
            case $arity === 3:
                return function ($_1, $_2, $_3) use ($invoker, $callable) { return $invoker($callable, func_get_args()); };
            case $arity === 4:
                return function ($_1, $_2, $_3, $_4) use ($invoker, $callable) { return $invoker($callable, func_get_args()); };
            case $arity === 5:
                return function ($_1, $_2, $_3, $_4, $_5) use ($invoker, $callable) { return $invoker($callable, func_get_args()); };
            case is_infinite($arity):
                return function (...$_) use ($invoker, $callable) { return $invoker($callable, func_get_args()); };
            default:
                $args = implode(',', array_map(function ($v) { return '$_' . $v; }, array_keys(array_fill(1, $arity, null))));
                $stmt = 'return function (' . $args . ') use ($invoker, $callable) { return $invoker($callable, func_get_args()); };';
                return eval($stmt);
        }
    }
}
if (function_exists("ryunosuke\\dbml\\delegate") && !defined("ryunosuke\\dbml\\delegate")) {
    define("ryunosuke\\dbml\\delegate", "ryunosuke\\dbml\\delegate");
}

if (!isset($excluded_functions["nbind"]) && (!function_exists("ryunosuke\\dbml\\nbind") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\nbind"))->isInternal()))) {
    /**
     * $callable の指定位置に引数を束縛したクロージャを返す
     *
     * Example:
     * ```php
     * $bind = nbind('sprintf', 2, 'X');
     * that($bind('%s%s%s', 'N', 'N'))->isSame('NXN');
     * ```
     *
     * @param callable $callable 対象 callable
     * @param int $n 挿入する引数位置
     * @param mixed ...$variadic 本来の引数（可変引数）
     * @return callable 束縛したクロージャ
     */
    function nbind($callable, $n, ...$variadic)
    {
        return delegate(function ($callable, $args) use ($variadic, $n) {
            return $callable(...array_insert($args, $variadic, $n));
        }, $callable, parameter_length($callable, true, true) - count($variadic));
    }
}
if (function_exists("ryunosuke\\dbml\\nbind") && !defined("ryunosuke\\dbml\\nbind")) {
    define("ryunosuke\\dbml\\nbind", "ryunosuke\\dbml\\nbind");
}

if (!isset($excluded_functions["rbind"]) && (!function_exists("ryunosuke\\dbml\\rbind") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\rbind"))->isInternal()))) {
    /**
     * $callable の最右に引数を束縛した callable を返す
     *
     * Example:
     * ```php
     * $bind = rbind('sprintf', 'X');
     * that($bind('%s%s', 'N'))->isSame('NX');
     * ```
     *
     * @param callable $callable 対象 callable
     * @param mixed ...$variadic 本来の引数（可変引数）
     * @return callable 束縛したクロージャ
     */
    function rbind($callable, ...$variadic)
    {
        return nbind(...array_insert(func_get_args(), null, 1));
    }
}
if (function_exists("ryunosuke\\dbml\\rbind") && !defined("ryunosuke\\dbml\\rbind")) {
    define("ryunosuke\\dbml\\rbind", "ryunosuke\\dbml\\rbind");
}

if (!isset($excluded_functions["reflect_callable"]) && (!function_exists("ryunosuke\\dbml\\reflect_callable") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\reflect_callable"))->isInternal()))) {
    /**
     * callable から ReflectionFunctionAbstract を生成する
     *
     * Example:
     * ```php
     * that(reflect_callable('sprintf'))->isInstanceOf(\ReflectionFunction::class);
     * that(reflect_callable('\Closure::bind'))->isInstanceOf(\ReflectionMethod::class);
     * ```
     *
     * @param callable $callable 対象 callable
     * @return \ReflectionFunction|\ReflectionMethod リフレクションインスタンス
     */
    function reflect_callable($callable)
    {
        // callable チェック兼 $call_name 取得
        if (!is_callable($callable, true, $call_name)) {
            throw new \InvalidArgumentException("'$call_name' is not callable");
        }

        if ($callable instanceof \Closure || strpos($call_name, '::') === false) {
            return new \ReflectionFunction($callable);
        }
        else {
            [$class, $method] = explode('::', $call_name, 2);
            // for タイプ 5: 相対指定による静的クラスメソッドのコール (PHP 5.3.0 以降)
            if (strpos($method, 'parent::') === 0) {
                [, $method] = explode('::', $method);
                return (new \ReflectionClass($class))->getParentClass()->getMethod($method);
            }
            return new \ReflectionMethod($class, $method);
        }
    }
}
if (function_exists("ryunosuke\\dbml\\reflect_callable") && !defined("ryunosuke\\dbml\\reflect_callable")) {
    define("ryunosuke\\dbml\\reflect_callable", "ryunosuke\\dbml\\reflect_callable");
}

if (!isset($excluded_functions["callable_code"]) && (!function_exists("ryunosuke\\dbml\\callable_code") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\callable_code"))->isInternal()))) {
    /**
     * callable のコードブロックを返す
     *
     * 返り値は2値の配列。0番目の要素が定義部、1番目の要素が処理部を表す。
     *
     * Example:
     * ```php
     * list($meta, $body) = callable_code(function(...$args){return true;});
     * that($meta)->isSame('function(...$args)');
     * that($body)->isSame('{return true;}');
     *
     * // ReflectionFunctionAbstract を渡しても動作する
     * list($meta, $body) = callable_code(new \ReflectionFunction(function(...$args){return true;}));
     * that($meta)->isSame('function(...$args)');
     * that($body)->isSame('{return true;}');
     * ```
     *
     * @param callable|\ReflectionFunctionAbstract $callable コードを取得する callable
     * @return array ['定義部分', '{処理コード}']
     */
    function callable_code($callable)
    {
        $ref = $callable instanceof \ReflectionFunctionAbstract ? $callable : reflect_callable($callable);
        $contents = file($ref->getFileName());
        $start = $ref->getStartLine();
        $end = $ref->getEndLine();
        $codeblock = implode('', array_slice($contents, $start - 1, $end - $start + 1));

        $meta = parse_php("<?php $codeblock", [
            'begin' => T_FUNCTION,
            'end'   => '{',
        ]);
        array_pop($meta);

        $body = parse_php("<?php $codeblock", [
            'begin'  => '{',
            'end'    => '}',
            'offset' => last_key($meta),
        ]);

        return [trim(implode('', array_column($meta, 1))), trim(implode('', array_column($body, 1)))];
    }
}
if (function_exists("ryunosuke\\dbml\\callable_code") && !defined("ryunosuke\\dbml\\callable_code")) {
    define("ryunosuke\\dbml\\callable_code", "ryunosuke\\dbml\\callable_code");
}

if (!isset($excluded_functions["call_safely"]) && (!function_exists("ryunosuke\\dbml\\call_safely") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\call_safely"))->isInternal()))) {
    /**
     * エラーを例外に変換するブロックでコールバックを実行する
     *
     * Example:
     * ```php
     * try {
     *     call_safely(function(){return []['dummy'];});
     * }
     * catch (\Exception $ex) {
     *     that($ex->getMessage())->containsAll(['Undefined', 'dummy']);
     * }
     * ```
     *
     * @param callable $callback 実行するコールバック
     * @param mixed ...$variadic $callback に渡される引数（可変引数）
     * @return mixed $callback の返り値
     */
    function call_safely($callback, ...$variadic)
    {
        set_error_handler(function ($errno, $errstr, $errfile, $errline) {
            if (!(error_reporting() & $errno)) {
                return false;
            }
            throw new \ErrorException($errstr, 0, $errno, $errfile, $errline);
        });

        try {
            return $callback(...$variadic);
        }
        finally {
            restore_error_handler();
        }
    }
}
if (function_exists("ryunosuke\\dbml\\call_safely") && !defined("ryunosuke\\dbml\\call_safely")) {
    define("ryunosuke\\dbml\\call_safely", "ryunosuke\\dbml\\call_safely");
}

if (!isset($excluded_functions["is_bindable_closure"]) && (!function_exists("ryunosuke\\dbml\\is_bindable_closure") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\is_bindable_closure"))->isInternal()))) {
    /**
     * $this を bind 可能なクロージャか調べる
     *
     * Example:
     * ```php
     * that(is_bindable_closure(function(){}))->isTrue();
     * that(is_bindable_closure(static function(){}))->isFalse();
     * ```
     *
     * @param \Closure $closure 調べるクロージャ
     * @return bool $this を bind 可能なクロージャなら true
     */
    function is_bindable_closure(\Closure $closure)
    {
        return !!@$closure->bindTo(new \stdClass());
    }
}
if (function_exists("ryunosuke\\dbml\\is_bindable_closure") && !defined("ryunosuke\\dbml\\is_bindable_closure")) {
    define("ryunosuke\\dbml\\is_bindable_closure", "ryunosuke\\dbml\\is_bindable_closure");
}

if (!isset($excluded_functions["parameter_length"]) && (!function_exists("ryunosuke\\dbml\\parameter_length") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\parameter_length"))->isInternal()))) {
    /**
     * callable の引数の数を返す
     *
     * クロージャはキャッシュされない。毎回リフレクションを生成し、引数の数を調べてそれを返す。
     * （クロージャには一意性がないので key-value なキャッシュが適用できない）。
     * ので、ループ内で使ったりすると目に見えてパフォーマンスが低下するので注意。
     *
     * Example:
     * ```php
     * // trim の引数は2つ
     * that(parameter_length('trim'))->isSame(2);
     * // trim の必須引数は1つ
     * that(parameter_length('trim', true))->isSame(1);
     * ```
     *
     * @param callable $callable 対象 callable
     * @param bool $require_only true を渡すと必須パラメータの数を返す
     * @param bool $thought_variadic 可変引数を考慮するか。 true を渡すと可変引数の場合に無限長を返す
     * @return int 引数の数
     */
    function parameter_length($callable, $require_only = false, $thought_variadic = false)
    {
        // クロージャの $call_name には一意性がないのでキャッシュできない（spl_object_hash でもいいが、かなり重複するので完全ではない）
        if ($callable instanceof \Closure) {
            /** @var \ReflectionFunctionAbstract $ref */
            $ref = reflect_callable($callable);
            if ($thought_variadic && $ref->isVariadic()) {
                return INF;
            }
            elseif ($require_only) {
                return $ref->getNumberOfRequiredParameters();
            }
            else {
                return $ref->getNumberOfParameters();
            }
        }

        // $call_name 取得
        is_callable($callable, false, $call_name);

        $cache = cache($call_name, function () use ($callable) {
            /** @var \ReflectionFunctionAbstract $ref */
            $ref = reflect_callable($callable);
            return [
                '00' => $ref->getNumberOfParameters(),
                '01' => $ref->isVariadic() ? INF : $ref->getNumberOfParameters(),
                '10' => $ref->getNumberOfRequiredParameters(),
                '11' => $ref->isVariadic() ? INF : $ref->getNumberOfRequiredParameters(),
            ];
        }, __FUNCTION__);
        return $cache[(int) $require_only . (int) $thought_variadic];
    }
}
if (function_exists("ryunosuke\\dbml\\parameter_length") && !defined("ryunosuke\\dbml\\parameter_length")) {
    define("ryunosuke\\dbml\\parameter_length", "ryunosuke\\dbml\\parameter_length");
}

if (!isset($excluded_functions["func_user_func_array"]) && (!function_exists("ryunosuke\\dbml\\func_user_func_array") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\func_user_func_array"))->isInternal()))) {
    /**
     * パラメータ定義数に応じて呼び出し引数を可変にしてコールする
     *
     * デフォルト引数はカウントされない。必須パラメータの数で呼び出す。
     *
     * $callback に null を与えると例外的に「第1引数を返すクロージャ」を返す。
     *
     * php の標準関数は定義数より多い引数を投げるとエラーを出すのでそれを抑制したい場合に使う。
     *
     * Example:
     * ```php
     * // strlen に2つの引数を渡してもエラーにならない
     * $strlen = func_user_func_array('strlen');
     * that($strlen('abc', null))->isSame(3);
     * ```
     *
     * @param callable $callback 呼び出すクロージャ
     * @return callable 引数ぴったりで呼び出すクロージャ
     */
    function func_user_func_array($callback)
    {
        // null は第1引数を返す特殊仕様
        if ($callback === null) {
            return function ($v) { return $v; };
        }
        // クロージャはユーザ定義しかありえないので調べる必要がない
        if ($callback instanceof \Closure) {
            // と思ったが、\Closure::fromCallable で作成されたクロージャは内部属性が伝播されるようなので除外
            if (reflect_callable($callback)->isUserDefined()) {
                return $callback;
            }
        }

        // 上記以外は「引数ぴったりで削ぎ落としてコールするクロージャ」を返す
        $plength = parameter_length($callback, true, true);
        return delegate(function ($callback, $args) use ($plength) {
            if (is_infinite($plength)) {
                return $callback(...$args);
            }
            return $callback(...array_slice($args, 0, $plength));
        }, $callback, $plength);
    }
}
if (function_exists("ryunosuke\\dbml\\func_user_func_array") && !defined("ryunosuke\\dbml\\func_user_func_array")) {
    define("ryunosuke\\dbml\\func_user_func_array", "ryunosuke\\dbml\\func_user_func_array");
}

if (!isset($excluded_functions["sql_quote"]) && (!function_exists("ryunosuke\\dbml\\sql_quote") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\sql_quote"))->isInternal()))) {
    /**
     * ものすごく雑に値をクオートする
     *
     * 非常に荒くアドホックに実装しているのでこの関数で得られた値で**実際に実行してはならない**。
     * あくまでログ出力やデバッグ用途で視認性を高める目的である。
     *
     * - null は NULL になる
     * - 数字はそのまま数字になる
     * - bool は 0 or 1 になる
     * - それ以外は addcslashes される
     *
     * Example:
     * ```php
     * that(sql_quote(null))->isSame('NULL');
     * that(sql_quote(123))->isSame(123);
     * that(sql_quote(true))->isSame(1);
     * that(sql_quote("hoge"))->isSame("'hoge'");
     * ```
     *
     * @param mixed $value クオートする値
     * @return mixed クオートされた値
     */
    function sql_quote($value)
    {
        if ($value === null) {
            return 'NULL';
        }
        if (is_numeric($value)) {
            return $value;
        }
        if (is_bool($value)) {
            return (int) $value;
        }
        return "'" . addcslashes((string) $value, "\0\e\f\n\r\t\v'\\") . "'";
    }
}
if (function_exists("ryunosuke\\dbml\\sql_quote") && !defined("ryunosuke\\dbml\\sql_quote")) {
    define("ryunosuke\\dbml\\sql_quote", "ryunosuke\\dbml\\sql_quote");
}

if (!isset($excluded_functions["sql_bind"]) && (!function_exists("ryunosuke\\dbml\\sql_bind") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\sql_bind"))->isInternal()))) {
    /**
     * ものすごく雑に SQL に値を埋め込む
     *
     * 非常に荒くアドホックに実装しているのでこの関数で得られた SQL を**実際に実行してはならない**。
     * あくまでログ出力やデバッグ用途で視認性を高める目的である。
     *
     * プレースホルダは ? か :alnum で混在していても良い。
     *
     * Example:
     * ```php
     * that(sql_bind('select ?', 1))->isSame("select 1");
     * that(sql_bind('select :hoge', ['hoge' => 'hoge']))->isSame("select 'hoge'");
     * that(sql_bind('select ?, :hoge', [1, 'hoge' => 'hoge']))->isSame("select 1, 'hoge'");
     * ```
     *
     * @param string $sql 値を埋め込む SQL
     * @param array|mixed $values 埋め込む値
     * @return mixed 値が埋め込まれた SQL
     */
    function sql_bind($sql, $values)
    {
        $embed = [];
        foreach (arrayval($values, false) as $k => $v) {
            if (is_int($k)) {
                $embed['?'][] = sql_quote($v);
            }
            else {
                $embed[":$k"] = sql_quote($v);
            }
        }

        return str_embed($sql, $embed, [
            "'"   => "'",
            '"'   => '"',
            '-- ' => "\n",
            '/*'  => "*/",
        ]);
    }
}
if (function_exists("ryunosuke\\dbml\\sql_bind") && !defined("ryunosuke\\dbml\\sql_bind")) {
    define("ryunosuke\\dbml\\sql_bind", "ryunosuke\\dbml\\sql_bind");
}

if (!isset($excluded_functions["sql_format"]) && (!function_exists("ryunosuke\\dbml\\sql_format") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\sql_format"))->isInternal()))) {
    /**
     * ものすごく雑に SQL を整形する
     *
     * 非常に荒くアドホックに実装しているのでこの関数で得られた SQL を**実際に実行してはならない**。
     * あくまでログ出力やデバッグ用途で視認性を高める目的である。
     *
     * JOIN 句は FROM 句とみなさず、別句として処理する。
     * AND と && は微妙に処理が異なる。 AND は改行されるが && は改行されない（OR と || も同様）。
     *
     * @param string $sql 整形する SQL
     * @param array $options 整形オプション
     * @return string 整形された SQL
     */
    function sql_format($sql, $options = [])
    {
        static $keywords;
        $keywords = $keywords ?? array_flip(KEYWORDS);

        $options += [
            // インデント文字
            'indent'    => "  ",
            // 括弧の展開レベル
            'nestlevel' => 1,
            // キーワードの大文字/小文字可変換（true だと大文字化。false だと小文字化。あるいは 'ucfirst' 等の文字列関数を直接指定する。クロージャでも良い）
            'case'      => null,
            // シンタックス装飾（true だと SAPI に基づいてよしなに。"html", "cli" だと SAPI を明示的に指定。クロージャだと直接コール）
            'highlight' => null,
            // 最大折返し文字数（未実装）
            'wrapsize'  => false,
        ];
        if ($options['case'] === true) {
            $options['case'] = 'strtoupper';
        }
        elseif ($options['case'] === false) {
            $options['case'] = 'strtolower';
        }

        if ($options['highlight'] === true) {
            $options['highlight'] = php_sapi_name() === 'cli' ? 'cli' : 'html';
        }
        if (is_string($options['highlight'])) {
            $rules = [
                'cli'  => [
                    'KEYWORD' => function ($token) { return "\e[1m" . $token . "\e[m"; },
                    'COMMENT' => function ($token) { return "\e[33m" . $token . "\e[m"; },
                    'STRING'  => function ($token) { return "\e[31m" . $token . "\e[m"; },
                    'NUMBER'  => function ($token) { return "\e[36m" . $token . "\e[m"; },
                ],
                'html' => [
                    'KEYWORD' => function ($token) { return "<span style='font-weight:bold;'>" . htmlspecialchars($token) . "</span>"; },
                    'COMMENT' => function ($token) { return "<span style='color:#FF8000;'>" . htmlspecialchars($token) . "</span>"; },
                    'STRING'  => function ($token) { return "<span style='color:#DD0000;'>" . htmlspecialchars($token) . "</span>"; },
                    'NUMBER'  => function ($token) { return "<span style='color:#0000BB;'>" . htmlspecialchars($token) . "</span>"; },
                ],
            ];
            $rule = $rules[$options['highlight']] ?? throws(new \InvalidArgumentException('highlight must be "cli" or "html".'));
            $options['highlight'] = function ($token, $ttype) use ($keywords, $rule) {
                switch (true) {
                    case isset($keywords[strtoupper($token)]):
                        return $rule['KEYWORD']($token);
                    case in_array($ttype, [T_COMMENT, T_DOC_COMMENT]):
                        return $rule['COMMENT']($token);
                    case in_array($ttype, [T_CONSTANT_ENCAPSED_STRING, T_ENCAPSED_AND_WHITESPACE]):
                        return $rule['STRING']($token);
                    case in_array($ttype, [T_LNUMBER, T_DNUMBER]):
                        return $rule['NUMBER']($token);
                }
                return $token;
            };
        }
        $options['syntaxer'] = function ($token, $ttype) use ($options, $keywords) {
            if ($options['case'] && isset($keywords[strtoupper($token)])) {
                $token = $options['case']($token);
            }
            if ($options['highlight']) {
                $token = $options['highlight']($token, $ttype);
            }
            return $token;
        };

        // 構文解析も先読みもない素朴な実装なので、特定文字列をあとから置換するための目印文字列
        $MARK = unique_string($sql, 8);
        $MARK_R = "{$MARK}_R:}";   // \r マーク
        $MARK_N = "{$MARK}_N:}";   // \n マーク
        $MARK_BR = "{$MARK}_BR:}"; // 改行マーク
        $MARK_CS = "{$MARK}_CS:}"; // コメント開始マーク
        $MARK_CE = "{$MARK}_CE:}"; // コメント終了マーク
        $MARK_NT = "{$MARK}_NT:}"; // インデントマーク
        $MARK_SP = "{$MARK}_SP:}"; // スペースマーク
        $MARK_PT = "{$MARK}_PT:}"; // 括弧ネストマーク

        // 字句にバラす（シンタックスが php に似ているので token_get_all で大幅にサボることができる）
        $tokens = [];
        $comment = '';
        foreach (token_get_all("<?php $sql") as $token) {
            // トークンは配列だったり文字列だったりするので -1 トークンとして配列に正規化
            if (is_string($token)) {
                $token = [-1, $token];
            }

            // パースのために無理やり <?php を付けているので無視
            if ($token[0] === T_OPEN_TAG) {
                continue;
            }
            // '--' は php ではデクリメントだが sql ではコメントなので特別扱いする
            elseif ($token[0] === T_DEC) {
                $comment = $token[1];
            }
            // 改行は '--' コメントの終わり
            elseif ($comment && in_array($token[0], [T_WHITESPACE, T_COMMENT], true) && strpos($token[1], "\n") !== false) {
                $tokens[] = [T_COMMENT, $comment . $token[1]];
                $comment = '';
            }
            // コメント中はコメントに格納する
            elseif ($comment) {
                $comment .= $token[1];
            }
            // 上記以外はただのトークンとして格納する
            else {
                // `string` のような文字列は T_ENCAPSED_AND_WHITESPACE として得られる（ただし ` がついていないので付与）
                if ($token[0] === T_ENCAPSED_AND_WHITESPACE) {
                    $tokens[] = [$token[0], "`{$token[1]}`"];
                }
                elseif ($token[0] !== T_WHITESPACE && $token[1] !== '`') {
                    $tokens[] = [$token[0], $token[1]];
                }
            }
        }

        // コメント以外の前後のトークンを返すクロージャ
        $seek = function ($start, $step) use ($tokens) {
            $comments = [];
            for ($n = 1; ; $n++) {
                $index = $start + $n * $step;
                if (!isset($tokens[$index])) {
                    break;
                }
                $token = $tokens[$index];
                if ($token[0] === T_COMMENT || $token[0] === T_DOC_COMMENT) {
                    $comments[] = trim($token[1]);
                }
                else {
                    return [$index, trim($token[1]), $comments];
                }
            }
            return [$start, '', $comments];
        };

        $interpret = function (&$index = -1) use (&$interpret, $MARK_R, $MARK_N, $MARK_BR, $MARK_CS, $MARK_CE, $MARK_NT, $MARK_SP, $MARK_PT, $tokens, $options, $seek) {
            $index++;
            $beginning = true; // クエリの冒頭か
            $context = '';     // SELECT, INSERT などの大分類
            $subcontext = '';  // SET, VALUES などのサブ分類
            $modifier = '';    // RIGHT などのキーワード修飾語
            $firstcol = null;  // SELECT における最初の列か

            $result = [];
            for ($token_length = count($tokens); $index < $token_length; $index++) {
                $ttype = $tokens[$index][0];
                $token = trim($tokens[$index][1]);

                $virttoken = $options['syntaxer']($token, $ttype);
                $uppertoken = strtoupper($token);

                // 最終的なインデントは「改行＋スペース」で行うのでリテラル内に改行があるとそれもインデントされてしまうので置換して逃がす
                $token = strtr($token, [
                    "\r" => $MARK_R,
                    "\n" => $MARK_N,
                ]);

                // SELECT の直後には DISTINCT などのオプションが来ることがあるので特別扱い
                if ($context === 'SELECT' && $firstcol) {
                    if (!in_array($uppertoken, ['DISTINCT', 'DISTINCTROW', 'STRAIGHT_JOIN'], true) && !preg_match('#^SQL_#i', $uppertoken)) {
                        $firstcol = false;
                        $result[] = $MARK_BR;
                    }
                }

                // コメントは特別扱いでただ付け足すだけ
                if ($ttype === T_COMMENT || $ttype === T_DOC_COMMENT) {
                    $result[] = ($beginning ? '' : $MARK_CS) . $virttoken . $MARK_CE . $MARK_BR;
                    continue;
                }
                $beginning = false;

                switch ($uppertoken) {
                    default:
                        _DEFAULT:
                        $prev = $seek($index, -1)[1];
                        $next = $seek($index, +1)[1];

                        // "tablename. columnname" になってしまう
                        // "@ var" になってしまう
                        // ": holder" になってしまう
                        if ($prev !== '.' && $prev !== '@' && $prev !== ':' && $prev !== ';') {
                            $result[] = $MARK_SP;
                        }

                        $result[] = $virttoken;

                        // "tablename .columnname" になってしまう
                        // "columnname ," になってしまう
                        // mysql において関数呼び出し括弧の前に空白は許されない
                        // ただし、関数呼び出しではなく記号の場合はスペースを入れたい（ colname = (SELECT ～) など）
                        if (($next !== '.' && $next !== ',' && $next !== '(') || ($next === '(' && !preg_match('#^[a-z0-9_"\'`]+$#i', $token))) {
                            $result[] = $MARK_SP;
                        }
                        break;
                    case "@":
                    case ":":
                        $result[] = $MARK_SP . $virttoken;
                        break;
                    case ";":
                        $result[] = $MARK_BR . $virttoken . $MARK_BR;
                        break;
                    case ".":
                        $result[] = $virttoken;
                        break;
                    case ",":
                        $result[] = $virttoken . $MARK_BR;
                        break;
                    case "WITH":
                        $result[] = $MARK_BR . $virttoken . $MARK_SP;
                        $subcontext = $uppertoken;
                        break;
                    /** @noinspection PhpMissingBreakStatementInspection */
                    case "BETWEEN":
                        $subcontext = $uppertoken;
                        goto _DEFAULT;
                    case "CREATE":
                    case "ALTER":
                    case "DROP":
                        $result[] = $MARK_SP . $virttoken . $MARK_SP;
                        $context = $uppertoken;
                        break;
                    case "TABLE":
                        // CREATE TABLE tablename は括弧があるので何もしなくて済むが、
                        // ALTER TABLE tablename は括弧がなく ADD などで始まるので特別分岐
                        [$index, $name, $comments] = $seek($index, +1);
                        $result[] = $MARK_SP . $virttoken . $MARK_SP . ($MARK_SP . implode('', $comments) . $MARK_CE) . $name . $MARK_SP;
                        if ($context !== 'CREATE' && $context !== 'DROP') {
                            $result[] = $MARK_BR;
                        }
                        break;
                    /** @noinspection PhpMissingBreakStatementInspection */
                    case "AND":
                        // BETWEEN A AND B と論理演算子の AND が競合するので分岐後にフォールスルー
                        if ($subcontext === 'BETWEEN') {
                            $result[] = $MARK_SP . $virttoken . $MARK_SP;
                            $subcontext = '';
                            break;
                        }
                    case "OR":
                    case "XOR":
                        // WHEN の条件はカッコがない限り改行しない
                        if ($subcontext === 'WHEN') {
                            $result[] = $MARK_SP . $virttoken . $MARK_SP;
                            break;
                        }
                        $result[] = $MARK_SP . $MARK_BR . $MARK_NT . $virttoken . $MARK_SP;
                        break;
                    case "UNION":
                    case "EXCEPT":
                    case "INTERSECT":
                        $result[] = $MARK_BR . $virttoken . $MARK_SP;
                        $result[] = $MARK_BR;
                        break;
                    case "BY":
                    case "ALL":
                        $result[] = $MARK_SP . $virttoken . array_pop($result);
                        break;
                    case "SELECT":
                        if ($context === 'INSERT') {
                            $result[] = $MARK_BR;
                        }
                        $result[] = $virttoken;
                        $context = $uppertoken;
                        $firstcol = true;
                        break;
                    case "LEFT":
                        /** @noinspection PhpMissingBreakStatementInspection */
                    case "RIGHT":
                        // 例えば LEFT や RIGHT は関数呼び出しの場合もあるので分岐後にフォールスルー
                        if ($seek($index, +1)[1] === '(') {
                            goto _DEFAULT;
                        }
                    case "CROSS":
                    case "INNER":
                    case "OUTER":
                        $modifier .= $virttoken . $MARK_SP;
                        break;
                    case "FROM":
                    case "JOIN":
                    case "WHERE":
                    case "HAVING":
                    case "GROUP":
                    case "ORDER":
                    case "LIMIT":
                    case "OFFSET":
                        $result[] = $MARK_BR . $modifier . $virttoken;
                        $result[] = $MARK_BR; // のちの BY のために結合はせず後ろに入れるだけにする
                        $modifier = '';
                        break;
                    case "FOR":
                    case "LOCK":
                        $result[] = $MARK_BR . $virttoken . $MARK_SP;
                        break;
                    case "ON":
                        // ON は ON でも mysql の ON DUPLICATED かもしれない（pgsql の ON CONFLICT も似たようなコンテキスト）
                        $name = $seek($index, +1)[1];
                        if (in_array(strtoupper($name), ['DUPLICATE', 'CONFLICT'], true)) {
                            $result[] = $MARK_BR;
                            $subcontext = '';
                        }
                        else {
                            $result[] = $MARK_SP;
                        }
                        $result[] = $virttoken . $MARK_SP;
                        break;
                    case "SET":
                        $result[] = $MARK_BR . $virttoken . $MARK_BR;
                        $subcontext = $uppertoken;
                        break;
                    case "INSERT":
                    case "REPLACE":
                        $result[] = $virttoken . $MARK_SP;
                        $context = "INSERT"; // 構文的には INSERT と同じ
                        break;
                    case "INTO":
                        $result[] = $virttoken;
                        if ($context === "INSERT") {
                            $result[] = $MARK_BR;
                        }
                        break;
                    case "VALUES":
                        if ($context === "UPDATE") {
                            $result[] = $MARK_SP . $virttoken;
                        }
                        else {
                            $result[] = $MARK_BR . $virttoken . $MARK_BR;
                        }
                        break;
                    case "REFERENCES":
                        $result[] = $MARK_SP . $virttoken . $MARK_SP;
                        $subcontext = $uppertoken;
                        break;
                    case "UPDATE":
                    case "DELETE":
                        $result[] = $virttoken;
                        if ($subcontext !== 'REFERENCES') {
                            $result[] = $MARK_BR;
                            $context = $uppertoken;
                        }
                        break;
                    /** @noinspection PhpMissingBreakStatementInspection */
                    case "WHEN":
                        $subcontext = $uppertoken;
                    case "ELSE":
                        $result[] = $MARK_BR . $MARK_NT . $virttoken . $MARK_SP;
                        break;
                    case "THEN":
                        $subcontext = '';
                        $result[] = $MARK_SP . $virttoken;
                        break;
                    case "CASE":
                        $parts = $interpret($index);
                        $parts = str_replace($MARK_BR, $MARK_BR . $MARK_NT, $parts);
                        $result[] = $MARK_NT . $virttoken . $MARK_SP . $parts;
                        break;
                    case "END":
                        $result[] = $MARK_BR . $virttoken;
                        break 2;
                    case "(":
                        $current = $index;
                        $parts = $MARK_BR . $interpret($index);

                        // コメントを含まない指定ネストレベル以下なら改行とインデントを吹き飛ばす
                        if (strpos($parts, $MARK_CE) === false && substr_count($parts, $MARK_PT) < $options['nestlevel']) {
                            $parts = strtr($parts, [
                                $MARK_BR => "",
                                $MARK_NT => "",
                            ]);
                            $parts = preg_replace("#^($MARK_SP)|($MARK_SP)+$#u", '', $parts);
                        }
                        elseif ($context === 'CREATE') {
                            $parts = $parts . $MARK_BR;
                        }
                        else {
                            $lastnt = $subcontext === 'WITH' ? '' : $MARK_NT;
                            $brnt = $MARK_BR . $MARK_NT;
                            if ($subcontext !== 'WITH' && strtoupper($seek($current, +1)[1]) === 'SELECT') {
                                $brnt .= $MARK_NT;
                            }
                            $parts = preg_replace("#($MARK_BR)+#u", $brnt, $parts) . $MARK_BR . $lastnt;
                            $parts = preg_replace("#$MARK_CS#u", "", $parts);
                        }

                        // IN や数式はネストとみなさない
                        $prev = $seek($current, -1)[1];
                        $suffix = $MARK_PT;
                        if (strtoupper($prev) === 'IN' || !preg_match('#^[a-z0-9_]+$#i', $prev)) {
                            $suffix = '';
                        }
                        if ($subcontext === 'WITH') {
                            $subcontext = '';
                            $suffix .= $MARK_BR;
                        }

                        $result[] = $MARK_NT . "($parts)" . $suffix;
                        break;
                    case ")":
                        break 2;
                }
            }
            return implode('', $result);
        };

        $result = $interpret();
        $result = preg_replaces("#" . implode('|', [
                // 改行文字＋インデント文字をインデントとみなす（改行＋連続スペースもついでに）
                "(?<indent>$MARK_BR(($MARK_NT|$MARK_SP)+))",
                // 行末コメントと単一コメント
                "(?<cs1>$MARK_BR$MARK_CS)",
                "(?<cs2>$MARK_CS)",
                // 連続改行は1つに集約
                "(?<br>$MARK_BR(($MARK_NT|$MARK_SP)*)($MARK_BR)*)",
                // 連続スペースは1つに集約
                "(?<sp>($MARK_SP)+)",
                // 下記はマーカ文字が現れないように単純置換
                "(?<ce>$MARK_CE)",
                "(?<nt>$MARK_NT)",
                "(?<pt>$MARK_PT)",
                "(?<R>$MARK_R)",
                "(?<N>$MARK_N)",
            ]) . "#u", [
            'indent' => function ($str) use ($options, $MARK_NT, $MARK_SP) {
                return "\n" . str_repeat($options['indent'], (substr_count($str, $MARK_NT) + substr_count($str, $MARK_SP)));
            },
            'cs1'    => "\n" . $options['indent'],
            'cs2'    => "",
            'br'     => "\n",
            'sp'     => ' ',
            'ce'     => "",
            'nt'     => "",
            'pt'     => "",
            'R'      => "\r",
            'N'      => "\n",
        ], $result);

        return trim($result);
    }
}
if (function_exists("ryunosuke\\dbml\\sql_format") && !defined("ryunosuke\\dbml\\sql_format")) {
    define("ryunosuke\\dbml\\sql_format", "ryunosuke\\dbml\\sql_format");
}

if (!isset($excluded_functions["concat"]) && (!function_exists("ryunosuke\\dbml\\concat") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\concat"))->isInternal()))) {
    /**
     * strcat の空文字回避版
     *
     * 基本は strcat と同じ。ただし、**引数の内1つでも空文字を含むなら空文字を返す**。
     *
     * 「プレフィックスやサフィックスを付けたいんだけど、空文字の場合はそのままで居て欲しい」という状況はまれによくあるはず。
     * コードで言えば `strlen($string) ? 'prefix-' . $string : '';` のようなもの。
     * 可変引数なので 端的に言えば mysql の CONCAT みたいな動作になる（あっちは NULL だが）。
     *
     * ```php
     * that(concat('prefix-', 'middle', '-suffix'))->isSame('prefix-middle-suffix');
     * that(concat('prefix-', '', '-suffix'))->isSame('');
     * ```
     *
     * @param mixed ...$variadic 結合する文字列（可変引数）
     * @return string 結合した文字列
     */
    function concat(...$variadic)
    {
        $result = '';
        foreach ($variadic as $s) {
            if (strlen($s) === 0) {
                return '';
            }
            $result .= $s;
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\concat") && !defined("ryunosuke\\dbml\\concat")) {
    define("ryunosuke\\dbml\\concat", "ryunosuke\\dbml\\concat");
}

if (!isset($excluded_functions["split_noempty"]) && (!function_exists("ryunosuke\\dbml\\split_noempty") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\split_noempty"))->isInternal()))) {
    /**
     * 空文字を除外する文字列分割
     *
     * - 空文字を任意の区切り文字で分割しても常に空配列
     * - キーは連番で返す（歯抜けがないただの配列）
     *
     * $triming を指定した場合、結果配列にも影響する。
     * つまり「除外は trim したいが結果配列にはしたくない」はできない。
     *
     * Example:
     * ```php
     * that(split_noempty(',', 'a, b, c'))->isSame(['a', 'b', 'c']);
     * that(split_noempty(',', 'a, , , b, c'))->isSame(['a', 'b', 'c']);
     * that(split_noempty(',', 'a, , , b, c', false))->isSame(['a', ' ', ' ', ' b', ' c']);
     * ```
     *
     * @param string $delimiter 区切り文字
     * @param string $string 対象文字
     * @param string|bool $trimchars 指定した文字を trim する。true を指定すると trim する
     * @return array 指定文字で分割して空文字を除いた配列
     */
    function split_noempty($delimiter, $string, $trimchars = true)
    {
        // trim しないなら preg_split(PREG_SPLIT_NO_EMPTY) で十分
        if (strlen($trimchars) === 0) {
            return preg_split('#' . preg_quote($delimiter, '#') . '#u', $string, -1, PREG_SPLIT_NO_EMPTY);
        }

        // trim するなら preg_split だと無駄にややこしくなるのでベタにやる
        $trim = ($trimchars === true) ? 'trim' : rbind('trim', $trimchars);
        $parts = explode($delimiter, $string);
        $parts = array_map($trim, $parts);
        $parts = array_filter($parts, 'strlen');
        $parts = array_values($parts);
        return $parts;
    }
}
if (function_exists("ryunosuke\\dbml\\split_noempty") && !defined("ryunosuke\\dbml\\split_noempty")) {
    define("ryunosuke\\dbml\\split_noempty", "ryunosuke\\dbml\\split_noempty");
}

if (!isset($excluded_functions["quoteexplode"]) && (!function_exists("ryunosuke\\dbml\\quoteexplode") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\quoteexplode"))->isInternal()))) {
    /**
     * エスケープやクオートに対応した explode
     *
     * $enclosures は配列で開始・終了文字が別々に指定できるが、実装上の都合で今のところ1文字ずつのみ。
     *
     * 歴史的な理由により第3引数は $limit でも $enclosures でもどちらでも渡すことができる。
     *
     * Example:
     * ```php
     * // シンプルな例
     * that(quoteexplode(',', 'a,b,c\\,d,"e,f"'))->isSame([
     *     'a', // 普通に分割される
     *     'b', // 普通に分割される
     *     'c\\,d', // \\ でエスケープしているので区切り文字とみなされない
     *     '"e,f"', // "" でクオートされているので区切り文字とみなされない
     * ]);
     *
     * // $enclosures で囲い文字の開始・終了文字を明示できる
     * that(quoteexplode(',', 'a,b,{e,f}', ['{' => '}']))->isSame([
     *     'a', // 普通に分割される
     *     'b', // 普通に分割される
     *     '{e,f}', // { } で囲まれているので区切り文字とみなされない
     * ]);
     *
     * // このように第3引数に $limit 引数を差し込むことができる
     * that(quoteexplode(',', 'a,b,{e,f}', 2, ['{' => '}']))->isSame([
     *     'a',
     *     'b,{e,f}',
     * ]);
     * ```
     *
     * @param string|array $delimiter 分割文字列
     * @param string $string 対象文字列
     * @param ?int $limit 分割数。負数未対応
     * @param array|string $enclosures 囲い文字。 ["start" => "end"] で開始・終了が指定できる
     * @param string $escape エスケープ文字
     * @return array 分割された配列
     */
    function quoteexplode($delimiter, $string, $limit = null, $enclosures = "'\"", $escape = '\\')
    {
        // for compatible 1.3.x
        if (!is_int($limit) && $limit !== null) {
            if (func_num_args() > 3) {
                $escape = $enclosures;
            }
            $enclosures = $limit;
            $limit = PHP_INT_MAX;
        }

        if ($limit === null) {
            $limit = PHP_INT_MAX;
        }
        $limit = max(1, $limit);

        $delimiters = arrayize($delimiter);
        $current = 0;
        $result = [];
        for ($i = 0, $l = strlen($string); $i < $l; $i++) {
            if (count($result) === $limit - 1) {
                break;
            }
            $i = strpos_quoted($string, $delimiters, $i, $enclosures, $escape);
            if ($i === false) {
                break;
            }
            foreach ($delimiters as $delimiter) {
                $delimiterlen = strlen($delimiter);
                if (substr_compare($string, $delimiter, $i, $delimiterlen) === 0) {
                    $result[] = substr($string, $current, $i - $current);
                    $current = $i + $delimiterlen;
                    $i += $delimiterlen - 1;
                    break;
                }
            }
        }
        $result[] = substr($string, $current, $l);
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\quoteexplode") && !defined("ryunosuke\\dbml\\quoteexplode")) {
    define("ryunosuke\\dbml\\quoteexplode", "ryunosuke\\dbml\\quoteexplode");
}

if (!isset($excluded_functions["strpos_array"]) && (!function_exists("ryunosuke\\dbml\\strpos_array") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\strpos_array"))->isInternal()))) {
    /**
     * 複数の文字列で strpos する
     *
     * $needles のそれぞれの位置を配列で返す。
     * ただし、見つからなかった文字は結果に含まれない。
     *
     * Example:
     * ```php
     * // 見つかった位置を返す
     * that(strpos_array('hello world', ['hello', 'world']))->isSame([
     *     0 => 0,
     *     1 => 6,
     * ]);
     * // 見つからない文字は含まれない
     * that(strpos_array('hello world', ['notfound', 'world']))->isSame([
     *     1 => 6,
     * ]);
     * ```
     *
     * @param string $haystack 対象文字列
     * @param iterable $needles 位置を取得したい文字列配列
     * @param int $offset 開始位置
     * @return array $needles それぞれの位置配列
     */
    function strpos_array($haystack, $needles, $offset = 0)
    {
        if ($offset < 0) {
            $offset += strlen($haystack);
        }

        $result = [];
        foreach (arrayval($needles, false) as $key => $needle) {
            $pos = strpos($haystack, $needle, $offset);
            if ($pos !== false) {
                $result[$key] = $pos;
            }
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\strpos_array") && !defined("ryunosuke\\dbml\\strpos_array")) {
    define("ryunosuke\\dbml\\strpos_array", "ryunosuke\\dbml\\strpos_array");
}

if (!isset($excluded_functions["strpos_quoted"]) && (!function_exists("ryunosuke\\dbml\\strpos_quoted") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\strpos_quoted"))->isInternal()))) {
    /**
     * クオートを考慮して strpos する
     *
     * Example:
     * ```php
     * // クオート中は除外される
     * that(strpos_quoted('hello "this" is world', 'is'))->isSame(13);
     * // 開始位置やクオート文字は指定できる（5文字目以降の \* に囲まれていない hoge の位置を返す）
     * that(strpos_quoted('1:hoge, 2:*hoge*, 3:hoge', 'hoge', 5, '*'))->isSame(20);
     * ```
     *
     * @param string $haystack 対象文字列
     * @param string|iterable $needle 位置を取得したい文字列
     * @param int $offset 開始位置
     * @param string|array $enclosure 囲い文字。この文字中にいる $from, $to 文字は走査外になる
     * @param string $escape エスケープ文字。この文字が前にある $from, $to 文字は走査外になる
     * @return false|int $needle の位置
     */
    function strpos_quoted($haystack, $needle, $offset = 0, $enclosure = "'\"", $escape = '\\')
    {
        if (is_string($enclosure) || is_null($enclosure)) {
            if (strlen($enclosure)) {
                $chars = str_split($enclosure);
                $enclosure = array_combine($chars, $chars);
            }
            else {
                $enclosure = [];
            }
        }
        $needles = arrayval($needle, false);

        $strlen = strlen($haystack);

        if ($offset < 0) {
            $offset += $strlen;
        }

        $enclosing = [];
        for ($i = $offset; $i < $strlen; $i++) {
            if ($i !== 0 && $haystack[$i - 1] === $escape) {
                continue;
            }
            foreach ($enclosure as $start => $end) {
                if (substr_compare($haystack, $end, $i, strlen($end)) === 0) {
                    if ($enclosing && $enclosing[count($enclosing) - 1] === $end) {
                        array_pop($enclosing);
                        $i += strlen($end) - 1;
                        continue 2;
                    }
                }
                if (substr_compare($haystack, $start, $i, strlen($start)) === 0) {
                    $enclosing[] = $end;
                    $i += strlen($start) - 1;
                    continue 2;
                }
            }

            if (empty($enclosing)) {
                foreach ($needles as $needle) {
                    if (substr_compare($haystack, $needle, $i, strlen($needle)) === 0) {
                        return $i;
                    }
                }
            }
        }
        return false;
    }
}
if (function_exists("ryunosuke\\dbml\\strpos_quoted") && !defined("ryunosuke\\dbml\\strpos_quoted")) {
    define("ryunosuke\\dbml\\strpos_quoted", "ryunosuke\\dbml\\strpos_quoted");
}

if (!isset($excluded_functions["str_exists"]) && (!function_exists("ryunosuke\\dbml\\str_exists") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\str_exists"))->isInternal()))) {
    /**
     * 指定文字列を含むか返す
     *
     * Example:
     * ```php
     * that(str_exists('abc', 'b'))->isTrue();
     * that(str_exists('abc', 'B', true))->isTrue();
     * that(str_exists('abc', ['b', 'x'], false, false))->isTrue();
     * that(str_exists('abc', ['b', 'x'], false, true))->isFalse();
     * ```
     *
     * @param string $haystack 対象文字列
     * @param string|array $needle 調べる文字列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @param bool $and_flag すべて含む場合に true を返すか
     * @return bool $needle を含むなら true
     */
    function str_exists($haystack, $needle, $case_insensitivity = false, $and_flag = false)
    {
        if (!is_array($needle)) {
            $needle = [$needle];
        }

        // あくまで文字列としての判定に徹する（strpos の第2引数は闇が深い気がする）
        $haystack = (string) $haystack;
        $needle = array_map('strval', $needle);

        foreach ($needle as $str) {
            if ($str === '') {
                continue;
            }
            $pos = $case_insensitivity ? stripos($haystack, $str) : strpos($haystack, $str);
            if ($and_flag && $pos === false) {
                return false;
            }
            if (!$and_flag && $pos !== false) {
                return true;
            }
        }
        return !!$and_flag;
    }
}
if (function_exists("ryunosuke\\dbml\\str_exists") && !defined("ryunosuke\\dbml\\str_exists")) {
    define("ryunosuke\\dbml\\str_exists", "ryunosuke\\dbml\\str_exists");
}

if (!isset($excluded_functions["str_chop"]) && (!function_exists("ryunosuke\\dbml\\str_chop") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\str_chop"))->isInternal()))) {
    /**
     * 先頭・末尾の指定文字列を削ぎ落とす
     *
     * Example:
     * ```php
     * // 文字列からパス文字列と拡張子を削ぎ落とす
     * $PATH = '/path/to/something';
     * that(str_chop("$PATH/hoge.php", "$PATH/", '.php'))->isSame('hoge');
     * ```
     *
     * @param string $string 対象文字列
     * @param ?string $prefix 削ぎ落とす先頭文字列
     * @param ?string $suffix 削ぎ落とす末尾文字列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return string 削ぎ落とした文字列
     */
    function str_chop($string, $prefix = null, $suffix = null, $case_insensitivity = false)
    {
        $pattern = [];
        if (strlen($prefix)) {
            $pattern[] = '(\A' . preg_quote($prefix, '#') . ')';
        }
        if (strlen($suffix)) {
            $pattern[] = '(' . preg_quote($suffix, '#') . '\z)';
        }
        $flag = 'u' . ($case_insensitivity ? 'i' : '');
        return preg_replace('#' . implode('|', $pattern) . '#' . $flag, '', $string);
    }
}
if (function_exists("ryunosuke\\dbml\\str_chop") && !defined("ryunosuke\\dbml\\str_chop")) {
    define("ryunosuke\\dbml\\str_chop", "ryunosuke\\dbml\\str_chop");
}

if (!isset($excluded_functions["str_lchop"]) && (!function_exists("ryunosuke\\dbml\\str_lchop") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\str_lchop"))->isInternal()))) {
    /**
     * 先頭の指定文字列を削ぎ落とす
     *
     * Example:
     * ```php
     * // 文字列からパス文字列を削ぎ落とす
     * $PATH = '/path/to/something';
     * that(str_lchop("$PATH/hoge.php", "$PATH/"))->isSame('hoge.php');
     * ```
     *
     * @param string $string 対象文字列
     * @param string $prefix 削ぎ落とす先頭文字列
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return string 削ぎ落とした文字列
     */
    function str_lchop($string, $prefix, $case_insensitivity = false)
    {
        return str_chop($string, $prefix, null, $case_insensitivity);
    }
}
if (function_exists("ryunosuke\\dbml\\str_lchop") && !defined("ryunosuke\\dbml\\str_lchop")) {
    define("ryunosuke\\dbml\\str_lchop", "ryunosuke\\dbml\\str_lchop");
}

if (!isset($excluded_functions["str_subreplace"]) && (!function_exists("ryunosuke\\dbml\\str_subreplace") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\str_subreplace"))->isInternal()))) {
    /**
     * 指定文字列を置換する
     *
     * $subject 内の $search を $replaces に置換する。
     * str_replace とは「N 番目のみ置換できる」点で異なる。
     * つまり、$search='hoge', $replace=[2 => 'fuga'] とすると「2 番目の 'hoge' が 'fuga' に置換される」という動作になる（0 ベース）。
     *
     * $replace に 非配列を与えた場合は配列化される。
     * つまり `$replaces = 'hoge'` は `$replaces = [0 => 'hoge']` と同じ（最初のマッチを置換する）。
     *
     * $replace に空配列を与えると何もしない。
     * 負数キーは後ろから数える動作となる。
     * また、置換後の文字列は置換対象にはならない。
     *
     * N 番目の検索文字列が見つからない場合は例外を投げる。
     * ただし、文字自体が見つからない場合は投げない。
     *
     * Example:
     * ```php
     * // 1番目（0ベースなので2番目）の x を X に置換
     * that(str_subreplace('xxx', 'x', [1 => 'X']))->isSame('xXx');
     * // 0番目（最前列）の x を Xa に、-1番目（最後尾）の x を Xz に置換
     * that(str_subreplace('!xxx!', 'x', [0 => 'Xa', -1 => 'Xz']))->isSame('!XaxXz!');
     * // 置換結果は置換対象にならない
     * that(str_subreplace('xxx', 'x', [0 => 'xxx', 1 => 'X']))->isSame('xxxXx');
     * ```
     *
     * @param string $subject 対象文字列
     * @param string $search 検索文字列
     * @param array|string $replaces 置換文字列配列（単一指定は配列化される）
     * @param bool $case_insensitivity 大文字小文字を無視するか
     * @return string 置換された文字列
     */
    function str_subreplace($subject, $search, $replaces, $case_insensitivity = false)
    {
        $replaces = is_iterable($replaces) ? $replaces : [$replaces];

        // 空はそのまま返す
        if (is_empty($replaces)) {
            return $subject;
        }

        // 負数対応のために逆数計算（ついでに整数チェック）
        $subcount = $case_insensitivity ? substr_count(strtolower($subject), strtolower($search)) : substr_count($subject, $search);
        if ($subcount === 0) {
            return $subject;
        }
        $mapping = [];
        foreach ($replaces as $n => $replace) {
            $origN = $n;
            if (!is_int($n)) {
                throw new \InvalidArgumentException('$replaces key must be integer.');
            }
            if ($n < 0) {
                $n += $subcount;
            }
            if (!(0 <= $n && $n < $subcount)) {
                throw new \InvalidArgumentException("notfound search string '$search' of {$origN}th.");
            }
            $mapping[$n] = $replace;
        }
        $maxseq = max(array_keys($mapping));
        $offset = 0;
        for ($n = 0; $n <= $maxseq; $n++) {
            $pos = $case_insensitivity ? stripos($subject, $search, $offset) : strpos($subject, $search, $offset);
            if (isset($mapping[$n])) {
                $subject = substr_replace($subject, $mapping[$n], $pos, strlen($search));
                $offset = $pos + strlen($mapping[$n]);
            }
            else {
                $offset = $pos + strlen($search);
            }
        }
        return $subject;
    }
}
if (function_exists("ryunosuke\\dbml\\str_subreplace") && !defined("ryunosuke\\dbml\\str_subreplace")) {
    define("ryunosuke\\dbml\\str_subreplace", "ryunosuke\\dbml\\str_subreplace");
}

if (!isset($excluded_functions["str_embed"]) && (!function_exists("ryunosuke\\dbml\\str_embed") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\str_embed"))->isInternal()))) {
    /**
     * エスケープ付きで文字列を置換する
     *
     * $replacemap で from -> to 文字列を指定する。
     * to は文字列と配列を受け付ける。
     * 文字列の場合は普通に想起される動作で単純な置換となる。
     * 配列の場合は順次置換していく。要素が足りなくなったら例外を投げる。
     *
     * strtr と同様、最も長いキーから置換を行い、置換後の文字列は対象にならない。
     *
     * $enclosure で「特定文字に囲まれている」場合を無視することができる。
     * $escape で「特定文字が前にある」場合を無視することができる。
     *
     * Example:
     * ```php
     * // 最も単純な置換
     * that(str_embed('a, b, c', ['a' => 'A', 'b' => 'B', 'c' => 'C']))->isSame('A, B, C');
     * // 最も長いキーから置換される
     * that(str_embed('abc', ['a' => 'X', 'ab' => 'AB']))->isSame('ABc');
     * // 配列を渡すと「N番目の置換」が実現できる（文字列の場合は再利用される）
     * that(str_embed('a, a, b, b', [
     *     'a' => 'A',          // 全ての a が A になる
     *     'b' => ['B1', 'B2'], // 1番目の b が B1, 2番目の b が B2 になる
     * ]))->isSame('A, A, B1, B2');
     * // 最も重要な性質として "' で囲まれていると対象にならない
     * that(str_embed('a, "a", b, "b", b', [
     *     'a' => 'A',
     *     'b' => ['B1', 'B2'],
     * ]))->isSame('A, "a", B1, "b", B2');
     * ```
     *
     * @param string $string 対象文字列
     * @param array $replacemap 置換文字列
     * @param string|array $enclosure 囲い文字。この文字中にいる $from, $to 文字は走査外になる
     * @param string $escape エスケープ文字。この文字が前にある $from, $to 文字は走査外になる
     * @return string 置換された文字列
     */
    function str_embed($string, $replacemap, $enclosure = "'\"", $escape = '\\')
    {
        assert(is_iterable($replacemap));

        $string = (string) $string;

        // 長いキーから処理するためソートしておく
        $replacemap = arrayval($replacemap, false);
        uksort($replacemap, function ($a, $b) { return strlen($b) - strlen($a); });
        $srcs = array_keys($replacemap);

        $counter = array_fill_keys(array_keys($replacemap), 0);
        for ($i = 0; $i < strlen($string); $i++) {
            $i = strpos_quoted($string, $srcs, $i, $enclosure, $escape);
            if ($i === false) {
                break;
            }

            foreach ($replacemap as $src => $dst) {
                $srclen = strlen($src);
                if ($srclen === 0) {
                    throw new \InvalidArgumentException("src length is 0.");
                }
                if (substr_compare($string, $src, $i, $srclen) === 0) {
                    if (is_array($dst)) {
                        $n = $counter[$src]++;
                        if (!isset($dst[$n])) {
                            throw new \InvalidArgumentException("notfound search string '$src' of {$n}th.");
                        }
                        $dst = $dst[$n];
                    }
                    $string = substr_replace($string, $dst, $i, $srclen);
                    $i += strlen($dst) - 1;
                    break;
                }
            }
        }
        return $string;
    }
}
if (function_exists("ryunosuke\\dbml\\str_embed") && !defined("ryunosuke\\dbml\\str_embed")) {
    define("ryunosuke\\dbml\\str_embed", "ryunosuke\\dbml\\str_embed");
}

if (!isset($excluded_functions["str_between"]) && (!function_exists("ryunosuke\\dbml\\str_between") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\str_between"))->isInternal()))) {
    /**
     * 指定文字で囲まれた文字列を取得する
     *
     * $from, $to で指定した文字間を取得する（$from, $to 自体は結果に含まれない）。
     * ネストしている場合、一番外側の文字間を返す。
     *
     * $enclosure で「特定文字に囲まれている」場合を無視することができる。
     * $escape で「特定文字が前にある」場合を無視することができる。
     *
     * $position を与えた場合、その場所から走査を開始する。
     * さらに結果があった場合、 $position には「次の走査開始位置」が代入される。
     * これを使用すると連続で「次の文字, 次の文字, ...」と言った動作が可能になる。
     *
     * Example:
     * ```php
     * // $position を利用して "first", "second", "third" を得る（"で囲まれた "blank" は返ってこない）。
     * that(str_between('{first} and {second} and "{blank}" and {third}', '{', '}', $n))->isSame('first');
     * that(str_between('{first} and {second} and "{blank}" and {third}', '{', '}', $n))->isSame('second');
     * that(str_between('{first} and {second} and "{blank}" and {third}', '{', '}', $n))->isSame('third');
     * // ネストしている場合は最も外側を返す
     * that(str_between('{nest1{nest2{nest3}}}', '{', '}'))->isSame('nest1{nest2{nest3}}');
     * ```
     *
     * @param string $string 対象文字列
     * @param string $from 開始文字列
     * @param string $to 終了文字列
     * @param int $position 開始位置。渡した場合次の開始位置が設定される
     * @param string $enclosure 囲い文字。この文字中にいる $from, $to 文字は走査外になる
     * @param string $escape エスケープ文字。この文字が前にある $from, $to 文字は走査外になる
     * @return string|bool $from, $to で囲まれた文字。見つからなかった場合は false
     */
    function str_between($string, $from, $to, &$position = 0, $enclosure = '\'"', $escape = '\\')
    {
        $strlen = strlen($string);
        $fromlen = strlen($from);
        $tolen = strlen($to);
        $position = intval($position);
        $nesting = 0;
        $start = null;
        for ($i = $position; $i < $strlen; $i++) {
            $i = strpos_quoted($string, [$from, $to], $i, $enclosure, $escape);
            if ($i === false) {
                break;
            }

            // 開始文字と終了文字が重複している可能性があるので $to からチェックする
            if (substr_compare($string, $to, $i, $tolen) === 0) {
                if (--$nesting === 0) {
                    $position = $i + $tolen;
                    return substr($string, $start, $i - $start);
                }
                // いきなり終了文字が来た場合は無視する
                if ($nesting < 0) {
                    $nesting = 0;
                }
            }
            if (substr_compare($string, $from, $i, $fromlen) === 0) {
                if ($nesting++ === 0) {
                    $start = $i + $fromlen;
                }
            }
        }
        return false;
    }
}
if (function_exists("ryunosuke\\dbml\\str_between") && !defined("ryunosuke\\dbml\\str_between")) {
    define("ryunosuke\\dbml\\str_between", "ryunosuke\\dbml\\str_between");
}

if (!isset($excluded_functions["str_ellipsis"]) && (!function_exists("ryunosuke\\dbml\\str_ellipsis") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\str_ellipsis"))->isInternal()))) {
    /**
     * 文字列を指定幅に丸める
     *
     * mb_strimwidth と機能的には同じだが、省略文字の差し込み位置を $pos で指定できる。
     * $pos は負数が指定できる。負数の場合後ろから数えられる。
     * 省略した場合は真ん中となる。
     *
     * Example:
     * ```php
     * // 8文字に丸める（$pos 省略なので真ん中が省略される）
     * that(str_ellipsis('1234567890', 8, '...'))->isSame('12...890');
     * // 8文字に丸める（$pos=1 なので1文字目から省略される）
     * that(str_ellipsis('1234567890', 8, '...', 1))->isSame('1...7890');
     * // 8文字に丸める（$pos=-1 なので後ろから1文字目から省略される）
     * that(str_ellipsis('1234567890', 8, '...', -1))->isSame('1234...0');
     * ```
     *
     * @param string $string 対象文字列
     * @param int $width 丸める幅
     * @param string $trimmarker 省略文字列
     * @param int|null $pos 省略記号の差し込み位置
     * @return string 丸められた文字列
     */
    function str_ellipsis($string, $width, $trimmarker = '...', $pos = null)
    {
        $string = (string) $string;

        $strlen = mb_strlen($string);
        if ($strlen <= $width) {
            return $string;
        }

        $markerlen = mb_strlen($trimmarker);
        if ($markerlen >= $width) {
            return $trimmarker;
        }

        $length = $width - $markerlen;
        $pos = $pos ?? $length / 2;
        if ($pos < 0) {
            $pos += $length;
        }
        $pos = max(0, min($pos, $length));

        return mb_substr_replace($string, $trimmarker, $pos, $strlen - $length);
    }
}
if (function_exists("ryunosuke\\dbml\\str_ellipsis") && !defined("ryunosuke\\dbml\\str_ellipsis")) {
    define("ryunosuke\\dbml\\str_ellipsis", "ryunosuke\\dbml\\str_ellipsis");
}

if (!isset($excluded_functions["pascal_case"]) && (!function_exists("ryunosuke\\dbml\\pascal_case") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\pascal_case"))->isInternal()))) {
    /**
     * PascalCase に変換する
     *
     * Example:
     * ```php
     * that(pascal_case('this_is_a_pen'))->isSame('ThisIsAPen');
     * ```
     *
     * @param string $string 対象文字列
     * @param string $delimiter デリミタ
     * @return string 変換した文字列
     */
    function pascal_case($string, $delimiter = '_')
    {
        return strtr(ucwords(strtr($string, [$delimiter => ' '])), [' ' => '']);
    }
}
if (function_exists("ryunosuke\\dbml\\pascal_case") && !defined("ryunosuke\\dbml\\pascal_case")) {
    define("ryunosuke\\dbml\\pascal_case", "ryunosuke\\dbml\\pascal_case");
}

if (!isset($excluded_functions["snake_case"]) && (!function_exists("ryunosuke\\dbml\\snake_case") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\snake_case"))->isInternal()))) {
    /**
     * snake_case に変換する
     *
     * Example:
     * ```php
     * that(snake_case('ThisIsAPen'))->isSame('this_is_a_pen');
     * ```
     *
     * @param string $string 対象文字列
     * @param string $delimiter デリミタ
     * @return string 変換した文字列
     */
    function snake_case($string, $delimiter = '_')
    {
        return ltrim(strtolower(preg_replace('/[A-Z]/', $delimiter . '\0', $string)), $delimiter);
    }
}
if (function_exists("ryunosuke\\dbml\\snake_case") && !defined("ryunosuke\\dbml\\snake_case")) {
    define("ryunosuke\\dbml\\snake_case", "ryunosuke\\dbml\\snake_case");
}

if (!isset($excluded_functions["namespace_split"]) && (!function_exists("ryunosuke\\dbml\\namespace_split") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\namespace_split"))->isInternal()))) {
    /**
     * 文字列を名前空間とローカル名に区切ってタプルで返す
     *
     * class_namespace/class_shorten や function_shorten とほぼ同じだが下記の違いがある。
     *
     * - あくまで文字列として処理する
     *     - 例えば class_namespace は get_class されるが、この関数は（いうなれば） strval される
     * - \\ を trim しないし、特別扱いもしない
     *     - `ns\\hoge` と `\\ns\\hoge` で返り値が微妙に異なる
     *     - `ns\\` のような場合は名前空間だけを返す
     *
     * Example:
     * ```php
     * that(namespace_split('ns\\hoge'))->isSame(['ns', 'hoge']);
     * that(namespace_split('hoge'))->isSame(['', 'hoge']);
     * that(namespace_split('ns\\'))->isSame(['ns', '']);
     * that(namespace_split('\\hoge'))->isSame(['', 'hoge']);
     * ```
     *
     * @param string $string 対象文字列
     * @return array [namespace, localname]
     */
    function namespace_split($string)
    {
        $pos = strrpos($string, '\\');
        if ($pos === false) {
            return ['', $string];
        }
        return [substr($string, 0, $pos), substr($string, $pos + 1)];
    }
}
if (function_exists("ryunosuke\\dbml\\namespace_split") && !defined("ryunosuke\\dbml\\namespace_split")) {
    define("ryunosuke\\dbml\\namespace_split", "ryunosuke\\dbml\\namespace_split");
}

if (!isset($excluded_functions["csv_import"]) && (!function_exists("ryunosuke\\dbml\\csv_import") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\csv_import"))->isInternal()))) {
    /**
     * CSV 的文字列を連想配列の配列に変換する
     *
     * 1行目をヘッダ文字列とみなしてそれをキーとした連想配列の配列を返す。
     * ただし、オプションで headers が与えられた場合はそれを使用する。
     * この headers オプションはヘッダフィルタも兼ねる（[n => header] で「n 番目フィールドを header で取り込み」となる）。
     * 入力にヘッダがありかつ headers に連想配列が渡された場合はフィルタ兼読み換えとなる（Example を参照）。
     *
     * structure オプションが渡された場合は query like なヘッダーで配列になる。
     *
     * callback オプションが渡された場合は「あらゆる処理の最後」にコールされる。
     * つまりヘッダの読み換えや文字エンコーディングの変換が行われた後の状態でコールされる。
     * また、 false を返すとその要素はスルーされる。
     *
     * メモリ効率は意識しない（どうせ配列を返すので意識しても無駄）。
     *
     * Example:
     * ```php
     * // シンプルな実行例
     * that(csv_import("
     * a,b,c
     * A1,B1,C1
     * A2,B2,C2
     * A3,B3,C3
     * "))->is([
     *     ['a' => 'A1', 'b' => 'B1', 'c' => 'C1'],
     *     ['a' => 'A2', 'b' => 'B2', 'c' => 'C2'],
     *     ['a' => 'A3', 'b' => 'B3', 'c' => 'C3'],
     * ]);
     *
     * // ヘッダを指定できる
     * that(csv_import("
     * A1,B1,C1
     * A2,B2,C2
     * A3,B3,C3
     * ", [
     *     'headers' => [0 => 'a', 2 => 'c'], // 1がないので1番目のフィールドを読み飛ばしつつ、0, 2 は "a", "c" として取り込む
     * ]))->is([
     *     ['a' => 'A1', 'c' => 'C1'],
     *     ['a' => 'A2', 'c' => 'C2'],
     *     ['a' => 'A3', 'c' => 'C3'],
     * ]);
     *
     * // ヘッダありで連想配列で指定するとキーの読み換えとなる（指定しなければ読み飛ばしも行える）
     * that(csv_import("
     * a,b,c
     * A1,B1,C1
     * A2,B2,C2
     * A3,B3,C3
     * ", [
     *     'headers' => ['a' => 'hoge', 'c' => 'piyo'], // a は hoge, c は piyo で読み込む。 b は指定がないので飛ばされる
     * ]))->is([
     *     ['hoge' => 'A1', 'piyo' => 'C1'],
     *     ['hoge' => 'A2', 'piyo' => 'C2'],
     *     ['hoge' => 'A3', 'piyo' => 'C3'],
     * ]);
     *
     * // structure:true で配列も扱える
     * that(csv_import("
     * scalar,list[],list[],hash[a],hash[b]
     * 123,list11,list12,hash1A,hash1B
     * 456,list21,list22,hash2A,hash2B
     * ", [
     *     'structure' => true,
     * ]))->is([
     *     ['scalar' => '123', 'list' => ['list11', 'list12'], 'hash' => ['a' => 'hash1A', 'b' => 'hash1B']],
     *     ['scalar' => '456', 'list' => ['list21', 'list22'], 'hash' => ['a' => 'hash2A', 'b' => 'hash2B']],
     * ]);
     * ```
     *
     * @param string|resource $csvstring CSV 的文字列。ファイルポインタでも良いが終了後に必ず閉じられる
     * @param array $options オプション配列。fgetcsv の第3引数以降もここで指定する
     * @return array 連想配列の配列
     */
    function csv_import($csvstring, $options = [])
    {
        $options += [
            'delimiter' => ',',
            'enclosure' => '"',
            'escape'    => '\\',
            'encoding'  => mb_internal_encoding(),
            'headers'   => [],
            'headermap' => null,
            'structure' => false,
            'callback'  => null, // map + filter 用コールバック（1行が参照で渡ってくるので書き換えられる&&false を返すと結果から除かれる）
        ];

        // 文字キーを含む場合はヘッダーありの読み換えとなる
        if (is_array($options['headers']) && count(array_filter(array_keys($options['headers']), 'is_string')) > 0) {
            $options['headermap'] = $options['headers'];
            $options['headers'] = null;
        }

        if (is_resource($csvstring)) {
            $fp = $csvstring;
        }
        else {
            $fp = fopen('php://temp', 'r+b');
            fwrite($fp, $csvstring);
            rewind($fp);
        }

        try {
            return call_safely(function ($fp, $delimiter, $enclosure, $escape, $encoding, $headers, $headermap, $structure, $callback) {
                $mb_internal_encoding = mb_internal_encoding();
                $result = [];
                $n = -1;
                while ($row = fgetcsv($fp, 0, $delimiter, $enclosure, $escape)) {
                    if ($row === [null]) {
                        continue;
                    }
                    if ($mb_internal_encoding !== $encoding) {
                        mb_convert_variables($mb_internal_encoding, $encoding, $row);
                    }
                    if (!$headers) {
                        $headers = $row;
                        continue;
                    }

                    $n++;
                    if ($structure) {
                        $query = [];
                        foreach ($headers as $i => $header) {
                            $query[] = $header . "=" . rawurlencode($row[$i]);
                        }
                        parse_str(implode('&', $query), $row);
                        // csv の仕様上、空文字を置かざるを得ないが、数値配列の場合は空にしたいことがある
                        $row = array_map_recursive($row, function ($v) {
                            if (is_array($v) && is_indexarray($v)) {
                                return array_values(array_filter($v, function ($v) {
                                    if (is_array($v)) {
                                        $v = implode('', array_flatten($v));
                                    }
                                    return strlen($v);
                                }));
                            }
                            return $v;
                        }, true, true);
                    }
                    else {
                        $row = array_combine($headers, array_intersect_key($row, $headers));
                    }
                    if ($headermap) {
                        $row = array_pickup($row, $headermap);
                    }
                    if ($callback) {
                        if ($callback($row, $n) === false) {
                            continue;
                        }
                    }
                    $result[] = $row;
                }
                return $result;
            }, $fp, $options['delimiter'], $options['enclosure'], $options['escape'], $options['encoding'], $options['headers'], $options['headermap'], $options['structure'], $options['callback']);
        }
        finally {
            fclose($fp);
        }
    }
}
if (function_exists("ryunosuke\\dbml\\csv_import") && !defined("ryunosuke\\dbml\\csv_import")) {
    define("ryunosuke\\dbml\\csv_import", "ryunosuke\\dbml\\csv_import");
}

if (!isset($excluded_functions["json_import"]) && (!function_exists("ryunosuke\\dbml\\json_import") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\json_import"))->isInternal()))) {
    /**
     * json_decode のプロキシ関数
     *
     * 引数体系とデフォルト値を変更してある。また、エラー時に例外が飛ぶ。
     *
     * JSON_ES5 に null か true を渡すと json5 としてでデコードする（null はまず json_decode で試みる、true は json5 のみ）。
     * その場合拡張オプションとして下記がある。
     *
     * - JSON_INT_AS_STRING: 常に整数を文字列で返す
     * - JSON_FLOAT_AS_STRING: 常に小数を文字列で返す
     *
     * Example:
     * ```php
     * // オプションはこのように [定数 => bool] で渡す。false は指定されていないとみなされる（JSON_MAX_DEPTH 以外）
     * that(json_import('{"a":"A","b":"B"}', [
     *    JSON_OBJECT_AS_ARRAY => true,
     * ]))->is(['a' => 'A', 'b' => 'B']);
     *
     * // json5 が使える
     * that(json_import('{a: "A", b: "B", }'))->is(['a' => 'A', 'b' => 'B']);
     * ```
     *
     * @license MIT https://github.com/colinodell/json5
     * @copyright Copyright (c) 2017-2019 Colin O'Dell colinodell@gmail.com. Based on https://github.com/json5/json5; Copyright (c) 2012-2016 Aseem Kishore, and others.
     *
     * @param string $value JSON 文字列
     * @param array $options JSON_*** をキーにした連想配列。値が false は指定されていないとみなされる
     * @return mixed decode された値
     */
    function json_import($value, $options = [])
    {
        $specials = [
            JSON_OBJECT_AS_ARRAY => true, // 個人的嗜好だが連想配列のほうが扱いやすい
            JSON_MAX_DEPTH       => 512,
            JSON_ES5             => null,
            JSON_INT_AS_STRING   => false,
            JSON_FLOAT_AS_STRING => false,
        ];
        foreach ($specials as $key => $default) {
            $specials[$key] = $options[$key] ?? $default;
            unset($options[$key]);
        }
        $specials[JSON_BIGINT_AS_STRING] = $options[JSON_BIGINT_AS_STRING] ?? false;
        if ($specials[JSON_INT_AS_STRING] || $specials[JSON_FLOAT_AS_STRING]) {
            $specials[JSON_ES5] = true;
        }

        // true でないならまず json_decode で試行（json が来るならその方が遥かに速い）
        if ($specials[JSON_ES5] === false || $specials[JSON_ES5] === null) {
            $option = array_sum(array_keys(array_filter($options)));
            $result = json_decode($value, $specials[JSON_OBJECT_AS_ARRAY], $specials[JSON_MAX_DEPTH], $option);

            // エラーが出なかったらもうその時点で返せば良い
            if (json_last_error() === JSON_ERROR_NONE) {
                return $result;
            }
            // json5 を試行しないモードならこの時点で例外
            if ($specials[JSON_ES5] === false) {
                throw new \ErrorException(json_last_error_msg(), json_last_error());
            }
        }

        // 上記を通り抜けたら json5 で試行
        $json5_decoder = new class() {
            private $json;
            private $associative;
            private $maxDepth;
            private $bigIntToString;
            private $intToString;
            private $floatToString;

            private $currentByte;
            private $lineNumber          = 1;
            private $currentLineStartsAt = 0;
            private $at                  = 0;
            private $depth               = 1;

            public function __invoke($json, $options)
            {
                $this->json = $json;
                $this->associative = !!$options[JSON_OBJECT_AS_ARRAY];
                $this->maxDepth = (int) $options[JSON_MAX_DEPTH];
                $this->bigIntToString = !!$options[JSON_BIGINT_AS_STRING];
                $this->intToString = !!$options[JSON_INT_AS_STRING];
                $this->floatToString = !!$options[JSON_FLOAT_AS_STRING];

                $this->currentByte = $this->json[0] ?? null;

                $result = $this->value();
                $this->white();
                if ($this->currentByte) {
                    throw $this->exception('Syntax error');
                }
                return $result;
            }

            private function next()
            {
                // Get the next character. When there are no more characters, return the empty string.
                if ($this->peek("\n") || $this->peek("\r", "\n")) {
                    $this->lineNumber++;
                    $this->currentLineStartsAt = $this->at + 1;
                }

                return $this->currentByte = $this->json[++$this->at] ?? null;
            }

            private function nextOrFail(...$chars)
            {
                foreach ($chars as $char) {
                    $char = is_int($char) ? chr($char) : $char;
                    if ($char !== $this->currentByte) {
                        throw $this->exception(sprintf('Expected %s instead of %s', $this->renderChar($char), $this->renderChar($this->currentChar())));
                    }
                    $this->next();
                }
                return $this->currentByte;
            }

            private function peek(...$chars)
            {
                foreach ($chars as $i => $char) {
                    $char = is_int($char) ? chr($char) : $char;
                    if ($char !== ($this->json[$this->at + $i] ?? null)) {
                        return false;
                    }
                }
                return true;
            }

            private function match($regex)
            {
                $subject = substr($this->json, $this->at);
                // Only match on the current line
                if ($pos = strpos($subject, "\n")) {
                    $subject = substr($subject, 0, $pos);
                }

                if (!preg_match($regex, $subject, $matches, PREG_OFFSET_CAPTURE)) {
                    return null;
                }

                $this->at += $matches[0][1] + strlen($matches[0][0]);
                $this->currentByte = $this->json[$this->at] ?? null;

                return $matches[0][0];
            }

            private function white()
            {
                while ($this->currentByte !== null) {
                    // Comments always begin with a / character.
                    if ($this->currentByte === '/') {
                        $this->next();

                        if ($this->currentByte === '/') {
                            do {
                                $this->next();
                                if ($this->currentByte === "\n" || $this->currentByte === "\r") {
                                    $this->next();
                                    continue 2;
                                }
                            } while ($this->currentByte !== null);
                        }
                        elseif ($this->currentByte === '*') {
                            do {
                                $this->next();
                                if ($this->peek('*', '/')) {
                                    $this->next();
                                    $this->next();
                                    continue 2;
                                }
                            } while ($this->currentByte !== null);

                            throw $this->exception('Unterminated block comment');
                        }
                        throw $this->exception('Unrecognized comment');
                    }
                    elseif (preg_match('/^[ \t\r\n\v\f\xA0]/', $this->currentByte) === 1) {
                        $this->next();
                    }
                    elseif ($this->peek(0xC2, 0xA0)) {
                        // Non-breaking space in UTF-8
                        $this->next();
                        $this->next();
                    }
                    else {
                        return $this->currentByte;
                    }
                }
            }

            private function value()
            {
                $this->white();

                switch ($this->currentByte) {
                    case '{':
                        return $this->associative ? (array) $this->object() : $this->object();
                    case '[':
                        return $this->array();
                    case '"':
                    case "'":
                        return $this->string();
                    case '-':
                    case '+':
                    case '.':
                        return $this->number();
                    default:
                        return is_numeric($this->currentByte) ? $this->number() : $this->word();
                }
            }

            private function identifier()
            {
                // Be careful when editing this regex, there are a couple Unicode characters in between here -------------vv
                $match = $this->match('/^(?:[\$_\p{L}\p{Nl}]|\\\\u[0-9A-Fa-f]{4})(?:[\$_\p{L}\p{Nl}\p{Mn}\p{Mc}\p{Nd}\p{Pc}‌‍]|\\\\u[0-9A-Fa-f]{4})*/u');

                if ($match === null) {
                    throw $this->exception('Bad identifier as unquoted key');
                }

                // Un-escape escaped Unicode chars
                $unescaped = preg_replace_callback('/(?:\\\\u[0-9A-Fa-f]{4})+/', function ($m) {
                    return json_decode('"' . $m[0] . '"');
                }, $match);

                return $unescaped;
            }

            private function word()
            {
                $consts = [
                    'true'     => true,
                    'false'    => false,
                    'null'     => null,
                    'Infinity' => INF,
                    'NaN'      => NAN,
                ];

                foreach ($consts as $const => $value) {
                    if ($this->currentByte === $const[0]) {
                        $this->nextOrFail(...str_split($const));
                        return $value;
                    }
                }

                throw $this->exception('Unexpected ' . $this->renderChar($this->currentChar()));
            }

            private function number()
            {
                $number = null;
                $sign = '';
                $string = '';
                $base = 10;

                if ($this->currentByte === '-' || $this->currentByte === '+') {
                    $sign = $this->currentByte;
                    $this->next();
                }

                // support for Infinity
                if ($this->currentByte === 'I') {
                    $this->word();

                    return ($sign === '-') ? -INF : INF;
                }

                // support for NaN
                if ($this->currentByte === 'N') {
                    $number = $this->word();

                    // ignore sign as -NaN also is NaN
                    return $number;
                }

                if ($this->currentByte === '0') {
                    $string .= $this->currentByte;
                    $this->next();
                    if ($this->currentByte === 'x' || $this->currentByte === 'X') {
                        $string .= $this->currentByte;
                        $this->next();
                        $base = 16;
                    }
                    elseif (is_numeric($this->currentByte)) {
                        throw $this->exception('Octal literal');
                    }
                }

                switch ($base) {
                    case 10:
                        if ((is_numeric($this->currentByte) || $this->currentByte === '.') && ($match = $this->match('/^\d*\.?\d*/')) !== null) {
                            $string .= $match;
                        }
                        if (($this->currentByte === 'E' || $this->currentByte === 'e') && ($match = $this->match('/^[Ee][-+]?\d*/')) !== null) {
                            $string .= $match;
                        }
                        $number = $string;
                        break;
                    case 16:
                        if (($match = $this->match('/^[A-Fa-f0-9]+/')) !== null) {
                            $string .= $match;
                            $number = hexdec($string);
                            break;
                        }
                        throw $this->exception('Bad hex number');
                }

                if (!is_numeric($number) || !is_finite($number)) {
                    throw $this->exception('Bad number');
                }

                if (false
                    || ($this->intToString && ctype_digit("$number"))
                    || ($this->floatToString && !ctype_digit("$number"))
                    || ($this->bigIntToString && ctype_digit("$number") && is_float(($number + 0)))
                ) {
                    return $sign === '-' ? '-' . $number : $number;
                }

                if ($sign === '-') {
                    $number = -1 * $number;
                }

                // Adding 0 will automatically cast this to an int or float
                return $number + 0;
            }

            private function string()
            {
                $escapees = [
                    "'"  => "'",
                    '"'  => '"',
                    '\\' => '\\',
                    '/'  => '/',
                    "\n" => '',
                    'b'  => chr(8),
                    'f'  => "\f",
                    'n'  => "\n",
                    'r'  => "\r",
                    't'  => "\t",
                ];

                $string = '';

                $delim = $this->currentByte;
                $this->next();
                while ($this->currentByte !== null) {
                    if ($this->currentByte === $delim) {
                        $this->next();

                        return $string;
                    }

                    if ($this->peek('\\', 'u') && $unicodeEscaped = $this->match('/^(?:\\\\u[0-9A-Fa-f]{4})+/')) {
                        $string .= \json_decode('"' . $unicodeEscaped . '"');
                        continue;
                    }
                    if ($this->currentByte === '\\') {
                        $this->next();

                        if ($this->currentByte === "\r") {
                            if ($this->peek("\r", "\n")) {
                                $this->next();
                            }
                        }
                        elseif (($escapee = ($escapees[$this->currentByte] ?? null)) !== null) {
                            $string .= $escapee;
                        }
                        else {
                            break;
                        }
                    }
                    elseif ($this->currentByte === "\n") {
                        // unescaped newlines are invalid; see:
                        // https://github.com/json5/json5/issues/24
                        // @todo this feels special-cased; are there other invalid unescaped chars?
                        break;
                    }
                    else {
                        $string .= $this->currentByte;
                    }

                    $this->next();
                }

                throw $this->exception('Bad string');
            }

            private function array()
            {
                $array = [];

                if (++$this->depth > $this->maxDepth) {
                    throw $this->exception('Maximum stack depth exceeded');
                }

                $this->nextOrFail('[');
                $this->white();
                while ($this->currentByte !== null) {
                    if ($this->currentByte === ']') {
                        $this->next();
                        $this->depth--;
                        return $array; // Potentially empty array
                    }
                    // ES5 allows omitting elements in arrays, e.g. [,] and [,null]. We don't allow this in JSON5.
                    if ($this->currentByte === ',') {
                        throw $this->exception('Missing array element');
                    }

                    $array[] = $this->value();

                    $this->white();
                    // If there's no comma after this value, this needs to be the end of the array.
                    if ($this->currentByte !== ',') {
                        $this->nextOrFail(']');
                        $this->depth--;
                        return $array;
                    }
                    $this->nextOrFail(',');
                    $this->white();
                }

                throw $this->exception('Invalid array');
            }

            private function object()
            {
                $object = new \stdClass;

                if (++$this->depth > $this->maxDepth) {
                    throw $this->exception('Maximum stack depth exceeded');
                }

                $this->nextOrFail('{');
                $this->white();
                while ($this->currentByte !== null) {
                    if ($this->currentByte === '}') {
                        $this->next();
                        $this->depth--;
                        return $object; // Potentially empty object
                    }

                    // Keys can be unquoted. If they are, they need to be valid JS identifiers.
                    if ($this->currentByte === '"' || $this->currentByte === "'") {
                        $key = $this->string();
                    }
                    else {
                        $key = $this->identifier();
                    }

                    $this->white();
                    $this->nextOrFail(':');
                    $object->{$key} = $this->value();
                    $this->white();
                    // If there's no comma after this pair, this needs to be the end of the object.
                    if ($this->currentByte !== ',') {
                        $this->nextOrFail('}');
                        $this->depth--;
                        return $object;
                    }
                    $this->nextOrFail(',');
                    $this->white();
                }

                throw $this->exception('Invalid object');
            }

            private function exception($message)
            {
                // Calculate the column number
                $str = substr($this->json, $this->currentLineStartsAt, $this->at - $this->currentLineStartsAt);
                $column = mb_strlen($str) + 1;

                $message = sprintf('%s at line %d column %d of the JSON5 data', $message, $this->lineNumber, $column);
                return new \ErrorException($message);
            }

            private function currentChar()
            {
                return $this->currentByte === null ? null : mb_substr(substr($this->json, $this->at, 4), 0, 1);
            }

            private function renderChar($char)
            {
                return $char === null ? 'EOF' : "'" . $char . "'";
            }
        };
        return $json5_decoder($value, $specials);
    }
}
if (function_exists("ryunosuke\\dbml\\json_import") && !defined("ryunosuke\\dbml\\json_import")) {
    define("ryunosuke\\dbml\\json_import", "ryunosuke\\dbml\\json_import");
}

if (!isset($excluded_functions["paml_import"]) && (!function_exists("ryunosuke\\dbml\\paml_import") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\paml_import"))->isInternal()))) {
    /**
     * paml 的文字列をパースする
     *
     * paml とは yaml を簡易化したような独自フォーマットを指す（Php Array Markup Language）。
     * ざっくりと下記のような特徴がある。
     *
     * - ほとんど yaml と同じだがフロースタイルのみでキーコロンの後のスペースは不要
     * - yaml のアンカーや複数ドキュメントのようなややこしい仕様はすべて未対応
     * - 配列を前提にしているので、トップレベルの `[]` `{}` は不要
     * - `[]` でいわゆる php の配列、 `{}` で stdClass を表す（オプション指定可能）
     * - bare string で php の定数を表す（クラス定数も完全修飾すれば使用可能）
     *
     * 簡易的な設定の注入に使える（yaml は標準で対応していないし、json や php 配列はクオートの必要やケツカンマ問題がある）。
     * なお、かなり緩くパースしてるので基本的にエラーにはならない。
     *
     * 早見表：
     *
     * - php:  `["n" => null, "f" => false, "i" => 123, "d" => 3.14, "s" => "this is string", "a" => [1, 2, "x" => "X"]]`
     *     - ダブルアローとキーのクオートが冗長
     * - json: `{"n":null, "f":false, "i":123, "d":3.14, "s":"this is string", "a":{"0": 1, "1": 2, "x": "X"}}`
     *     - キーのクオートが冗長だしケツカンマ非許容
     * - yaml: `{n: null, f: false, i: 123, d: 3.14, s: "this is string", a: {0: 1, 1: 2, x: X}}`
     *     - 理想に近いが、コロンの後にスペースが必要だし連想配列が少々難。なにより拡張や外部ライブラリが必要
     * - paml: `n:null, f:false, i:123, d:3.14, s:"this is string", a:[1, 2, x:X]`
     *     - シンプルイズベスト
     *
     * Example:
     * ```php
     * // こういったスカラー型はほとんど yaml と一緒だが、コロンの後のスペースは不要（あってもよい）
     * that(paml_import('n:null, f:false, i:123, d:3.14, s:"this is string"'))->isSame([
     *     'n' => null,
     *     'f' => false,
     *     'i' => 123,
     *     'd' => 3.14,
     *     's' => 'this is string',
     * ]);
     * // 配列が使える（キーは連番なら不要）。ネストも可能
     * that(paml_import('a:[1,2,x:X,3], nest:[a:[b:[c:[X]]]]'))->isSame([
     *     'a'    => [1, 2, 'x' => 'X', 3],
     *     'nest' => [
     *         'a' => [
     *             'b' => [
     *                 'c' => ['X']
     *             ],
     *         ],
     *     ],
     * ]);
     * // bare 文字列で定数が使える。::class も特別扱いで定数とみなす
     * that(paml_import('pv:PHP_VERSION, ao:ArrayObject::STD_PROP_LIST, class:ArrayObject::class'))->isSame([
     *     'pv'    => \PHP_VERSION,
     *     'ao'    => \ArrayObject::STD_PROP_LIST,
     *     'class' => \ArrayObject::class,
     * ]);
     * ```
     *
     * @param string $pamlstring PAML 文字列
     * @param array $options オプション配列
     * @return array php 配列
     */
    function paml_import($pamlstring, $options = [])
    {
        $options += [
            'cache'          => true,
            'trailing-comma' => true,
            'stdclass'       => true,
            'expression'     => false,
            'escapers'       => ['"' => '"', "'" => "'", '[' => ']', '{' => '}'],
        ];

        static $caches = [];
        if ($options['cache']) {
            $key = $pamlstring . json_encode($options);
            return $caches[$key] = $caches[$key] ?? paml_import($pamlstring, ['cache' => false] + $options);
        }

        $resolve = function (&$value) use ($options) {
            $prefix = $value[0] ?? null;
            $suffix = $value[-1] ?? null;

            if (($prefix === '[' && $suffix === ']') || ($prefix === '{' && $suffix === '}')) {
                $values = paml_import(substr($value, 1, -1), $options);
                $value = ($prefix === '[' || !$options['stdclass']) ? (array) $values : (object) $values;
                return true;
            }

            if ($prefix === '"' && $suffix === '"') {
                //$element = stripslashes(substr($element, 1, -1));
                $value = json_decode($value);
                return true;
            }
            if ($prefix === "'" && $suffix === "'") {
                $value = substr($value, 1, -1);
                return true;
            }

            if (ctype_digit(ltrim($value, '+-'))) {
                $value = (int) $value;
                return true;
            }
            if (is_numeric($value)) {
                $value = (double) $value;
                return true;
            }

            if (defined($value)) {
                $value = constant($value);
                return true;
            }
            [$class, $cname] = explode('::', $value, 2) + [1 => null];
            if (class_exists($class) && strtolower($cname) === 'class') {
                $value = ltrim($class, '\\');
                return true;
            }

            if ($options['expression']) {
                $semicolon = ';';
                if ($prefix === '`' && $suffix === '`') {
                    $value = eval("return " . substr($value, 1, -1) . $semicolon);
                    return true;
                }
                try {
                    $evalue = @eval("return $value$semicolon");
                    if ($value !== $evalue) {
                        $value = $evalue;
                        return true;
                    }
                }
                catch (\ParseError $e) {
                }
            }

            return false;
        };

        $values = array_map('trim', quoteexplode(',', $pamlstring, null, $options['escapers']));
        if ($options['trailing-comma'] && end($values) === '') {
            array_pop($values);
        }

        $result = [];
        foreach ($values as $value) {
            $key = null;
            if (!$resolve($value)) {
                $kv = array_map('trim', quoteexplode(':', $value, 2, $options['escapers']));
                if (count($kv) === 2) {
                    [$key, $value] = $kv;
                    $resolve($value);
                }
            }

            array_put($result, $value, $key);
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\paml_import") && !defined("ryunosuke\\dbml\\paml_import")) {
    define("ryunosuke\\dbml\\paml_import", "ryunosuke\\dbml\\paml_import");
}

if (!isset($excluded_functions["ltsv_import"]) && (!function_exists("ryunosuke\\dbml\\ltsv_import") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\ltsv_import"))->isInternal()))) {
    /**
     * LTSV 的文字列を配列に変換する
     *
     * escape オプションで「LTSV 的にまずい文字」がその文字でエスケープされる（具体的には "\n" と "\t"）。
     * デフォルトでは "\\" でエスケープされるので、整合性が崩れることはない。
     *
     * decode オプションで「`` で囲まれた値」が来たときのその関数を通して出力される。
     * デフォルトでは json_decode される。
     *
     * エンコード機能はおまけに過ぎない（大抵の場合はそんな機能は必要ない）。
     * ので、この実装は互換性を維持せず変更される可能性がある。
     *
     * Example:
     * ```php
     * // シンプルな実行例
     * that(ltsv_import("label1:value1	label2:value2"))->is([
     *     "label1" => "value1",
     *     "label2" => "value2",
     * ]);
     *
     * // タブや改行文字のエスケープ
     * that(ltsv_import("label1:val\\tue1	label2:val\\nue2"))->is([
     *     "label1" => "val\tue1",
     *     "label2" => "val\nue2",
     * ]);
     *
     * // 配列のデコード
     * that(ltsv_import("label1:value1	label2:`[1,2,3]`"))->is([
     *     "label1" => "value1",
     *     "label2" => [1, 2, 3],
     * ]);
     * ```
     *
     * @param string $ltsvstring LTSV 的文字列
     * @param array $options オプション配列
     * @return array 配列
     */
    function ltsv_import($ltsvstring, $options = [])
    {
        $options += [
            'escape' => '\\',
            'decode' => function ($v) { return json_decode($v, true); },
        ];
        $escape = $options['escape'];
        $decode = $options['decode'];

        $map = [];
        if (strlen($escape)) {
            $map["{$escape}\\"] = "\\";
            $map["{$escape}t"] = "\t";
            $map["{$escape}n"] = "\n";
        }

        $result = [];
        foreach (explode("\t", $ltsvstring) as $part) {
            [$label, $value] = explode(':', $part, 2);
            $should_decode = substr($value, 0, 1) === '`' && substr($value, -1, 1) === '`';
            if ($map) {
                $label = strtr($label, $map);
                if (!$should_decode) {
                    $value = strtr($value, $map);
                }
            }
            if ($should_decode) {
                $value2 = $decode(substr($value, 1, -1));
                // たまたま ` が付いているだけかも知れないので結果で判定する
                if (!is_stringable($value2)) {
                    $value = $value2;
                }
            }
            $result[$label] = $value;
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\ltsv_import") && !defined("ryunosuke\\dbml\\ltsv_import")) {
    define("ryunosuke\\dbml\\ltsv_import", "ryunosuke\\dbml\\ltsv_import");
}

if (!isset($excluded_functions["unique_string"]) && (!function_exists("ryunosuke\\dbml\\unique_string") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\unique_string"))->isInternal()))) {
    /**
     * 文字列に含まれない文字列を生成する
     *
     * 例えば http のマルチパートバウンダリのような、「競合しない文字列」を生成する。
     * 実装は愚直に文字列を調べて存在しなければそれを返すようになっている。
     * 一応初期値や文字セットは指定可能。
     *
     * $initial に int を与えると初期値としてその文字数分 $charlist から確保する。
     * 例えば生成後の変更が前提で、ある程度の長さを担保したいときに指定すれば最低でもその長さ以上は保証される。
     * $initial に string を与えるとそれがそのまま初期値として使用される。
     * 例えば「ほぼ存在しない文字列」が予測できるのであればそれを指定すれば無駄な処理が省ける。
     *
     * Example:
     * ```php
     * // 単純に呼ぶと生成1,2文字程度の文字列になる
     * that(unique_string('hello, world'))->stringLengthEqualsAny([1, 2]);
     * // 数値を含んでいないので候補文字に数値のみを指定すれば1文字で「存在しない文字列」となる
     * that(unique_string('hello, world', null, range(0, 9)))->stringLengthEquals(1);
     * // int を渡すと最低でもそれ以上は保証される
     * that(unique_string('hello, world', 5))->stringLengthEqualsAny([5, 6]);
     * // string を渡すとそれが初期値となる
     * that(unique_string('hello, world', 'prefix-'))->stringStartsWith('prefix');
     * ```
     *
     * @param string $source 元文字列
     * @param string|int $initial 初期文字列あるいは文字数
     * @param string|array $charlist 使用する文字セット
     * @return string 一意な文字列
     */
    function unique_string($source, $initial = null, $charlist = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')
    {
        assert(is_stringable($initial) || is_int($initial) || is_null($initial));

        if (is_stringable($charlist)) {
            $charlist = preg_split('//', $charlist, -1, PREG_SPLIT_NO_EMPTY);
        }

        $charlength = count($charlist);
        if ($charlength === 0) {
            throw new \InvalidArgumentException('charlist is empty.');
        }

        $result = '';
        if (is_int($initial)) {
            shuffle($charlist);
            $result = implode('', array_slice($charlist, 0, $initial));
        }
        elseif (is_stringable($initial)) {
            $result = $initial;
        }

        $p = 0;
        do {
            $result .= $charlist[mt_rand(0, $charlength - 1)];
        } while (($p = strpos($source, $result, $p)) !== false);

        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\unique_string") && !defined("ryunosuke\\dbml\\unique_string")) {
    define("ryunosuke\\dbml\\unique_string", "ryunosuke\\dbml\\unique_string");
}

if (!isset($excluded_functions["preg_capture"]) && (!function_exists("ryunosuke\\dbml\\preg_capture") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\preg_capture"))->isInternal()))) {
    /**
     * キャプチャを主軸においた preg_match
     *
     * $pattern で $subject をマッチングして $default で埋めて返す。$default はフィルタも兼ねる。
     * 空文字マッチは「マッチしていない」とみなすので注意（$default が使用される）。
     *
     * キャプチャを主軸においているので「マッチしなかった」は検出不可能。
     * $default がそのまま返ってくる。
     *
     * Example:
     * ```php
     * $pattern = '#(\d{4})/(\d{1,2})(/(\d{1,2}))?#';
     * $default = [1 => '2000', 2 => '1', 4 => '1'];
     * // 完全にマッチするのでそれぞれ返ってくる
     * that(preg_capture($pattern, '2014/12/24', $default))->isSame([1 => '2014', 2 => '12', 4 => '24']);
     * // 最後の \d{1,2} はマッチしないのでデフォルト値が使われる
     * that(preg_capture($pattern, '2014/12', $default))->isSame([1 => '2014', 2 => '12', 4 => '1']);
     * // 一切マッチしないので全てデフォルト値が使われる
     * that(preg_capture($pattern, 'hoge', $default))->isSame([1 => '2000', 2 => '1', 4 => '1']);
     * ```
     *
     * @param string $pattern 正規表現
     * @param string $subject 対象文字列
     * @param array $default デフォルト値
     * @return array キャプチャした配列
     */
    function preg_capture($pattern, $subject, $default)
    {
        preg_match($pattern, $subject, $matches);

        foreach ($matches as $n => $match) {
            if (array_key_exists($n, $default) && strlen($match)) {
                $default[$n] = $match;
            }
        }

        return $default;
    }
}
if (function_exists("ryunosuke\\dbml\\preg_capture") && !defined("ryunosuke\\dbml\\preg_capture")) {
    define("ryunosuke\\dbml\\preg_capture", "ryunosuke\\dbml\\preg_capture");
}

if (!isset($excluded_functions["preg_splice"]) && (!function_exists("ryunosuke\\dbml\\preg_splice") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\preg_splice"))->isInternal()))) {
    /**
     * キャプチャも行える preg_replace
     *
     * 「置換を行いつつ、キャプチャ文字列が欲しい」状況はまれによくあるはず。
     *
     * $replacement に callable を渡すと preg_replace_callback がコールされる。
     * callable とはいっても単純文字列 callble （"strtoupper" など）は callable とはみなされない。
     * 配列形式の callable や クロージャのみ preg_replace_callback になる。
     *
     * Example:
     * ```php
     * // 数字を除去しつつその除去された数字を得る
     * that(preg_splice('#\\d+#', '', 'abc123', $m))->isSame('abc');
     * that($m)->isSame(['123']);
     *
     * // callable だと preg_replace_callback が呼ばれる
     * that(preg_splice('#[a-z]+#', function($m){return strtoupper($m[0]);}, 'abc123', $m))->isSame('ABC123');
     * that($m)->isSame(['abc']);
     *
     * // ただし、 文字列 callable は文字列として扱う
     * that(preg_splice('#[a-z]+#', 'strtoupper', 'abc123', $m))->isSame('strtoupper123');
     * that($m)->isSame(['abc']);
     * ```
     *
     * @param string $pattern 正規表現
     * @param string|callable $replacement 置換文字列
     * @param string $subject 対象文字列
     * @param array $matches キャプチャ配列が格納される
     * @return string 置換された文字列
     */
    function preg_splice($pattern, $replacement, $subject, &$matches = [])
    {
        if (preg_match($pattern, $subject, $matches)) {
            if (!is_string($replacement) && is_callable($replacement)) {
                $subject = preg_replace_callback($pattern, $replacement, $subject);
            }
            else {
                $subject = preg_replace($pattern, $replacement, $subject);
            }
        }
        return $subject;
    }
}
if (function_exists("ryunosuke\\dbml\\preg_splice") && !defined("ryunosuke\\dbml\\preg_splice")) {
    define("ryunosuke\\dbml\\preg_splice", "ryunosuke\\dbml\\preg_splice");
}

if (!isset($excluded_functions["preg_replaces"]) && (!function_exists("ryunosuke\\dbml\\preg_replaces") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\preg_replaces"))->isInternal()))) {
    /**
     * パターン番号を指定して preg_replace する
     *
     * パターン番号を指定してそれのみを置換する。
     * 名前付きキャプチャを使用している場合はキーに文字列も使える。
     * 値にクロージャを渡した場合はコールバックされて置換される。
     *
     * $replacements に単一文字列を渡した場合、 `[1 => $replacements]` と等しくなる（第1キャプチャを置換）。
     *
     * Example:
     * ```php
     * // a と z に囲まれた数字を XXX に置換する
     * that(preg_replaces('#a(\d+)z#', [1 => 'XXX'], 'a123z'))->isSame('aXXXz');
     * // 名前付きキャプチャも指定できる
     * that(preg_replaces('#a(?<digit>\d+)z#', ['digit' => 'XXX'], 'a123z'))->isSame('aXXXz');
     * // クロージャを渡すと元文字列を引数としてコールバックされる
     * that(preg_replaces('#a(?<digit>\d+)z#', ['digit' => function($src){return $src * 2;}], 'a123z'))->isSame('a246z');
     * // 複合的なサンプル（a タグの href と target 属性を書き換える）
     * that(preg_replaces('#<a\s+href="(?<href>.*)"\s+target="(?<target>.*)">#', [
     *     'href'   => function($href){return strtoupper($href);},
     *     'target' => function($target){return strtoupper($target);},
     * ], '<a href="hoge" target="fuga">inner text</a>'))->isSame('<a href="HOGE" target="FUGA">inner text</a>');
     * ```
     *
     * @param string $pattern 正規表現
     * @param array|string $replacements 置換文字列
     * @param string $subject 対象文字列
     * @param int $limit 置換回数
     * @param null $count 置換回数格納変数
     * @return string 置換された文字列
     */
    function preg_replaces($pattern, $replacements, $subject, $limit = -1, &$count = null)
    {
        $offset = 0;
        $count = 0;
        if (!is_arrayable($replacements)) {
            $replacements = [1 => $replacements];
        }

        preg_match_all($pattern, $subject, $matches, PREG_OFFSET_CAPTURE | PREG_SET_ORDER);
        foreach ($matches as $match) {
            if ($limit-- === 0) {
                break;
            }
            $count++;

            foreach ($match as $index => $m) {
                if ($m[1] >= 0 && $index !== 0 && isset($replacements[$index])) {
                    $src = $m[0];
                    $dst = $replacements[$index];
                    if ($dst instanceof \Closure) {
                        $dst = $dst($src);
                    }

                    $srclen = strlen($src);
                    $dstlen = strlen($dst);

                    $subject = substr_replace($subject, $dst, $offset + $m[1], $srclen);
                    $offset += $dstlen - $srclen;
                }
            }
        }
        return $subject;
    }
}
if (function_exists("ryunosuke\\dbml\\preg_replaces") && !defined("ryunosuke\\dbml\\preg_replaces")) {
    define("ryunosuke\\dbml\\preg_replaces", "ryunosuke\\dbml\\preg_replaces");
}

if (!isset($excluded_functions["mb_substr_replace"]) && (!function_exists("ryunosuke\\dbml\\mb_substr_replace") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\mb_substr_replace"))->isInternal()))) {
    /**
     * マルチバイト対応 substr_replace
     *
     * 本家は配列を与えたりできるが、ややこしいし使う気がしないので未対応。
     *
     * Example:
     * ```php
     * // 2文字目から5文字を「あいうえお」に置換する
     * that(mb_substr_replace('０１２３４５６７８９', 'あいうえお', 2, 5))->isSame('０１あいうえお７８９');
     * ```
     *
     * @param string $string 対象文字列
     * @param string $replacement 置換文字列
     * @param int $start 開始位置
     * @param ?int $length 置換長
     * @return string 置換した文字列
     */
    function mb_substr_replace($string, $replacement, $start, $length = null)
    {
        $string = (string) $string;

        $strlen = mb_strlen($string);
        if ($start < 0) {
            $start += $strlen;
        }
        if ($length === null) {
            $length = $strlen;
        }
        if ($length < 0) {
            $length += $strlen - $start;
        }

        return mb_substr($string, 0, $start) . $replacement . mb_substr($string, $start + $length);
    }
}
if (function_exists("ryunosuke\\dbml\\mb_substr_replace") && !defined("ryunosuke\\dbml\\mb_substr_replace")) {
    define("ryunosuke\\dbml\\mb_substr_replace", "ryunosuke\\dbml\\mb_substr_replace");
}

if (!isset($excluded_functions["evaluate"]) && (!function_exists("ryunosuke\\dbml\\evaluate") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\evaluate"))->isInternal()))) {
    /**
     * eval のプロキシ関数
     *
     * 一度ファイルに吐いてから require した方が opcache が効くので抜群に速い。
     * また、素の eval は ParseError が起こったときの表示がわかりにくすぎるので少し見やすくしてある。
     *
     * 関数化してる以上 eval におけるコンテキストの引き継ぎはできない。
     * ただし、引数で変数配列を渡せるようにしてあるので get_defined_vars を併用すれば基本的には同じ（$this はどうしようもない）。
     *
     * 短いステートメントだと opcode が少ないのでファイルを経由せず直接 eval したほうが速いことに留意。
     * 一応引数で指定できるようにはしてある。
     *
     * Example:
     * ```php
     * $a = 1;
     * $b = 2;
     * $phpcode = ';
     * $c = $a + $b;
     * return $c * 3;
     * ';
     * that(evaluate($phpcode, get_defined_vars()))->isSame(9);
     * ```
     *
     * @param string $phpcode 実行する php コード
     * @param array $contextvars コンテキスト変数配列
     * @param int $cachesize キャッシュするサイズ
     * @return mixed eval の return 値
     */
    function evaluate($phpcode, $contextvars = [], $cachesize = 256)
    {
        $cachefile = null;
        if ($cachesize && strlen($phpcode) >= $cachesize) {
            $cachefile = cachedir() . '/' . rawurlencode(__FUNCTION__) . '-' . sha1($phpcode) . '.php';
            if (!file_exists($cachefile)) {
                file_put_contents($cachefile, "<?php $phpcode", LOCK_EX);
            }
        }

        try {
            if ($cachefile) {
                /** @noinspection PhpMethodParametersCountMismatchInspection */
                return (static function () {
                    extract(func_get_arg(1));
                    return require func_get_arg(0);
                })($cachefile, $contextvars);
            }
            else {
                /** @noinspection PhpMethodParametersCountMismatchInspection */
                return (static function () {
                    extract(func_get_arg(1));
                    return eval(func_get_arg(0));
                })($phpcode, $contextvars);
            }
        }
        catch (\ParseError $ex) {
            $errline = $ex->getLine();
            $errline_1 = $errline - 1;
            $codes = preg_split('#\\R#u', $phpcode);
            $codes[$errline_1] = '>>> ' . $codes[$errline_1];

            $N = 5; // 前後の行数
            $message = $ex->getMessage();
            $message .= "\n" . implode("\n", array_slice($codes, max(0, $errline_1 - $N), $N * 2 + 1));
            if ($cachefile) {
                $message .= "\n in " . realpath($cachefile) . " on line " . $errline . "\n";
            }
            throw new \ParseError($message, $ex->getCode(), $ex);
        }
    }
}
if (function_exists("ryunosuke\\dbml\\evaluate") && !defined("ryunosuke\\dbml\\evaluate")) {
    define("ryunosuke\\dbml\\evaluate", "ryunosuke\\dbml\\evaluate");
}

if (!isset($excluded_functions["parse_php"]) && (!function_exists("ryunosuke\\dbml\\parse_php") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\parse_php"))->isInternal()))) {
    /**
     * php のコード断片をパースする
     *
     * 結果配列は token_get_all したものだが、「字句の場合に文字列で返す」仕様は適用されずすべて配列で返す。
     * つまり必ず `[TOKENID, TOKEN, LINE, POS]` で返す。
     *
     * @todo 現在の仕様では php タグが自動で付与されるが、標準と異なり直感的ではないのでその仕様は除去する
     * @todo そもそも何がしたいのかよくわからない関数になってきたので動作の洗い出しが必要
     *
     * Example:
     * ```php
     * $phpcode = 'namespace Hogera;
     * class Example
     * {
     *     // something
     * }';
     *
     * // namespace ～ ; を取得
     * $part = parse_php($phpcode, [
     *     'begin' => T_NAMESPACE,
     *     'end'   => ';',
     * ]);
     * that(implode('', array_column($part, 1)))->isSame('namespace Hogera;');
     *
     * // class ～ { を取得
     * $part = parse_php($phpcode, [
     *     'begin' => T_CLASS,
     *     'end'   => '{',
     * ]);
     * that(implode('', array_column($part, 1)))->isSame("class Example\n{");
     * ```
     *
     * @param string $phpcode パースする php コード
     * @param array|int $option パースオプション
     * @return array トークン配列
     */
    function parse_php($phpcode, $option = [])
    {
        if (is_int($option)) {
            $option = ['flags' => $option];
        }

        $default = [
            'phptag'         => true, // 初めに php タグを付けるか
            'short_open_tag' => null, // ショートオープンタグを扱うか（null だと余計なことはせず ini に従う）
            'line'           => [],   // 行の範囲（以上以下）
            'position'       => [],   // 文字位置の範囲（以上以下）
            'begin'          => [],   // 開始トークン
            'end'            => [],   // 終了トークン
            'offset'         => 0,    // 開始トークン位置
            'flags'          => 0,    // token_get_all の $flags. TOKEN_PARSE を与えると ParseError が出ることがあるのでデフォルト 0
            'cache'          => true, // キャッシュするか否か
            'nest_token'     => [
                ')' => '(',
                '}' => '{',
                ']' => '[',
            ],
        ];
        $option += $default;

        $cachekey = var_hash($phpcode) . $option['flags'] . '-' . $option['phptag'] . '-' . var_export($option['short_open_tag'], true);
        static $cache = [];
        if (!($option['cache'] && isset($cache[$cachekey]))) {
            $phptag = $option['phptag'] ? '<?php ' : '';
            $phpcode = $phptag . $phpcode;
            $position = -strlen($phptag);

            $tokens = [];
            $tmp = token_get_all($phpcode, $option['flags']);
            for ($i = 0; $i < count($tmp); $i++) {
                $token = $tmp[$i];

                // token_get_all の結果は微妙に扱いづらいので少し調整する（string/array だったり、名前変換の必要があったり）
                if (!is_array($token)) {
                    $last = $tokens[count($tokens) - 1] ?? [null, 1, 0];
                    $token = [ord($token), $token, $last[2] + preg_match_all('/(?:\r\n|\r|\n)/', $last[1])];
                }

                // @codeCoverageIgnoreStart
                if ($option['short_open_tag'] === true && $token[0] === T_INLINE_HTML && ($p = strpos($token[1], '<?')) !== false) {
                    $newtokens = [];
                    $nlcount = 0;

                    if ($p !== 0) {
                        $html = substr($token[1], 0, $p);
                        $nlcount = preg_match_all('#\r\n|\r|\n#u', $html);
                        $newtokens[] = [T_INLINE_HTML, $html, $token[2]];
                    }

                    $code = substr($token[1], $p + 2);
                    $subtokens = token_get_all("<?php $code");
                    $subtokens[0][1] = '<?';
                    foreach ($subtokens as $subtoken) {
                        if (is_array($subtoken)) {
                            $subtoken[2] += $token[2] + $nlcount - 1;
                        }
                        $newtokens[] = $subtoken;
                    }

                    array_splice($tmp, $i + 1, 0, $newtokens);
                    continue;
                }
                if ($option['short_open_tag'] === false && $token[0] === T_OPEN_TAG && $token[1] === '<?') {
                    for ($j = $i + 1; $j < count($tmp); $j++) {
                        if ($tmp[$j][0] === T_CLOSE_TAG) {
                            break;
                        }
                    }
                    $html = implode('', array_map(function ($token) {
                        return is_array($token) ? $token[1] : $token;
                    }, array_slice($tmp, $i, $j - $i + 1)));
                    array_splice($tmp, $i + 1, $j - $i, [[T_INLINE_HTML, $html, $token[2]]]);
                    continue;
                }
                // @codeCoverageIgnoreEnd

                $token[] = $position;
                if ($option['flags'] & TOKEN_NAME) {
                    $token[] = token_name($token[0]);
                }

                $position += strlen($token[1]);
                $tokens[] = $token;
            }
            // @codeCoverageIgnoreStart
            if ($option['short_open_tag'] === false) {
                for ($i = 0; $i < count($tokens); $i++) {
                    if ($tokens[$i][0] === T_INLINE_HTML && isset($tokens[$i + 1]) && $tokens[$i + 1][0] === T_INLINE_HTML) {
                        $tokens[$i][1] .= $tokens[$i + 1][1];
                        array_splice($tokens, $i + 1, 1, []);
                        $i--;
                    }
                }
            }
            // @codeCoverageIgnoreEnd
            $cache[$cachekey] = $tokens;
        }
        $tokens = $cache[$cachekey];

        $lines = $option['line'] + [-PHP_INT_MAX, PHP_INT_MAX];
        $positions = $option['position'] + [-PHP_INT_MAX, PHP_INT_MAX];
        $begin_tokens = (array) $option['begin'];
        $end_tokens = (array) $option['end'];
        $nest_tokens = $option['nest_token'];

        $result = [];
        $starting = !$begin_tokens;
        $nesting = 0;
        $offset = is_array($option['offset']) ? ($option['offset'][0] ?? 0) : $option['offset'];
        $endset = is_array($option['offset']) ? ($option['offset'][1] ?? count($tokens)) : count($tokens);

        for ($i = $offset; $i < $endset; $i++) {
            $token = $tokens[$i];

            if ($lines[0] > $token[2]) {
                continue;
            }
            if ($lines[1] < $token[2]) {
                continue;
            }
            if ($positions[0] > $token[3]) {
                continue;
            }
            if ($positions[1] < $token[3]) {
                continue;
            }

            foreach ($begin_tokens as $t) {
                if ($t === $token[0] || $t === $token[1]) {
                    $starting = true;
                    break;
                }
            }
            if (!$starting) {
                continue;
            }

            $result[$i] = $token;

            foreach ($end_tokens as $t) {
                if (isset($nest_tokens[$t])) {
                    $nest_token = $nest_tokens[$t];
                    if ($token[0] === $nest_token || $token[1] === $nest_token) {
                        $nesting++;
                    }
                }
                if ($t === $token[0] || $t === $token[1]) {
                    $nesting--;
                    if ($nesting <= 0) {
                        break 2;
                    }
                    break;
                }
            }
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\parse_php") && !defined("ryunosuke\\dbml\\parse_php")) {
    define("ryunosuke\\dbml\\parse_php", "ryunosuke\\dbml\\parse_php");
}

if (!isset($excluded_functions["indent_php"]) && (!function_exists("ryunosuke\\dbml\\indent_php") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\indent_php"))->isInternal()))) {
    /**
     * php のコードのインデントを調整する
     *
     * baseline で基準インデント位置を指定する。
     * その基準インデントを削除した後、指定したインデントレベルでインデントするようなイメージ。
     *
     * Example:
     * ```php
     * $phpcode = '
     *     echo 123;
     *
     *     if (true) {
     *         echo 456;
     *     }
     * ';
     * // 数値指定は空白換算
     * that(indent_php($phpcode, 8))->isSame('
     *         echo 123;
     *
     *         if (true) {
     *             echo 456;
     *         }
     * ');
     * // 文字列を指定すればそれが使用される
     * that(indent_php($phpcode, "  "))->isSame('
     *   echo 123;
     *
     *   if (true) {
     *       echo 456;
     *   }
     * ');
     * // オプション指定
     * that(indent_php($phpcode, [
     *     'baseline'  => 1,    // 基準インデントの行番号（負数で下からの指定になる）
     *     'indent'    => 4,    // インデント指定（上記の数値・文字列指定はこれの糖衣構文）
     *     'trimempty' => true, // 空行を trim するか
     *     'heredoc'   => true, // php7.3 の Flexible Heredoc もインデントするか
     * ]))->isSame('
     *     echo 123;
     *
     *     if (true) {
     *         echo 456;
     *     }
     * ');
     * ```
     *
     * @param string $phpcode インデントする php コード
     * @param array|int|string $options オプション
     * @return string インデントされた php コード
     */
    function indent_php($phpcode, $options = [])
    {
        if (!is_array($options)) {
            $options = ['indent' => $options];
        }
        $options += [
            'baseline'  => 1,
            'indent'    => 0,
            'trimempty' => true,
            'heredoc'   => version_compare(PHP_VERSION, '7.3.0') < 0,
        ];
        if (is_int($options['indent'])) {
            $options['indent'] = str_repeat(' ', $options['indent']);
        }

        $lines = preg_split('#\\R#u', $phpcode);
        $baseline = $options['baseline'];
        if ($baseline < 0) {
            $baseline = count($lines) + $baseline;
        }
        preg_match('@^[ \t]*@u', $lines[$baseline] ?? '', $matches);
        $indent = $matches[0] ?? '';

        $tmp = token_get_all("<?php $phpcode");
        array_shift($tmp);

        // トークンの正規化
        $tokens = [];
        for ($i = 0; $i < count($tmp); $i++) {
            if (is_string($tmp[$i])) {
                $tmp[$i] = [-1, $tmp[$i], null];
            }

            // 行コメントの分割（T_COMMENT には改行が含まれている）
            if ($tmp[$i][0] === T_COMMENT && preg_match('@^(#|//).*?(\\R)@um', $tmp[$i][1], $matches)) {
                $tmp[$i][1] = trim($tmp[$i][1]);
                if (($tmp[$i + 1][0] ?? null) === T_WHITESPACE) {
                    $tmp[$i + 1][1] = $matches[2] . $tmp[$i + 1][1];
                }
                else {
                    array_splice($tmp, $i + 1, 0, [[T_WHITESPACE, $matches[2], null]]);
                }
            }

            if ($options['heredoc']) {
                // 行コメントと同じ（T_START_HEREDOC には改行が含まれている）
                if ($tmp[$i][0] === T_START_HEREDOC && preg_match('@^(<<<).*?(\\R)@um', $tmp[$i][1], $matches)) {
                    $tmp[$i][1] = trim($tmp[$i][1]);
                    if (($tmp[$i + 1][0] ?? null) === T_ENCAPSED_AND_WHITESPACE) {
                        $tmp[$i + 1][1] = $matches[2] . $tmp[$i + 1][1];
                    }
                    else {
                        array_splice($tmp, $i + 1, 0, [[T_ENCAPSED_AND_WHITESPACE, $matches[2], null]]);
                    }
                }
                // php 7.3 において T_END_HEREDOC は必ず単一行になる
                if ($tmp[$i][0] === T_ENCAPSED_AND_WHITESPACE) {
                    if (($tmp[$i + 1][0] ?? null) === T_END_HEREDOC && preg_match('@^(\\s+)(.*)@um', $tmp[$i + 1][1], $matches)) {
                        $tmp[$i][1] = $tmp[$i][1] . $matches[1];
                        $tmp[$i + 1][1] = $matches[2];
                    }
                }
            }

            $tokens[] = $tmp[$i] + [3 => token_name($tmp[$i][0])];
        }

        // 改行を置換してインデント
        $hereing = false;
        foreach ($tokens as $i => $token) {
            if ($options['heredoc']) {
                if ($token[0] === T_START_HEREDOC) {
                    $hereing = true;
                }
                if ($token[0] === T_END_HEREDOC) {
                    $hereing = false;
                }
            }
            if (in_array($token[0], [T_WHITESPACE, T_COMMENT, T_DOC_COMMENT], true) || ($hereing && $token[0] === T_ENCAPSED_AND_WHITESPACE)) {
                $token[1] = preg_replace("@(\\R)$indent@um", '$1' . $options['indent'], $token[1]);
            }
            if ($options['trimempty']) {
                if ($token[0] === T_WHITESPACE) {
                    $token[1] = preg_replace("@(\\R)[ \\t]+(\\R)@um", '$1$2', $token[1]);
                }
            }

            $tokens[$i] = $token;
        }
        return implode('', array_column($tokens, 1));
    }
}
if (function_exists("ryunosuke\\dbml\\indent_php") && !defined("ryunosuke\\dbml\\indent_php")) {
    define("ryunosuke\\dbml\\indent_php", "ryunosuke\\dbml\\indent_php");
}

if (!isset($excluded_functions["optional"]) && (!function_exists("ryunosuke\\dbml\\optional") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\optional"))->isInternal()))) {
    /**
     * オブジェクトならそれを、オブジェクトでないなら NullObject を返す
     *
     * null を返すかもしれないステートメントを一時変数を介さずワンステートメントで呼ぶことが可能になる。
     *
     * NullObject は 基本的に null を返すが、return type が規約されている場合は null 以外を返すこともある。
     * 取得系呼び出しを想定しているので、設定系呼び出しは行うべきではない。
     * __set のような明らかに設定が意図されているものは例外が飛ぶ。
     *
     * Example:
     * ```php
     * // null を返すかもしれないステートメント
     * $getobject = function () {return null;};
     * // メソッド呼び出しは null を返す
     * that(optional($getobject())->method())->isSame(null);
     * // プロパティアクセスは null を返す
     * that(optional($getobject())->property)->isSame(null);
     * // empty は true を返す
     * that(empty(optional($getobject())->nothing))->isSame(true);
     * // __isset は false を返す
     * that(isset(optional($getobject())->nothing))->isSame(false);
     * // __toString は '' を返す
     * that(strval(optional($getobject())))->isSame('');
     * // __invoke は null を返す
     * that(call_user_func(optional($getobject())))->isSame(null);
     * // 配列アクセスは null を返す
     * that(optional($getobject())['hoge'])->isSame(null);
     * // 空イテレータを返す
     * that(iterator_to_array(optional($getobject())))->isSame([]);
     *
     * // $expected を与えるとその型以外は NullObject を返す（\ArrayObject はオブジェクトだが stdClass ではない）
     * that(optional(new \ArrayObject([1]), 'stdClass')->count())->isSame(null);
     * ```
     *
     * @param object|null $object オブジェクト
     * @param ?string $expected 期待するクラス名。指定した場合は is_a される
     * @return object $object がオブジェクトならそのまま返し、違うなら NullObject を返す
     */
    function optional($object, $expected = null)
    {
        if (is_object($object)) {
            if ($expected === null || is_a($object, $expected)) {
                return $object;
            }
        }

        static $nullobject = null;
        if ($nullobject === null) {
            $nullobject = new class implements \ArrayAccess, \IteratorAggregate {
                // @formatter:off
                public function __isset($name) { return false; }
                public function __get($name) { return null; }
                public function __set($name, $value) { throw new \DomainException('called NullObject#' . __FUNCTION__); }
                public function __unset($name) { throw new \DomainException('called NullObject#' . __FUNCTION__); }
                public function __call($name, $arguments) { return null; }
                public function __invoke() { return null; }
                public function __toString() { return ''; }
                public function offsetExists($offset) { return false; }
                public function offsetGet($offset) { return null; }
                public function offsetSet($offset, $value) { throw new \DomainException('called NullObject#' . __FUNCTION__); }
                public function offsetUnset($offset) { throw new \DomainException('called NullObject#' . __FUNCTION__); }
                public function getIterator() { return new \ArrayIterator([]); }
                // @formatter:on
            };
        }
        /** @var object $nullobject */
        return $nullobject;
    }
}
if (function_exists("ryunosuke\\dbml\\optional") && !defined("ryunosuke\\dbml\\optional")) {
    define("ryunosuke\\dbml\\optional", "ryunosuke\\dbml\\optional");
}

if (!isset($excluded_functions["throws"]) && (!function_exists("ryunosuke\\dbml\\throws") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\throws"))->isInternal()))) {
    /**
     * throw の関数版
     *
     * hoge() or throw などしたいことがまれによくあるはず。
     *
     * Example:
     * ```php
     * try {
     *     throws(new \Exception('throws'));
     * }
     * catch (\Exception $ex) {
     *     that($ex->getMessage())->isSame('throws');
     * }
     * ```
     *
     * @param \Exception $ex 投げる例外
     * @return mixed （`return hoge or throws` のようなコードで警告が出るので抑止用）
     */
    function throws($ex)
    {
        throw $ex;
    }
}
if (function_exists("ryunosuke\\dbml\\throws") && !defined("ryunosuke\\dbml\\throws")) {
    define("ryunosuke\\dbml\\throws", "ryunosuke\\dbml\\throws");
}

if (!isset($excluded_functions["try_finally"]) && (!function_exists("ryunosuke\\dbml\\try_finally") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\try_finally"))->isInternal()))) {
    /**
     * try ～ finally 構文の関数版
     *
     * 例外は投げっぱなす。例外機構構文が冗長なことがまれによくあるはず。
     *
     * Example:
     * ```php
     * $finally_count = 0;
     * $finally = function()use(&$finally_count){$finally_count++;};
     * // 例外が飛ぼうと飛ぶまいと $finally は実行される
     * $try = function($a, $b, $c){return [$a, $b, $c];};
     * that(try_finally($try, $finally, 1, 2, 3))->isSame([1, 2, 3]);
     * that($finally_count)->isSame(1); // 呼ばれている
     * // 例外は投げっぱなすが、 $finally は実行される
     * $try = function(){throw new \Exception('tried');};
     * try {try_finally($try, $finally, 1, 2, 3);} catch(\Exception $e){}
     * that($finally_count)->isSame(2); // 呼ばれている
     * ```
     *
     * @param callable $try try ブロッククロージャ
     * @param ?callable $finally finally ブロッククロージャ
     * @param mixed ...$variadic $try に渡る引数
     * @return \Exception|mixed 例外が飛ばなかったら $try ブロックの返り値、飛んだなら $catch の返り値（デフォルトで例外オブジェクト）
     */
    function try_finally($try, $finally = null, ...$variadic)
    {
        return try_catch_finally($try, throws, $finally, ...$variadic);
    }
}
if (function_exists("ryunosuke\\dbml\\try_finally") && !defined("ryunosuke\\dbml\\try_finally")) {
    define("ryunosuke\\dbml\\try_finally", "ryunosuke\\dbml\\try_finally");
}

if (!isset($excluded_functions["try_catch_finally"]) && (!function_exists("ryunosuke\\dbml\\try_catch_finally") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\try_catch_finally"))->isInternal()))) {
    /**
     * try ～ catch ～ finally 構文の関数版
     *
     * 例外機構構文が冗長なことがまれによくあるはず。
     *
     * Example:
     * ```php
     * $finally_count = 0;
     * $finally = function()use(&$finally_count){$finally_count++;};
     * // 例外が飛ぼうと飛ぶまいと $finally は実行される
     * $try = function($a, $b, $c){return [$a, $b, $c];};
     * that(try_catch_finally($try, null, $finally, 1, 2, 3))->isSame([1, 2, 3]);
     * that($finally_count)->isSame(1); // 呼ばれている
     * // 例外を投げるが、 $catch で握りつぶす
     * $try = function(){throw new \Exception('tried');};
     * that(try_catch_finally($try, null, $finally, 1, 2, 3)->getMessage())->isSame('tried');
     * that($finally_count)->isSame(2); // 呼ばれている
     * ```
     *
     * @param callable $try try ブロッククロージャ
     * @param ?callable $catch catch ブロッククロージャ
     * @param ?callable $finally finally ブロッククロージャ
     * @param mixed ...$variadic $try に渡る引数
     * @return \Exception|mixed 例外が飛ばなかったら $try ブロックの返り値、飛んだなら $catch の返り値（デフォルトで例外オブジェクト）
     */
    function try_catch_finally($try, $catch = null, $finally = null, ...$variadic)
    {
        if ($catch === null) {
            $catch = function ($v) { return $v; };
        }

        try {
            return $try(...$variadic);
        }
        catch (\Exception $tried_ex) {
            try {
                return $catch($tried_ex);
            }
            catch (\Exception $catched_ex) {
                throw $catched_ex;
            }
        }
        finally {
            if ($finally !== null) {
                $finally();
            }
        }
    }
}
if (function_exists("ryunosuke\\dbml\\try_catch_finally") && !defined("ryunosuke\\dbml\\try_catch_finally")) {
    define("ryunosuke\\dbml\\try_catch_finally", "ryunosuke\\dbml\\try_catch_finally");
}

if (!isset($excluded_functions["cacheobject"]) && (!function_exists("ryunosuke\\dbml\\cacheobject") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\cacheobject"))->isInternal()))) {
    /**
     * psr-16 を実装したキャッシュオブジェクトを返す
     *
     * このオブジェクトはあくまで「他のパッケージに依存したくない」場合のデフォルト実装としての使用を想定している。
     *
     * - キャッシュはファイルシステムに保存される
     * - キャッシュキーの . はディレクトリ区切りとして使用される
     * - TTL を指定しなかったときのデフォルト値は約100年（実質無期限だろう）
     * - clear するとディレクトリ自体を吹き飛ばすのでそのディレクトリはキャッシュ以外の用途に使用してはならない
     * - psr-16 にはない getOrSet が生えている（利便性が非常に高く使用頻度が多いため）
     *
     * psr/simple-cache （\Psr\SimpleCache\CacheInterface）が存在するなら implement される。
     * 存在しないなら素の無名クラスで返す。
     * 動作に違いはないが instanceoof や class_implements に違いが出てくるので注意。
     *
     * @param string $directory キャッシュ保存ディレクトリ
     * @return \Psr16CacheInterface psr-16 実装オブジェクト
     */
    function cacheobject($directory)
    {
        $cacheobject = new class($directory) {
            private $directory;
            private $entries = [];

            public function __construct(string $directory)
            {
                assert(strlen($directory));
                $this->directory = $directory;
            }

            private function _exception(string $message = "", int $code = 0, \Throwable $previous = null): \Throwable
            {
                return interface_exists(\Psr\SimpleCache\InvalidArgumentException::class)
                    ? new class ( $message, $code, $previous ) extends \InvalidArgumentException implements \Psr\SimpleCache\InvalidArgumentException { }
                    : new class ( $message, $code, $previous ) extends \InvalidArgumentException { };
            }

            private function _validateKey(string $key): void
            {
                if ($key === '') {
                    throw $this->_exception("\$key is empty string");
                }
                if (strpbrk($key, '{}()/\\@:') !== false) {
                    throw $this->_exception("\$key contains reserved character({}()/\\@:)");
                }
            }

            private function _normalizeTtl($ttl): int
            {
                if ($ttl === null) {
                    return 60 * 60 * 24 * 365 * 100;
                }
                if (is_int($ttl)) {
                    return $ttl;
                }
                if ($ttl instanceof \DateInterval) {
                    return (new \DateTime())->setTimestamp(0)->add($ttl)->getTimestamp();
                }
                throw $this->_exception("\$ttl must be null|int|DateInterval(" . gettype($ttl) . ")");
            }

            private function _getFilename(string $key): string
            {
                return $this->directory . DIRECTORY_SEPARATOR . strtr(rawurlencode($key), ['.' => DIRECTORY_SEPARATOR]) . ".php";
            }

            public function fetch($key, $provider, $ttl = null)
            {
                $value = $this->get($key);
                if ($value === null) {
                    $value = $provider($this);
                    $this->set($key, $value, $ttl);
                }
                return $value;
            }

            public function fetchMultiple($providers, $ttl = null)
            {
                $result = $this->getMultiple(array_keys($providers));
                foreach ($providers as $key => $provider) {
                    $result[$key] = $result[$key] ?? $this->fetch($key, $provider, $ttl);
                }
                return $result;
            }

            public function get($key, $default = null)
            {
                $this->_validateKey($key);

                error_clear_last();
                $entry = $this->entries[$key] ?? @include $this->_getFilename($key);
                if (error_get_last() !== null || $entry[0] < time()) {
                    $this->delete($key);
                    return $default;
                }

                $this->entries[$key] = $entry;
                return $entry[1];
            }

            public function set($key, $value, $ttl = null)
            {
                $this->_validateKey($key);
                $ttl = $this->_normalizeTtl($ttl);

                if ($ttl <= 0) {
                    return $this->delete($key);
                }

                $this->entries[$key] = [time() + $ttl, $value];
                $code = var_export3($this->entries[$key], ['outmode' => 'file']);
                return !!file_set_contents($this->_getFilename($key), $code);
            }

            public function delete($key)
            {
                $this->_validateKey($key);

                unset($this->entries[$key]);
                return @unlink($this->_getFilename($key));
            }

            public function clear()
            {
                $this->entries = [];
                return rm_rf($this->directory, false);
            }

            public function getMultiple($keys, $default = null)
            {
                return array_each($keys, function (&$result, $v) use ($default) {
                    $result[$v] = $this->get($v, $default);
                }, []);
            }

            public function setMultiple($values, $ttl = null)
            {
                return array_each($values, function (&$result, $v, $k) use ($ttl) {
                    $result = $this->set($k, $v, $ttl) && $result;
                }, true);
            }

            public function deleteMultiple($keys)
            {
                return array_each($keys, function (&$result, $v) {
                    $result = $this->delete($v) && $result;
                }, true);
            }

            public function has($key)
            {
                return $this->get($key) !== null;
            }
        };

        /** @noinspection PhpIncompatibleReturnTypeInspection */
        return !interface_exists(\Psr\SimpleCache\CacheInterface::class) ? $cacheobject : new class($cacheobject) implements \Psr\SimpleCache\CacheInterface {
            private $cacheobject;

            public function __construct($cacheobject)
            {
                $this->cacheobject = $cacheobject;
            }

            // @formatter:off
            public function fetch($key, $provider, $ttl = null)    { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function fetchMultiple($providers, $ttl = null) { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function get($key, $default = null)             { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function set($key, $value, $ttl = null)         { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function delete($key)                           { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function clear()                                { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function getMultiple($keys, $default = null)    { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function setMultiple($values, $ttl = null)      { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function deleteMultiple($keys)                  { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            public function has($key)                              { return $this->cacheobject->{__FUNCTION__}(...func_get_args()); }
            // @formatter:on
        };
    }
}
if (function_exists("ryunosuke\\dbml\\cacheobject") && !defined("ryunosuke\\dbml\\cacheobject")) {
    define("ryunosuke\\dbml\\cacheobject", "ryunosuke\\dbml\\cacheobject");
}

if (!isset($excluded_functions["cachedir"]) && (!function_exists("ryunosuke\\dbml\\cachedir") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\cachedir"))->isInternal()))) {
    /**
     * 本ライブラリで使用するキャッシュディレクトリを設定する
     *
     * @param string|null $dirname キャッシュディレクトリ。省略時は返すのみ
     * @return string 設定前のキャッシュディレクトリ
     */
    function cachedir($dirname = null)
    {
        static $cachedir;
        if ($cachedir === null) {
            $cachedir = sys_get_temp_dir() . DIRECTORY_SEPARATOR . strtr(__NAMESPACE__, ['\\' => '%']);
            cachedir($cachedir); // for mkdir
        }

        if ($dirname === null) {
            return $cachedir;
        }

        if (!file_exists($dirname)) {
            @mkdir($dirname, 0777 & (~umask()), true);
        }
        $result = $cachedir;
        $cachedir = realpath($dirname);
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\cachedir") && !defined("ryunosuke\\dbml\\cachedir")) {
    define("ryunosuke\\dbml\\cachedir", "ryunosuke\\dbml\\cachedir");
}

if (!isset($excluded_functions["cache"]) && (!function_exists("ryunosuke\\dbml\\cache") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\cache"))->isInternal()))) {
    /**
     * シンプルにキャッシュする
     *
     * この関数は get/set/delete を兼ねる。
     * キャッシュがある場合はそれを返し、ない場合は $provider を呼び出してその結果をキャッシュしつつそれを返す。
     *
     * $provider に null を与えるとキャッシュの削除となる。
     *
     * Example:
     * ```php
     * $provider = function(){return rand();};
     * // 乱数を返す処理だが、キャッシュされるので同じ値になる
     * $rand1 = cache('rand', $provider);
     * $rand2 = cache('rand', $provider);
     * that($rand1)->isSame($rand2);
     * // $provider に null を与えると削除される
     * cache('rand', null);
     * $rand3 = cache('rand', $provider);
     * that($rand1)->isNotSame($rand3);
     * ```
     *
     * @param string $key キャッシュのキー
     * @param callable $provider キャッシュがない場合にコールされる callable
     * @param ?string $namespace 名前空間
     * @return mixed キャッシュ
     */
    function cache($key, $provider, $namespace = null)
    {
        static $cacheobject;
        $cacheobject = $cacheobject ?? new class(cachedir()) {
                const CACHE_EXT = '.php-cache';

                /** @var string キャッシュディレクトリ */
                private $cachedir;

                /** @var array 内部キャッシュ */
                private $cache;

                /** @var array 変更感知配列 */
                private $changed;

                public function __construct($cachedir)
                {
                    $this->cachedir = $cachedir;
                    $this->cache = [];
                    $this->changed = [];
                }

                public function __destruct()
                {
                    // 変更されているもののみ保存
                    foreach ($this->changed as $namespace => $dummy) {
                        $filepath = $this->cachedir . '/' . rawurlencode($namespace) . self::CACHE_EXT;
                        $content = "<?php\nreturn " . var_export($this->cache[$namespace], true) . ";\n";

                        $temppath = tempnam(sys_get_temp_dir(), 'cache');
                        if (file_put_contents($temppath, $content) !== false) {
                            @chmod($temppath, 0644);
                            if (!@rename($temppath, $filepath)) {
                                @unlink($temppath); // @codeCoverageIgnore
                            }
                        }
                    }
                }

                public function has($namespace, $key)
                {
                    // ファイルから読み込む必要があるので get しておく
                    $this->get($namespace, $key);
                    return array_key_exists($key, $this->cache[$namespace]);
                }

                public function get($namespace, $key)
                {
                    // 名前空間自体がないなら作る or 読む
                    if (!isset($this->cache[$namespace])) {
                        $nsarray = [];
                        $cachpath = $this->cachedir . '/' . rawurldecode($namespace) . self::CACHE_EXT;
                        if (file_exists($cachpath)) {
                            $nsarray = require $cachpath;
                        }
                        $this->cache[$namespace] = $nsarray;
                    }

                    return $this->cache[$namespace][$key] ?? null;
                }

                public function set($namespace, $key, $value)
                {
                    // 新しい値が来たら変更フラグを立てる
                    if (!isset($this->cache[$namespace]) || !array_key_exists($key, $this->cache[$namespace]) || $this->cache[$namespace][$key] !== $value) {
                        $this->changed[$namespace] = true;
                    }

                    $this->cache[$namespace][$key] = $value;
                }

                public function delete($namespace, $key)
                {
                    $this->changed[$namespace] = true;
                    unset($this->cache[$namespace][$key]);
                }

                public function clear()
                {
                    // インメモリ情報をクリアして・・・
                    $this->cache = [];
                    $this->changed = [];

                    // ファイルも消す
                    foreach (glob($this->cachedir . '/*' . self::CACHE_EXT) as $file) {
                        unlink($file);
                    }
                }
            };

        // flush (for test)
        if ($key === null) {
            if ($provider === null) {
                $cacheobject->clear();
            }
            $cacheobject = null;
            return;
        }

        $namespace = $namespace ?? __FILE__;

        $exist = $cacheobject->has($namespace, $key);
        if ($provider === null) {
            $cacheobject->delete($namespace, $key);
            return $exist;
        }
        if (!$exist) {
            $cacheobject->set($namespace, $key, $provider());
        }
        return $cacheobject->get($namespace, $key);
    }
}
if (function_exists("ryunosuke\\dbml\\cache") && !defined("ryunosuke\\dbml\\cache")) {
    define("ryunosuke\\dbml\\cache", "ryunosuke\\dbml\\cache");
}

if (!isset($excluded_functions["parse_namespace"]) && (!function_exists("ryunosuke\\dbml\\parse_namespace") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\parse_namespace"))->isInternal()))) {
    /**
     * php ファイルをパースして名前空間配列を返す
     *
     * ファイル内で use/use const/use function していたり、シンボルを定義していたりする箇所を検出して名前空間単位で返す。
     *
     * Example:
     * ```php
     * // このような php ファイルをパースすると・・・
     * file_set_contents(sys_get_temp_dir() . '/namespace.php', '
     * <?php
     * namespace NS1;
     * use ArrayObject as AO;
     * use function strlen as SL;
     * function InnerFunc(){}
     * class InnerClass{}
     * define("OUTER\\\\CONST", "OuterConst");
     *
     * namespace NS2;
     * use RuntimeException as RE;
     * use const COUNT_RECURSIVE as CR;
     * class InnerClass{}
     * const InnerConst = 123;
     * ');
     * // このような名前空間配列が得られる
     * that(parse_namespace(sys_get_temp_dir() . '/namespace.php'))->isSame([
     *     'NS1' => [
     *         'const'    => [],
     *         'function' => [
     *             'SL'        => 'strlen',
     *             'InnerFunc' => 'NS1\\InnerFunc',
     *         ],
     *         'alias'    => [
     *             'AO'         => 'ArrayObject',
     *             'InnerClass' => 'NS1\\InnerClass',
     *         ],
     *     ],
     *     'OUTER' => [
     *         'const'    => [
     *             'CONST' => 'OUTER\\CONST',
     *         ],
     *         'function' => [],
     *         'alias'    => [],
     *     ],
     *     'NS2' => [
     *         'const'    => [
     *             'CR'         => 'COUNT_RECURSIVE',
     *             'InnerConst' => 'NS2\\InnerConst',
     *         ],
     *         'function' => [],
     *         'alias'    => [
     *             'RE'         => 'RuntimeException',
     *             'InnerClass' => 'NS2\\InnerClass',
     *         ],
     *     ],
     * ]);
     * ```
     *
     * @param string $filename ファイル名
     * @param array $options オプション配列
     * @return array 名前空間配列
     */
    function parse_namespace($filename, $options = [])
    {
        $options += [
            'cache' => true,
        ];
        if (!$options['cache']) {
            cache(realpath($filename), null, __FUNCTION__);
        }
        return cache(realpath($filename), function () use ($filename) {
            $stringify = function ($tokens) {
                // @codeCoverageIgnoreStart
                if (version_compare(PHP_VERSION, '8.0.0') >= 0) {
                    return trim(implode('', array_column(array_filter($tokens, function ($token) {
                        /** @noinspection PhpElementIsNotAvailableInCurrentPhpVersionInspection */
                        return in_array($token[0], [T_NAME_QUALIFIED, T_NAME_FULLY_QUALIFIED, T_NAME_RELATIVE, T_STRING], true);
                    }), 1)), '\\');
                }
                // @codeCoverageIgnoreEnd
                return trim(implode('', array_column(array_filter($tokens, function ($token) {
                    return $token[0] === T_NS_SEPARATOR || $token[0] === T_STRING;
                }), 1)), '\\');
            };

            $keys = [
                0           => 'alias', // for use
                T_CLASS     => 'alias',
                T_INTERFACE => 'alias',
                T_TRAIT     => 'alias',
                T_STRING    => 'const', // for define
                T_CONST     => 'const',
                T_FUNCTION  => 'function',
            ];

            $contents = "?>" . file_get_contents($filename);
            $namespace = '';
            $tokens = [-1 => null];
            $result = [];
            while (true) {
                $tokens = parse_php($contents, [
                    'flags'  => TOKEN_PARSE,
                    'begin'  => ["define", T_NAMESPACE, T_USE, T_CONST, T_FUNCTION, T_CLASS, T_INTERFACE, T_TRAIT],
                    'end'    => ['{', ';', '(', T_EXTENDS, T_IMPLEMENTS],
                    'offset' => last_key($tokens) + 1,
                ]);
                if (!$tokens) {
                    break;
                }
                $token = reset($tokens);
                // define は現在の名前空間とは無関係に名前空間定数を宣言することができる
                if ($token[0] === T_STRING && $token[1] === "define") {
                    $tokens = parse_php($contents, [
                        'flags'  => TOKEN_PARSE,
                        'begin'  => [T_CONSTANT_ENCAPSED_STRING],
                        'end'    => [T_CONSTANT_ENCAPSED_STRING],
                        'offset' => last_key($tokens),
                    ]);
                    $define = trim(json_decode(implode('', array_column($tokens, 1))), '\\');
                    [$ns, $nm] = namespace_split($define);
                    if (!isset($result[$ns])) {
                        $result[$ns] = [
                            'const'    => [],
                            'function' => [],
                            'alias'    => [],
                        ];
                    }
                    $result[$ns][$keys[$token[0]]][$nm] = $define;
                }
                switch ($token[0]) {
                    case T_NAMESPACE:
                        $namespace = $stringify($tokens);
                        $result[$namespace] = [
                            'const'    => [],
                            'function' => [],
                            'alias'    => [],
                        ];
                        break;
                    case T_USE:
                        $tokenCorF = array_find($tokens, function ($token) {
                            return ($token[0] === T_CONST || $token[0] === T_FUNCTION) ? $token[0] : 0;
                        }, false);

                        $prefix = '';
                        if (end($tokens)[1] === '{') {
                            $prefix = $stringify($tokens);
                            $tokens = parse_php($contents, [
                                'flags'  => TOKEN_PARSE,
                                'begin'  => ['{'],
                                'end'    => ['}'],
                                'offset' => last_key($tokens),
                            ]);
                        }

                        $multi = array_explode($tokens, function ($token) { return $token[1] === ','; });
                        foreach ($multi as $ttt) {
                            $as = array_explode($ttt, function ($token) { return $token[0] === T_AS; });

                            $alias = $stringify($as[0]);
                            if (isset($as[1])) {
                                $result[$namespace][$keys[$tokenCorF]][$stringify($as[1])] = concat($prefix, '\\') . $alias;
                            }
                            else {
                                $result[$namespace][$keys[$tokenCorF]][namespace_split($alias)[1]] = concat($prefix, '\\') . $alias;
                            }
                        }
                        break;
                    case T_CONST:
                    case T_FUNCTION:
                    case T_CLASS:
                    case T_INTERFACE:
                    case T_TRAIT:
                        $alias = $stringify($tokens);
                        if (strlen($alias)) {
                            $result[$namespace][$keys[$token[0]]][$alias] = concat($namespace, '\\') . $alias;
                        }
                        // ブロック内に興味はないので進めておく（function 内 function などはあり得るが考慮しない）
                        if ($token[0] !== T_CONST) {
                            $tokens = parse_php($contents, [
                                'flags'  => TOKEN_PARSE,
                                'begin'  => ['{'],
                                'end'    => ['}'],
                                'offset' => last_key($tokens),
                            ]);
                            break;
                        }
                }
            }
            return $result;
        }, __FUNCTION__);
    }
}
if (function_exists("ryunosuke\\dbml\\parse_namespace") && !defined("ryunosuke\\dbml\\parse_namespace")) {
    define("ryunosuke\\dbml\\parse_namespace", "ryunosuke\\dbml\\parse_namespace");
}

if (!isset($excluded_functions["resolve_symbol"]) && (!function_exists("ryunosuke\\dbml\\resolve_symbol") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\resolve_symbol"))->isInternal()))) {
    /**
     * エイリアス名を完全修飾名に解決する
     *
     * 例えばあるファイルのある名前空間で `use Hoge\Fuga\Piyo;` してるときの `Piyo` を `Hoge\Fuga\Piyo` に解決する。
     *
     * Example:
     * ```php
     * // このような php ファイルがあるとして・・・
     * file_set_contents(sys_get_temp_dir() . '/symbol.php', '
     * <?php
     * namespace vendor\NS;
     *
     * use ArrayObject as AO;
     * use function strlen as SL;
     *
     * function InnerFunc(){}
     * class InnerClass{}
     * ');
     * // 下記のように解決される
     * that(resolve_symbol('AO', sys_get_temp_dir() . '/symbol.php'))->isSame('ArrayObject');
     * that(resolve_symbol('SL', sys_get_temp_dir() . '/symbol.php'))->isSame('strlen');
     * that(resolve_symbol('InnerFunc', sys_get_temp_dir() . '/symbol.php'))->isSame('vendor\\NS\\InnerFunc');
     * that(resolve_symbol('InnerClass', sys_get_temp_dir() . '/symbol.php'))->isSame('vendor\\NS\\InnerClass');
     * ```
     *
     * @param string $shortname エイリアス名
     * @param string|array $nsfiles ファイル名 or [ファイル名 => 名前空間名]
     * @param array $targets エイリアスタイプ（'const', 'function', 'alias' のいずれか）
     * @return string|null 完全修飾名。解決できなかった場合は null
     */
    function resolve_symbol(string $shortname, $nsfiles, $targets = ['const', 'function', 'alias'])
    {
        // 既に完全修飾されている場合は何もしない
        if (($shortname[0] ?? null) === '\\') {
            return $shortname;
        }

        // use Inner\Space のような名前空間の use の場合を考慮する
        $parts = explode('\\', $shortname, 2);
        $prefix = isset($parts[1]) ? array_shift($parts) : null;

        if (is_string($nsfiles)) {
            $nsfiles = [$nsfiles => []];
        }

        $targets = (array) $targets;
        foreach ($nsfiles as $filename => $namespaces) {
            $namespaces = array_flip(array_map(function ($n) { return trim($n, '\\'); }, (array) $namespaces));
            foreach (parse_namespace($filename) as $namespace => $ns) {
                /** @noinspection PhpIllegalArrayKeyTypeInspection */
                if (!$namespaces || isset($namespaces[$namespace])) {
                    if (isset($ns['alias'][$prefix])) {
                        return $ns['alias'][$prefix] . '\\' . implode('\\', $parts);
                    }
                    foreach ($targets as $target) {
                        if (isset($ns[$target][$shortname])) {
                            return $ns[$target][$shortname];
                        }
                    }
                }
            }
        }
        return null;
    }
}
if (function_exists("ryunosuke\\dbml\\resolve_symbol") && !defined("ryunosuke\\dbml\\resolve_symbol")) {
    define("ryunosuke\\dbml\\resolve_symbol", "ryunosuke\\dbml\\resolve_symbol");
}

if (!isset($excluded_functions["parse_annotation"]) && (!function_exists("ryunosuke\\dbml\\parse_annotation") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\parse_annotation"))->isInternal()))) {
    /**
     * アノテーションっぽい文字列をそれっぽくパースして返す
     *
     * $annotation にはリフレクションオブジェクトも渡せる。
     * その場合、getDocComment や getFilename, getNamespaceName などを用いてある程度よしなに名前解決する。
     * もっとも、@Class(args) 形式を使わないのであれば特に意味はない。
     *
     * $schame で「どのように取得するか？」のスキーマ定義が渡せる。
     * スキーマ定義は連想配列で各アノテーションごとに下記のような定義を指定でき、連想配列でない場合はすべてのアノテーションにおいて指定したとみなされる。
     *
     * - true: 余計なことはせず、アノテーションの文字列をそのまま返す
     * - false: 下記にようによしなに変換して返す
     * - []: 複数値モードを強制する
     * - null: 単一値モードを強制する
     *
     * アノテーションの仕様は下記（すべて $schema が false であるとする）。
     *
     * - @から行末まで（1行に複数のアノテーションは含められない）
     *     - ただし行末が `({[` のいずれかであれば次の `]})` までブロックを記載する機会が与えられる
     *     - ブロックを見つけたときは本来値となるべき値がキーに、ブロックが値となり、結果は必ず配列化される
     * - 同じアノテーションを複数見つけたときは配列化される
     * - `@hogera`: 値なしは null を返す
     * - `@hogera v1 "v2 v3"`: ["v1", "v2 v3"] という配列として返す
     * - `@hogera {key: 123}`: ["key" => 123] という（連想）配列として返す
     * - `@hogera [123, 456]`: [123, 456] という連番配列として返す
     * - `@hogera ("2019/12/23")`: hogera で解決できるクラス名で new して返す（$filename 引数の指定が必要）
     * - 下3つの形式はアノテーション区切りのスペースはあってもなくても良い
     *
     * $schema が true だと上記のような変換は一切行わず、素朴な文字列で返す。
     * あくまで簡易実装であり、本格的に何かをしたいなら専用のパッケージを導入したほうが良い。
     *
     * Example:
     * ```php
     * $annotations = parse_annotation('
     *
     * @noval
     * @single this is value
     * @closure this is value
     * @array this is value
     * @hash {key: 123}
     * @list [1, 2, 3]
     * @ArrayObject([1, 2, 3])
     * @block message {
     *     this is message1
     *     this is message2
     * }
     * @same this is same value1
     * @same this is same value2
     * @same this is same value3
     * ', [
     *     'single'  => true,
     *     'closure' => function ($value) { return explode(' ', strtoupper($value)); },
     * ]);
     * that($annotations)->is([
     *     'noval'       => null,                        // 値なしは null になる
     *     'single'      => 'this is value',             // $schema 指定してるので文字列になる
     *     'closure'     => ['THIS', 'IS', 'VALUE'],     // $schema 指定してそれがクロージャだとコールバックされる
     *     'array'       => ['this', 'is', 'value'],     // $schema 指定していないので配列になる
     *     'hash'        => ['key' => '123'],            // 連想配列になる
     *     'list'        => [1, 2, 3],                   // 連番配列になる
     *     'ArrayObject' => new \ArrayObject([1, 2, 3]), // new されてインスタンスになる
     *     "block"       => [                            // ブロックはブロック外をキーとした連想配列になる（複数指定でキーは指定できるイメージ）
     *         "message" => ["this is message1\n    this is message2"],
     *     ],
     *     'same'        => [                            // 複数あるのでそれぞれの配列になる
     *         ['this', 'is', 'same', 'value1'],
     *         ['this', 'is', 'same', 'value2'],
     *         ['this', 'is', 'same', 'value3'],
     *     ],
     * ]);
     * ```
     *
     * @param string|\Reflector $annotation アノテーション文字列
     * @param array|mixed $schema スキーマ定義
     * @param string|array $nsfiles ファイル名 or [ファイル名 => 名前空間名]
     * @return array アノテーション配列
     */
    function parse_annotation($annotation, $schema = [], $nsfiles = [])
    {
        if ($annotation instanceof \Reflector) {
            $reflector = $annotation;
            /** @noinspection PhpPossiblePolymorphicInvocationInspection */
            $annotation = $reflector->getDocComment();

            // クラスメンバーリフレクションは getDeclaringClass しないと名前空間が取れない
            if (false
                || $reflector instanceof \ReflectionClassConstant
                || $reflector instanceof \ReflectionProperty
                || $reflector instanceof \ReflectionMethod
            ) {
                $reflector = $reflector->getDeclaringClass();
            }

            // 無名クラスに名前空間という概念はない（無くはないが普通に想起される名前空間ではない）
            $namespaces = [];
            if (!($reflector instanceof \ReflectionClass && $reflector->isAnonymous())) {
                $namespaces[] = $reflector->getNamespaceName();
            }
            $nsfiles[$reflector->getFileName()] = $nsfiles[$reflector->getFileName()] ?? $namespaces;

            // doccomment 特有のインデントを削除する
            $annotation = preg_replace('#(\\R)[ \\t]+\\*[ \\t]?#u', '$1', str_chop($annotation, '/**', '*/'));
        }

        $result = [];
        $multiples = [];

        $brace = [
            '(' => ')',
            '{' => '}',
            '[' => ']',
        ];
        for ($i = 0, $l = strlen($annotation); $i < $l; $i++) {
            $i = strpos_quoted($annotation, '@', $i);
            if ($i === false) {
                break;
            }

            $seppos = min(strpos_array($annotation, [" ", "\t", "\n", '[', '{', '('], $i + 1) ?: [false]);
            $name = substr($annotation, $i + 1, $seppos - $i - 1);
            $i += strlen($name);
            $name = trim($name);

            $key = null;
            $brkpos = strpos_quoted($annotation, "\n", $seppos) ?: strlen($annotation);
            if (isset($brace[$annotation[$brkpos - 1]])) {
                $s = $annotation[$brkpos - 1];
                $e = $brace[$s];
                $brkpos--;
                $key = trim(substr($annotation, $seppos, $brkpos - $seppos));
                $value = $s . str_between($annotation, $s, $e, $brkpos) . $e;
                $i = $brkpos;
            }
            else {
                $endpos = strpos_quoted($annotation, "@", $seppos) ?: strlen($annotation);
                $value = substr($annotation, $seppos, $endpos - $seppos);
                $i += strlen($value);
                $value = trim($value);
            }

            $rawmode = $schema;
            if (is_array($rawmode)) {
                $rawmode = array_key_exists($name, $rawmode) ? $rawmode[$name] : false;
            }
            if ($rawmode instanceof \Closure) {
                $value = $rawmode($value, $key);
            }
            elseif ($rawmode) {
                if (is_string($key)) {
                    $value = substr($value, 1, -1);
                }
            }
            else {
                if (is_array($rawmode)) {
                    $multiples[$name] = true;
                }
                if (is_null($rawmode)) {
                    $multiples[$name] = false;
                }
                if ($value === '') {
                    $value = null;
                }
                elseif (in_array($value[0] ?? null, ['('], true)) {
                    $class = resolve_symbol($name, $nsfiles, 'alias') ?? $name;
                    $value = new $class(...paml_import(substr($value, 1, -1)));
                }
                elseif (in_array($value[0] ?? null, ['{', '['], true)) {
                    $value = (array) paml_import($value)[0];
                }
                else {
                    $value = array_values(array_filter(quoteexplode([" ", "\t"], $value), "strlen"));
                }
            }

            if (array_key_exists($name, $result) && !isset($multiples[$name])) {
                $multiples[$name] = true;
                $result[$name] = [$result[$name]];
            }
            if (strlen($key)) {
                $multiples[$name] = true;
                $result[$name][$key] = $value;
            }
            elseif (isset($multiples[$name]) && $multiples[$name] === true) {
                $result[$name][] = $value;
            }
            else {
                $result[$name] = $value;
            }
        }

        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\parse_annotation") && !defined("ryunosuke\\dbml\\parse_annotation")) {
    define("ryunosuke\\dbml\\parse_annotation", "ryunosuke\\dbml\\parse_annotation");
}

if (!isset($excluded_functions["arrayval"]) && (!function_exists("ryunosuke\\dbml\\arrayval") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\arrayval"))->isInternal()))) {
    /**
     * array キャストの関数版
     *
     * intval とか strval とかの array 版。
     * ただキャストするだけだが、関数なのでコールバックとして使える。
     *
     * $recursive を true にすると再帰的に適用する（デフォルト）。
     * 入れ子オブジェクトを配列化するときなどに使える。
     *
     * Example:
     * ```php
     * // キャストなので基本的には配列化される
     * that(arrayval(123))->isSame([123]);
     * that(arrayval('str'))->isSame(['str']);
     * that(arrayval([123]))->isSame([123]); // 配列は配列のまま
     *
     * // $recursive = false にしない限り再帰的に適用される
     * $stdclass = stdclass(['key' => 'val']);
     * that(arrayval([$stdclass], true))->isSame([['key' => 'val']]); // true なので中身も配列化される
     * that(arrayval([$stdclass], false))->isSame([$stdclass]);       // false なので中身は変わらない
     * ```
     *
     * @param mixed $var array 化する値
     * @param bool $recursive 再帰的に行うなら true
     * @return array array 化した配列
     */
    function arrayval($var, $recursive = true)
    {
        // return json_decode(json_encode($var), true);

        // 無駄なループを回したくないので非再帰で配列の場合はそのまま返す
        if (!$recursive && is_array($var)) {
            return $var;
        }

        if (is_primitive($var)) {
            return (array) $var;
        }

        $result = [];
        foreach ($var as $k => $v) {
            if ($recursive && !is_primitive($v)) {
                $v = arrayval($v, $recursive);
            }
            $result[$k] = $v;
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\arrayval") && !defined("ryunosuke\\dbml\\arrayval")) {
    define("ryunosuke\\dbml\\arrayval", "ryunosuke\\dbml\\arrayval");
}

if (!isset($excluded_functions["is_empty"]) && (!function_exists("ryunosuke\\dbml\\is_empty") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\is_empty"))->isInternal()))) {
    /**
     * 値が空か検査する
     *
     * `empty` とほぼ同じ。ただし
     *
     * - string: "0"
     * - countable でない object
     * - countable である object で count() > 0
     *
     * は false 判定する。
     * ただし、 $empty_stcClass に true を指定すると「フィールドのない stdClass」も true を返すようになる。
     * これは stdClass の立ち位置はかなり特殊で「フィールドアクセスできる組み込み配列」のような扱いをされることが多いため。
     * （例えば `json_decode('{}')` は stdClass を返すが、このような状況は空判定したいことが多いだろう）。
     *
     * なお、関数の仕様上、未定義変数を true 判定することはできない。
     * 未定義変数をチェックしたい状況は大抵の場合コードが悪いが `$array['key1']['key2']` を調べたいことはある。
     * そういう時には使えない（?? する必要がある）。
     *
     * 「 `if ($var) {}` で十分なんだけど "0" が…」という状況はまれによくあるはず。
     *
     * Example:
     * ```php
     * // この辺は empty と全く同じ
     * that(is_empty(null))->isTrue();
     * that(is_empty(false))->isTrue();
     * that(is_empty(0))->isTrue();
     * that(is_empty(''))->isTrue();
     * // この辺だけが異なる
     * that(is_empty('0'))->isFalse();
     * // 第2引数に true を渡すと空の stdClass も empty 判定される
     * $stdclass = new \stdClass();
     * that(is_empty($stdclass, true))->isTrue();
     * // フィールドがあれば empty ではない
     * $stdclass->hoge = 123;
     * that(is_empty($stdclass, true))->isFalse();
     * ```
     *
     * @param mixed $var 判定する値
     * @param bool $empty_stdClass 空の stdClass を空とみなすか
     * @return bool 空なら true
     */
    function is_empty($var, $empty_stdClass = false)
    {
        // object は is_countable 次第
        if (is_object($var)) {
            // が、 stdClass だけは特別扱い（stdClass は継承もできるので、クラス名で判定する（継承していたらそれはもう stdClass ではないと思う））
            if ($empty_stdClass && get_class($var) === 'stdClass') {
                return !(array) $var;
            }
            if (is_countable($var)) {
                return !count($var);
            }
            return false;
        }

        // "0" は false
        if ($var === '0') {
            return false;
        }

        // 上記以外は empty に任せる
        return empty($var);
    }
}
if (function_exists("ryunosuke\\dbml\\is_empty") && !defined("ryunosuke\\dbml\\is_empty")) {
    define("ryunosuke\\dbml\\is_empty", "ryunosuke\\dbml\\is_empty");
}

if (!isset($excluded_functions["is_primitive"]) && (!function_exists("ryunosuke\\dbml\\is_primitive") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\is_primitive"))->isInternal()))) {
    /**
     * 値が複合型でないか検査する
     *
     * 「複合型」とはオブジェクトと配列のこと。
     * つまり
     *
     * - is_scalar($var) || is_null($var) || is_resource($var)
     *
     * と同義（!is_array($var) && !is_object($var) とも言える）。
     *
     * Example:
     * ```php
     * that(is_primitive(null))->isTrue();
     * that(is_primitive(false))->isTrue();
     * that(is_primitive(123))->isTrue();
     * that(is_primitive(STDIN))->isTrue();
     * that(is_primitive(new \stdClass))->isFalse();
     * that(is_primitive(['array']))->isFalse();
     * ```
     *
     * @param mixed $var 調べる値
     * @return bool 複合型なら false
     */
    function is_primitive($var)
    {
        return is_scalar($var) || is_null($var) || is_resource($var);
    }
}
if (function_exists("ryunosuke\\dbml\\is_primitive") && !defined("ryunosuke\\dbml\\is_primitive")) {
    define("ryunosuke\\dbml\\is_primitive", "ryunosuke\\dbml\\is_primitive");
}

if (!isset($excluded_functions["is_stringable"]) && (!function_exists("ryunosuke\\dbml\\is_stringable") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\is_stringable"))->isInternal()))) {
    /**
     * 変数が文字列化できるか調べる
     *
     * 「配列」「__toString を持たないオブジェクト」が false になる。
     * （厳密に言えば配列は "Array" になるので文字列化できるといえるがここでは考えない）。
     *
     * Example:
     * ```php
     * // こいつらは true
     * that(is_stringable(null))->isTrue();
     * that(is_stringable(true))->isTrue();
     * that(is_stringable(3.14))->isTrue();
     * that(is_stringable(STDOUT))->isTrue();
     * that(is_stringable(new \Exception()))->isTrue();
     * // こいつらは false
     * that(is_stringable(new \ArrayObject()))->isFalse();
     * that(is_stringable([1, 2, 3]))->isFalse();
     * ```
     *
     * @param mixed $var 調べる値
     * @return bool 文字列化できるなら true
     */
    function is_stringable($var)
    {
        if (is_array($var)) {
            return false;
        }
        if (is_object($var) && !method_exists($var, '__toString')) {
            return false;
        }
        return true;
    }
}
if (function_exists("ryunosuke\\dbml\\is_stringable") && !defined("ryunosuke\\dbml\\is_stringable")) {
    define("ryunosuke\\dbml\\is_stringable", "ryunosuke\\dbml\\is_stringable");
}

if (!isset($excluded_functions["is_arrayable"]) && (!function_exists("ryunosuke\\dbml\\is_arrayable") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\is_arrayable"))->isInternal()))) {
    /**
     * 変数が配列アクセス可能か調べる
     *
     * Example:
     * ```php
     * that(is_arrayable([]))->isTrue();
     * that(is_arrayable(new \ArrayObject()))->isTrue();
     * that(is_arrayable(new \stdClass()))->isFalse();
     * ```
     *
     * @param array|object $var 調べる値
     * @return bool 配列アクセス可能なら true
     */
    function is_arrayable($var)
    {
        return is_array($var) || $var instanceof \ArrayAccess;
    }
}
if (function_exists("ryunosuke\\dbml\\is_arrayable") && !defined("ryunosuke\\dbml\\is_arrayable")) {
    define("ryunosuke\\dbml\\is_arrayable", "ryunosuke\\dbml\\is_arrayable");
}

if (!isset($excluded_functions["is_countable"]) && (!function_exists("ryunosuke\\dbml\\is_countable") || (!true && (new \ReflectionFunction("ryunosuke\\dbml\\is_countable"))->isInternal()))) {
    /**
     * 変数が count でカウントできるか調べる
     *
     * 要するに {@link http://php.net/manual/function.is-countable.php is_countable} の polyfill。
     *
     * Example:
     * ```php
     * that(is_countable([1, 2, 3]))->isTrue();
     * that(is_countable(new \ArrayObject()))->isTrue();
     * that(is_countable((function () { yield 1; })()))->isFalse();
     * that(is_countable(1))->isFalse();
     * that(is_countable(new \stdClass()))->isFalse();
     * ```
     *
     * @polyfill
     *
     * @param mixed $var 調べる値
     * @return bool count でカウントできるなら true
     */
    function is_countable($var)
    {
        return is_array($var) || $var instanceof \Countable;
    }
}
if (function_exists("ryunosuke\\dbml\\is_countable") && !defined("ryunosuke\\dbml\\is_countable")) {
    define("ryunosuke\\dbml\\is_countable", "ryunosuke\\dbml\\is_countable");
}

if (!isset($excluded_functions["var_hash"]) && (!function_exists("ryunosuke\\dbml\\var_hash") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\var_hash"))->isInternal()))) {
    /**
     * 値に複数のハッシュアルゴリズムを適用させて結合して返す
     *
     * $data は何らかの方法で文字列化される（この「何らかの方法」は互換性を担保しない）。
     * 文字長がかなり増えるため、 $base64 に true を与えるとバイナリ変換してその結果を base64（url セーフ）して返す。
     * さらに false を与えると 16進数文字列で返し、 null を与えるとバイナリ文字列で返す。
     *
     * Example:
     * ```php
     * // 配列をハッシュ化する
     * that(var_hash(['a', 'b', 'c']))->isSame('7BDgx6NE2hkXAKtKzhpeJm6-mheMOQWNgrCe7768OiFeoWgA');
     * // オブジェクトをハッシュ化する
     * that(var_hash(new \ArrayObject(['a', 'b', 'c'])))->isSame('-zR2rZ58CzuYhhdHn1Oq90zkYSaxMS-dHUbmb0MTRM4gBpj2');
     * ```
     *
     * @param mixed $var ハッシュ化する値
     * @param string[] $algos ハッシュアルゴリズム
     * @param ?bool $base64 結果を base64 化するか
     * @return string ハッシュ文字列
     */
    function var_hash($var, $algos = ['md5', 'sha1'], $base64 = true)
    {
        if (!is_string($var)) {
            $var = serialize($var);
        }

        $algos = arrayize($algos);
        assert($algos);

        $hash = '';
        foreach ($algos as $algo) {
            $hash .= hash($algo, "$var", $base64 !== false);
        }

        if ($base64 !== true) {
            return $hash;
        }

        return rtrim(strtr(base64_encode($hash), ['+' => '-', '/' => '_']));
    }
}
if (function_exists("ryunosuke\\dbml\\var_hash") && !defined("ryunosuke\\dbml\\var_hash")) {
    define("ryunosuke\\dbml\\var_hash", "ryunosuke\\dbml\\var_hash");
}

if (!isset($excluded_functions["var_apply"]) && (!function_exists("ryunosuke\\dbml\\var_apply") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\var_apply"))->isInternal()))) {
    /**
     * 値にコールバックを適用する
     *
     * 普通のスカラー値であれば `$callback($var)` と全く同じ。
     * この関数は「$var が配列だったら中身に適用して返す（再帰）」という点で上記とは異なる。
     *
     * 「配列が与えられたら要素に適用して配列で返す、配列じゃないなら直に適用してそれを返す」という状況はまれによくあるはず。
     *
     * Example:
     * ```php
     * // 素の値は素の呼び出しと同じ
     * that(var_apply(' x ', 'trim'))->isSame('x');
     * // 配列は中身に適用して配列で返す（再帰）
     * that(var_apply([' x ', ' y ', [' z ']], 'trim'))->isSame(['x', 'y', ['z']]);
     * // 第3引数以降は残り引数を意味する
     * that(var_apply(['!x!', '!y!'], 'trim', '!'))->isSame(['x', 'y']);
     * // 「まれによくある」の具体例
     * that(var_apply(['<x>', ['<y>']], 'htmlspecialchars', ENT_QUOTES, 'utf-8'))->isSame(['&lt;x&gt;', ['&lt;y&gt;']]);
     * ```
     *
     * @param mixed $var $callback を適用する値
     * @param callable $callback 値変換コールバック
     * @param mixed ...$args $callback の残り引数（可変引数）
     * @return mixed|array $callback が適用された値。元が配列なら配列で返す
     */
    function var_apply($var, $callback, ...$args)
    {
        $iterable = is_iterable($var);
        if ($iterable) {
            $result = [];
            foreach ($var as $k => $v) {
                $result[$k] = var_apply($v, $callback, ...$args);
            }
            return $result;
        }

        return $callback($var, ...$args);
    }
}
if (function_exists("ryunosuke\\dbml\\var_apply") && !defined("ryunosuke\\dbml\\var_apply")) {
    define("ryunosuke\\dbml\\var_apply", "ryunosuke\\dbml\\var_apply");
}

if (!isset($excluded_functions["var_export3"]) && (!function_exists("ryunosuke\\dbml\\var_export3") || (!false && (new \ReflectionFunction("ryunosuke\\dbml\\var_export3"))->isInternal()))) {
    /**
     * var_export を色々と出力できるようにしたもの
     *
     * php のコードに落とし込むことで serialize と比較してかなり高速に動作する。ただし、要 php7.4.
     *
     * 各種オブジェクトやクロージャ、循環参照を含む配列など様々なものが出力できる。
     * ただし、下記は不可能あるいは復元不可（今度も対応するかは未定）。
     *
     * - 無名クラス
     * - Generator クラス
     * - 特定の内部クラス（PDO など）
     * - リソース
     * - php7.4 以降のアロー関数によるクロージャ
     *
     * オブジェクトは「リフレクションを用いてコンストラクタなしで生成してプロパティを代入する」という手法で復元する。
     * のでクラスによってはおかしな状態で復元されることがある（大体はリソース型のせいだが…）。
     * sleep, wakeup, Serializable などが実装されているとそれはそのまま機能する。
     * set_state だけは呼ばれないので注意。
     *
     * クロージャはコード自体を引っ張ってきて普通に function (){} として埋め込む。
     * クラス名のエイリアスや use, $this バインドなど可能な限り復元するが、おそらくあまりに複雑なことをしてると失敗する。
     *
     * 軽くベンチを取ったところ、オブジェクトを含まない純粋な配列の場合、serialize の 200 倍くらいは速い（それでも var_export の方が速いが…）。
     * オブジェクトを含めば含むほど遅くなり、全要素がオブジェクトになると serialize と同程度になる。
     * 大体 var_export:var_export3:serialize が 1:5:1000 くらい。
     *
     * @param mixed $value エクスポートする値
     * @param bool|array $return 返り値として返すなら true. 配列を与えるとオプションになる
     * @return string エクスポートされた文字列
     */
    function var_export3($value, $return = false)
    {
        // 原則として var_export に合わせたいのでデフォルトでは bool: false で単に出力するのみとする
        if (is_bool($return)) {
            $return = [
                'return' => $return,
            ];
        }
        $options = $return;
        $options += [
            'format'  => 'pretty', // pretty or minify
            'outmode' => null,     // null: 本体のみ, 'eval': return ...;, 'file': <?php return ...;
        ];
        $options['return'] = $options['return'] ?? !!$options['outmode'];

        $var_manager = new class() {
            private $vars = [];
            private $refs = [];

            private function arrayHasReference($array)
            {
                foreach ($array as $k => $v) {
                    $ref = \ReflectionReference::fromArrayElement($array, $k);
                    if ($ref) {
                        return true;
                    }
                    if (is_array($v) && $this->arrayHasReference($v)) {
                        return true;
                    }
                }
                return false;
            }

            public function varId($var)
            {
                // オブジェクトは明確な ID が取れる（closure/object の区分けに処理的な意味はない）
                if (is_object($var)) {
                    $id = ($var instanceof \Closure ? 'closure' : 'object') . (spl_object_id($var) + 1);
                    $this->vars[$id] = $var;
                    return $id;
                }
                // 配列は明確な ID が存在しないので、貯めて検索して ID を振る（参照さえ含まなければ ID に意味はないので参照込みのみ）
                if (is_array($var) && $this->arrayHasReference($var)) {
                    $id = array_search($var, $this->vars, true);
                    if (!$id) {
                        $id = 'array' . (count($this->vars) + 1);
                    }
                    $this->vars[$id] = $var;
                    return $id;
                }
            }

            public function refId($array, $k)
            {
                static $ids = [];
                $ref = \ReflectionReference::fromArrayElement($array, $k);
                if ($ref) {
                    $refid = $ref->getId();
                    $ids[$refid] = ($ids[$refid] ?? count($ids) + 1);
                    $id = 'reference' . $ids[$refid];
                    $this->refs[$id] = $array[$k];
                    return $id;
                }
            }

            public function orphan()
            {
                foreach ($this->refs as $rid => $var) {
                    $vid = array_search($var, $this->vars, true);
                    yield $rid => [!!$vid, $vid, $var];
                }
            }
        };

        // 再帰用クロージャ
        $vars = [];
        $export = function ($value, $nest = 0) use (&$export, &$vars, $var_manager) {
            $neighborToken = function ($n, $d, $tokens) {
                for ($i = $n + $d; isset($tokens[$i]); $i += $d) {
                    if ($tokens[$i][0] !== T_WHITESPACE) {
                        return $tokens[$i];
                    }
                }
            };
            $resolveSymbol = function ($token, $prev, $next, $filename) {
                if ($token[0] === T_STRING) {
                    if ($prev[0] === T_NEW || $next[0] === T_DOUBLE_COLON || $next[0] === T_VARIABLE || $next[1] === '{') {
                        $token[1] = resolve_symbol($token[1], $filename, 'alias') ?? $token[1];
                    }
                    elseif ($next[1] === '(') {
                        $token[1] = resolve_symbol($token[1], $filename, 'function') ?? $token[1];
                    }
                    else {
                        $token[1] = resolve_symbol($token[1], $filename, 'const') ?? $token[1];
                    }
                }
                return $token;
            };
            $var_export = function ($v) { return var_export($v, true); };
            $spacer0 = str_repeat(" ", 4 * ($nest + 0));
            $spacer1 = str_repeat(" ", 4 * ($nest + 1));

            $vid = $var_manager->varId($value);
            if ($vid) {
                if (isset($vars[$vid])) {
                    return "\$this->$vid";
                }
                $vars[$vid] = $value;
            }

            if (is_array($value)) {
                $hashed = is_hasharray($value);
                if (!$hashed && array_all($value, is_primitive)) {
                    [$begin, $middle, $end] = ["", ", ", ""];
                }
                else {
                    [$begin, $middle, $end] = ["\n{$spacer1}", ",\n{$spacer1}", ",\n{$spacer0}"];
                }

                $keys = array_map($var_export, array_combine($keys = array_keys($value), $keys));
                $maxlen = max(array_map('strlen', $keys ?: ['']));
                $kvl = [];
                foreach ($value as $k => $v) {
                    $refid = $var_manager->refId($value, $k);
                    $keystr = $hashed ? $keys[$k] . str_repeat(" ", $maxlen - strlen($keys[$k])) . " => " : '';
                    $valstr = $refid ? "&\$this->$refid" : $export($v, $nest + 1);
                    $kvl[] = $keystr . $valstr;
                }
                $kvl = implode($middle, $kvl);
                $declare = $vid ? "\$this->$vid = " : "";
                return "{$declare}[$begin{$kvl}$end]";
            }
            if ($value instanceof \Closure) {
                $ref = new \ReflectionFunction($value);
                $bind = $ref->getClosureThis();
                $class = $ref->getClosureScopeClass() ? $ref->getClosureScopeClass()->getName() : null;
                $statics = $ref->getStaticVariables();

                // 内部由来はきちんと fromCallable しないと差異が出てしまう
                if ($ref->isInternal()) {
                    $receiver = $bind ?? $class;
                    $callee = $receiver ? [$receiver, $ref->getName()] : $ref->getName();
                    return "\$this->$vid = \\Closure::fromCallable({$export($callee, $nest)})";
                }

                $tokens = array_slice(parse_php(implode(' ', callable_code($value)) . ';', TOKEN_PARSE), 1, -1);
                $uses = "";
                $context = [
                    'use'   => false,
                    'class' => 0,
                    'brace' => 0,
                ];
                foreach ($tokens as $n => $token) {
                    $prev = $neighborToken($n, -1, $tokens) ?? [null, null, null];
                    $next = $neighborToken($n, +1, $tokens) ?? [null, null, null];

                    // クロージャは何でもかける（クロージャ・無名クラス・ジェネレータ etc）のでネスト（ブレース）レベルを記録しておく
                    if ($token[1] === '{') {
                        $context['brace']++;
                    }
                    if ($token[1] === '}') {
                        $context['brace']--;
                    }

                    // 無名クラスは色々厄介なので読み飛ばすために覚えておく
                    if ($prev[0] === T_NEW && $token[0] === T_CLASS) {
                        $context['class'] = $context['brace'];
                    }
                    // そして無名クラスは色々かける上に終了条件が自明ではない（シンタックスエラーでない限りは {} が一致するはず）
                    if ($token[1] === '}' && $context['class'] === $context['brace']) {
                        $context['class'] = 0;
                    }

                    // fromCallable 由来だと名前がついてしまう
                    if (!$context['class'] && $prev[0] === T_FUNCTION && $token[0] === T_STRING) {
                        unset($tokens[$n]);
                        continue;
                    }

                    // use 変数の導出
                    if ($prev[1] === ')' && $token[0] === T_USE) {
                        $context['use'] = true;
                    }
                    if ($context['use'] && $token[0] === T_VARIABLE) {
                        $varname = substr($token[1], 1);
                        // クロージャ内クロージャの use に反応してしまうので存在するときのみとする
                        if (array_key_exists($varname, $statics)) {
                            $recurself = $statics[$varname] === $value ? '&' : '';
                            $uses .= "$spacer1\$$varname = $recurself{$export($statics[$varname], $nest + 1)};\n";
                        }
                    }
                    if ($context['use'] && $token[1] === ')') {
                        $context['use'] = false;
                    }

                    $tokens[$n] = $resolveSymbol($token, $prev, $next, $ref->getFileName());
                }

                $code = indent_php(implode('', array_column($tokens, 1)), [
                    'indent'   => $spacer1,
                    'baseline' => -1,
                ]);
                if ($bind) {
                    $scope = $var_export($class === 'Closure' ? 'static' : $class);
                    $code = "\Closure::bind($code, {$export($bind, $nest + 1)}, $scope)";
                }
                elseif (!is_bindable_closure($value)) {
                    $code = "static $code";
                }

                return "\$this->$vid = (function () {\n{$uses}{$spacer1}return $code;\n$spacer0})->call(\$this)";
            }
            if (is_object($value)) {
                $ref = new \ReflectionObject($value);

                // ジェネレータはどう頑張っても無理
                if ($value instanceof \Generator) {
                    throw new \DomainException('Generator Class is not support.');
                }

                // 無名クラスは定義がないのでパースが必要
                // さらにコンストラクタを呼ぶわけには行かない（引数を検出するのは不可能）ので潰す必要もある
                if ($ref->isAnonymous()) {
                    $fname = $ref->getFileName();
                    $sline = $ref->getStartLine();
                    $eline = $ref->getEndLine();
                    $tokens = parse_php(implode('', array_slice(file($fname), $sline - 1, $eline - $sline + 1)));

                    $block = [];
                    $starting = false;
                    $constructing = 0;
                    $nesting = 0;
                    foreach ($tokens as $n => $token) {
                        $prev = $neighborToken($n, -1, $tokens) ?? [null, null, null];
                        $next = $neighborToken($n, +1, $tokens) ?? [null, null, null];

                        // 無名クラスは new class で始まるはず
                        if ($token[0] === T_NEW && $next[0] === T_CLASS) {
                            $starting = true;
                        }
                        if (!$starting) {
                            continue;
                        }

                        // コンストラクタの呼び出し引数はスキップする
                        if ($constructing !== null) {
                            if ($token[1] === '(') {
                                $constructing++;
                            }
                            if ($token[1] === ')') {
                                $constructing--;
                                if ($constructing === 0) {
                                    $constructing = null;          // null を終了済みマークとして変数を再利用している
                                    $block[] = [null, '()', null]; // for psr-12
                                    continue;
                                }
                            }
                            if ($constructing) {
                                continue;
                            }
                        }

                        // コンストラクタは呼ばないのでリネームしておく
                        if ($token[1] === '__construct') {
                            $token[1] = "replaced__construct";
                        }

                        $block[] = $resolveSymbol($token, $prev, $next, $ref->getFileName());

                        if ($token[1] === '{') {
                            $nesting++;
                        }
                        if ($token[1] === '}') {
                            $nesting--;
                            if ($nesting === 0) {
                                break;
                            }
                        }
                    }

                    $code = indent_php(implode('', array_column($block, 1)), [
                        'indent'   => $spacer1,
                        'baseline' => -1,
                    ]);
                    $classname = "(function () {\n{$spacer1}return $code;\n{$spacer0}})";
                }
                else {
                    $classname = "\\" . get_class($value) . "::class";
                }

                $privates = [];

                // __serialize があるならそれに従う
                if (method_exists($value, '__serialize')) {
                    $fields = $value->__serialize();
                }
                // __sleep があるならそれをプロパティとする
                elseif (method_exists($value, '__sleep')) {
                    $fields = array_intersect_key(get_object_properties($value, $privates), array_flip($value->__sleep()));
                }
                // それ以外は適当に漁る
                else {
                    $fields = get_object_properties($value, $privates);
                }

                return "\$this->new(\$this->$vid, $classname, (function () {\n{$spacer1}return {$export([$fields, $privates], $nest + 1)};\n{$spacer0}}))";
            }

            return is_null($value) || is_resource($value) ? 'null' : $var_export($value);
        };

        $exported = $export($value, 1);
        $others = "";
        $vars = [];
        foreach ($var_manager->orphan() as $rid => [$isref, $vid, $var]) {
            $declare = $isref ? "&\$this->$vid" : $export($var, 1);
            $others .= "    \$this->$rid = $declare;\n";
        }
        $result = "(function () {
{$others}    return $exported;
" . '})->call(new class() {
    public function new(&$object, $class, $provider)
    {
        if ($class instanceof \\Closure) {
            $object = $class();
            $reflection = $this->reflect(get_class($object));
        }
        else {
            $reflection = $this->reflect($class);
            $object = $reflection["self"]->newInstanceWithoutConstructor();
        }
        [$fields, $privates] = $provider();

        if ($reflection["unserialize"]) {
            $object->__unserialize($fields);
            return $object;
        }

        foreach ($reflection["parents"] as $parent) {
            foreach ($this->reflect($parent->name)["properties"] as $name => $property) {
                if (isset($privates[$parent->name][$name])) {
                    $property->setValue($object, $privates[$parent->name][$name]);
                }
                if (isset($fields[$name]) || array_key_exists($name, $fields)) {
                    $property->setValue($object, $fields[$name]);
                    unset($fields[$name]);
                }
            }
        }
        foreach ($fields as $name => $value) {
            $object->$name = $value;
        }

        if ($reflection["wakeup"]) {
            $object->__wakeup();
        }

        return $object;
    }

    private function reflect($class)
    {
        static $cache = [];
        if (!isset($cache[$class])) {
            $refclass = new \ReflectionClass($class);
            $cache[$class] = [
                "self"        => $refclass,
                "parents"     => [],
                "properties"  => [],
                "unserialize" => $refclass->hasMethod("__unserialize"),
                "wakeup"      => $refclass->hasMethod("__wakeup"),
            ];
            for ($current = $refclass; $current; $current = $current->getParentClass()) {
                $cache[$class]["parents"][$current->name] = $current;
            }
            foreach ($refclass->getProperties() as $property) {
                if (!$property->isStatic()) {
                    $property->setAccessible(true);
                    $cache[$class]["properties"][$property->name] = $property;
                }
            }
        }
        return $cache[$class];
    }
})';

        if ($options['format'] === 'minify') {
            $tmp = memory_path('var_export3.php');
            file_put_contents($tmp, "<?php $result;");
            $result = substr(php_strip_whitespace($tmp), 6, -1);
        }

        if ($options['outmode'] === 'eval') {
            $result = "return $result;";
        }
        if ($options['outmode'] === 'file') {
            $result = "<?php return $result;\n";
        }

        if (!$options['return']) {
            echo $result;
        }
        return $result;
    }
}
if (function_exists("ryunosuke\\dbml\\var_export3") && !defined("ryunosuke\\dbml\\var_export3")) {
    define("ryunosuke\\dbml\\var_export3", "ryunosuke\\dbml\\var_export3");
}
